/* soapStub.h
   Generated by gSOAP 2.8.28 from ../../wsdl/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_WSDD_2005
#define SOAP_WSA_200408
#define SOAP_NAMESPACE_OF_wsdd	"http://schemas.xmlsoap.org/ws/2005/04/discovery"
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_tmd	"http://www.onvif.org/ver10/deviceIO/wsdl"
#define SOAP_NAMESPACE_OF_trt	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tev	"http://www.onvif.org/ver10/events/wsdl"
#define SOAP_NAMESPACE_OF_wsrfrw	"http://docs.oasis-open.org/wsrf/rw-2"
#define SOAP_NAMESPACE_OF_wsrfr	"http://docs.oasis-open.org/wsrf/r-2"
#define SOAP_NAMESPACE_OF_tls	"http://www.onvif.org/ver10/display/wsdl"
#define SOAP_NAMESPACE_OF_timg	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_tptz	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_trv	"http://www.onvif.org/ver10/receiver/wsdl"
#define SOAP_NAMESPACE_OF_trc	"http://www.onvif.org/ver10/recording/wsdl"
#define SOAP_NAMESPACE_OF_tse	"http://www.onvif.org/ver10/search/wsdl"
#define SOAP_NAMESPACE_OF_tdn	"http://www.onvif.org/ver10/network/wsdl"
#define SOAP_NAMESPACE_OF_trp	"http://www.onvif.org/ver10/replay/wsdl"
#define SOAP_NAMESPACE_OF_tan	"http://www.onvif.org/ver20/analytics/wsdl"
#define SOAP_NAMESPACE_OF_tad	"http://www.onvif.org/ver10/analyticsdevice/wsdl"
#define SOAP_NAMESPACE_OF_ns1	"http://www.onvif.org/ver10/actionengine/wsdl"
#define SOAP_NAMESPACE_OF_ns2	"http://www.onvif.org/ver10/accesscontrol/wsdl"
#define SOAP_NAMESPACE_OF_ns3	"http://www.onvif.org/ver10/pacs"
#define SOAP_NAMESPACE_OF_ns4	"http://www.onvif.org/ver10/doorcontrol/wsdl"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* wsa.h:119 */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (12)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues
{
	wsa__Reply = 0
};
#endif

/* wsa.h:127 */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (13)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues
{
	wsa__InvalidMessageInformationHeader = 0,
	wsa__MessageInformationHeaderRequired = 1,
	wsa__DestinationUnreachable = 2,
	wsa__ActionNotSupported = 3,
	wsa__EndpointUnavailable = 4
};
#endif

/* wsdd10.h:111 */
#ifndef SOAP_TYPE_wsdd__FaultCodeType
#define SOAP_TYPE_wsdd__FaultCodeType (58)
/* wsdd:FaultCodeType */
enum wsdd__FaultCodeType
{
	wsdd__MatchingRuleNotSupported = 0
};
#endif

/* wsa5.h:94 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (93)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType
{
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:102 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (94)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType
{
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:252 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (113)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter
{
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* ../../wsdl/onvif.h:4403 */
#ifndef SOAP_TYPE_tmd__SerialPortType
#define SOAP_TYPE_tmd__SerialPortType (1409)
/* tmd:SerialPortType */
enum tmd__SerialPortType
{
	tmd__SerialPortType__RS232 = 0,
	tmd__SerialPortType__RS422HalfDuplex = 1,
	tmd__SerialPortType__RS422FullDuplex = 2,
	tmd__SerialPortType__RS485HalfDuplex = 3,
	tmd__SerialPortType__RS485FullDuplex = 4,
	tmd__SerialPortType__Generic = 5
};
#endif

/* ../../wsdl/onvif.h:4426 */
#ifndef SOAP_TYPE_tmd__ParityBit
#define SOAP_TYPE_tmd__ParityBit (1411)
/* tmd:ParityBit */
enum tmd__ParityBit
{
	tmd__ParityBit__None = 0,
	tmd__ParityBit__Even = 1,
	tmd__ParityBit__Odd = 2,
	tmd__ParityBit__Mark = 3,
	tmd__ParityBit__Space = 4,
	tmd__ParityBit__Extended = 5
};
#endif

/* ../../wsdl/onvif.h:4494 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (1417)
/* tt:RotateMode */
enum tt__RotateMode
{
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* ../../wsdl/onvif.h:4511 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (1419)
/* tt:VideoEncoding */
enum tt__VideoEncoding
{
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* ../../wsdl/onvif.h:4528 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (1421)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile
{
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* ../../wsdl/onvif.h:4544 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (1423)
/* tt:H264Profile */
enum tt__H264Profile
{
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* ../../wsdl/onvif.h:4562 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (1425)
/* tt:AudioEncoding */
enum tt__AudioEncoding
{
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* ../../wsdl/onvif.h:4579 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (1427)
/* tt:StreamType */
enum tt__StreamType
{
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* ../../wsdl/onvif.h:4595 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (1429)
/* tt:TransportProtocol */
enum tt__TransportProtocol
{
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* ../../wsdl/onvif.h:4613 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (1431)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition
{
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* ../../wsdl/onvif.h:4629 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (1433)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode
{
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* ../../wsdl/onvif.h:4657 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (1437)
/* tt:Duplex */
enum tt__Duplex
{
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* ../../wsdl/onvif.h:4687 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (1441)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration
{
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* ../../wsdl/onvif.h:4705 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (1443)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType
{
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* ../../wsdl/onvif.h:4722 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (1445)
/* tt:NetworkHostType */
enum tt__NetworkHostType
{
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* ../../wsdl/onvif.h:4772 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (1453)
/* tt:IPType */
enum tt__IPType
{
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* ../../wsdl/onvif.h:4810 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (1459)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType
{
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* ../../wsdl/onvif.h:4826 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (1461)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType
{
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* ../../wsdl/onvif.h:4855 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (1465)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode
{
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* ../../wsdl/onvif.h:4872 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (1467)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode
{
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* ../../wsdl/onvif.h:4891 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (1469)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher
{
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:4933 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (1475)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength
{
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* ../../wsdl/onvif.h:4953 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (1477)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite
{
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:4971 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (1479)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory
{
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* ../../wsdl/onvif.h:4995 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (1481)
/* tt:SystemLogType */
enum tt__SystemLogType
{
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* ../../wsdl/onvif.h:5020 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (1483)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType
{
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* ../../wsdl/onvif.h:5042 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (1485)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType
{
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* ../../wsdl/onvif.h:5064 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (1487)
/* tt:UserLevel */
enum tt__UserLevel
{
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* ../../wsdl/onvif.h:5083 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (1489)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState
{
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* ../../wsdl/onvif.h:5099 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (1491)
/* tt:RelayIdleState */
enum tt__RelayIdleState
{
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* ../../wsdl/onvif.h:5115 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (1493)
/* tt:RelayMode */
enum tt__RelayMode
{
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* ../../wsdl/onvif.h:5131 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (1495)
/* tt:EFlipMode */
enum tt__EFlipMode
{
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* ../../wsdl/onvif.h:5148 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (1497)
/* tt:ReverseMode */
enum tt__ReverseMode
{
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5178 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1501)
/* tt:MoveStatus */
enum tt__MoveStatus
{
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/* ../../wsdl/onvif.h:5195 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (1503)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState
{
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5213 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (1505)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection
{
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* ../../wsdl/onvif.h:5230 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (1507)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation
{
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5248 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (1509)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode
{
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* ../../wsdl/onvif.h:5264 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (1511)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode
{
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* ../../wsdl/onvif.h:5283 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (1513)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode
{
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* ../../wsdl/onvif.h:5305 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (1515)
/* tt:ExposurePriority */
enum tt__ExposurePriority
{
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* ../../wsdl/onvif.h:5321 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (1517)
/* tt:ExposureMode */
enum tt__ExposureMode
{
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* ../../wsdl/onvif.h:5337 */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (1519)
/* tt:Enabled */
enum tt__Enabled
{
	tt__Enabled__ENABLED = 0,
	tt__Enabled__DISABLED = 1
};
#endif

/* ../../wsdl/onvif.h:5353 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (1521)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode
{
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* ../../wsdl/onvif.h:5369 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (1523)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode
{
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* ../../wsdl/onvif.h:5386 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (1525)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode
{
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5415 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (1529)
/* tt:PropertyOperation */
enum tt__PropertyOperation
{
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* ../../wsdl/onvif.h:5432 */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (1531)
/* tt:Direction */
enum tt__Direction
{
	tt__Direction__Left = 0,
	tt__Direction__Right = 1,
	tt__Direction__Any = 2
};
#endif

/* ../../wsdl/onvif.h:5449 */
#ifndef SOAP_TYPE_tt__ClassType
#define SOAP_TYPE_tt__ClassType (1533)
/* tt:ClassType */
enum tt__ClassType
{
	tt__ClassType__Animal = 0,
	tt__ClassType__Face = 1,
	tt__ClassType__Human = 2,
	tt__ClassType__Vehical = 3,
	tt__ClassType__Other = 4
};
#endif

/* ../../wsdl/onvif.h:5471 */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (1535)
/* tt:ReceiverMode */
enum tt__ReceiverMode
{
	tt__ReceiverMode__AutoConnect = 0,
	tt__ReceiverMode__AlwaysConnect = 1,
	tt__ReceiverMode__NeverConnect = 2,
	tt__ReceiverMode__Unknown = 3
};
#endif

/* ../../wsdl/onvif.h:5504 */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (1537)
/* tt:ReceiverState */
enum tt__ReceiverState
{
	tt__ReceiverState__NotConnected = 0,
	tt__ReceiverState__Connecting = 1,
	tt__ReceiverState__Connected = 2,
	tt__ReceiverState__Unknown = 3
};
#endif

/* ../../wsdl/onvif.h:5556 */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (1543)
/* tt:SearchState */
enum tt__SearchState
{
	tt__SearchState__Queued = 0,
	tt__SearchState__Searching = 1,
	tt__SearchState__Completed = 2,
	tt__SearchState__Unknown = 3
};
#endif

/* ../../wsdl/onvif.h:5586 */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (1545)
/* tt:RecordingStatus */
enum tt__RecordingStatus
{
	tt__RecordingStatus__Initiated = 0,
	tt__RecordingStatus__Recording = 1,
	tt__RecordingStatus__Stopped = 2,
	tt__RecordingStatus__Removing = 3,
	tt__RecordingStatus__Removed = 4,
	tt__RecordingStatus__Unknown = 5
};
#endif

/* ../../wsdl/onvif.h:5609 */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (1547)
/* tt:TrackType */
enum tt__TrackType
{
	tt__TrackType__Video = 0,
	tt__TrackType__Audio = 1,
	tt__TrackType__Metadata = 2,
	tt__TrackType__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5652 */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (1553)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation
{
	tt__ModeOfOperation__Idle = 0,
	tt__ModeOfOperation__Active = 1,
	tt__ModeOfOperation__Unknown = 2
};
#endif

/* ../../wsdl/onvif.h:5870 */
#ifndef SOAP_TYPE_ns1__AddressFormatType
#define SOAP_TYPE_ns1__AddressFormatType (1561)
/* ns1:AddressFormatType */
enum ns1__AddressFormatType
{
	ns1__AddressFormatType__hostname = 0,
	ns1__AddressFormatType__ipv4 = 1,
	ns1__AddressFormatType__ipv6 = 2,
	ns1__AddressFormatType__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5888 */
#ifndef SOAP_TYPE_ns1__EMailAuthenticationMode
#define SOAP_TYPE_ns1__EMailAuthenticationMode (1563)
/* ns1:EMailAuthenticationMode */
enum ns1__EMailAuthenticationMode
{
	ns1__EMailAuthenticationMode__none = 0,
	ns1__EMailAuthenticationMode__SMTP = 1,
	ns1__EMailAuthenticationMode__POPSMTP = 2,
	ns1__EMailAuthenticationMode__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5906 */
#ifndef SOAP_TYPE_ns1__HttpProtocolType
#define SOAP_TYPE_ns1__HttpProtocolType (1565)
/* ns1:HttpProtocolType */
enum ns1__HttpProtocolType
{
	ns1__HttpProtocolType__http = 0,
	ns1__HttpProtocolType__https = 1,
	ns1__HttpProtocolType__Extended = 2
};
#endif

/* ../../wsdl/onvif.h:5923 */
#ifndef SOAP_TYPE_ns1__HttpAuthenticationMethodType
#define SOAP_TYPE_ns1__HttpAuthenticationMethodType (1567)
/* ns1:HttpAuthenticationMethodType */
enum ns1__HttpAuthenticationMethodType
{
	ns1__HttpAuthenticationMethodType__none = 0,
	ns1__HttpAuthenticationMethodType__MD5Digest = 1,
	ns1__HttpAuthenticationMethodType__Extended = 2
};
#endif

/* ../../wsdl/onvif.h:5940 */
#ifndef SOAP_TYPE_ns1__FileSuffixType
#define SOAP_TYPE_ns1__FileSuffixType (1569)
/* ns1:FileSuffixType */
enum ns1__FileSuffixType
{
	ns1__FileSuffixType__none = 0,
	ns1__FileSuffixType__sequence = 1,
	ns1__FileSuffixType__dateTime = 2,
	ns1__FileSuffixType__Extended = 3
};
#endif

/* ../../wsdl/onvif.h:5969 */
#ifndef SOAP_TYPE_ns2__Decision
#define SOAP_TYPE_ns2__Decision (1571)
/* ns2:Decision */
enum ns2__Decision
{
	ns2__Decision__Granted = 0,
	ns2__Decision__Denied = 1
};
#endif

/* ../../wsdl/onvif.h:5995 */
#ifndef SOAP_TYPE_ns2__DenyReason
#define SOAP_TYPE_ns2__DenyReason (1573)
/* ns2:DenyReason */
enum ns2__DenyReason
{
	ns2__DenyReason__CredentialNotEnabled = 0,
	ns2__DenyReason__CredentialNotActive = 1,
	ns2__DenyReason__CredentialExpired = 2,
	ns2__DenyReason__InvalidPIN = 3,
	ns2__DenyReason__NotPermittedAtThisTime = 4,
	ns2__DenyReason__Unauthorized = 5,
	ns2__DenyReason__Other = 6
};
#endif

/* ../../wsdl/onvif.h:6103 */
#ifndef SOAP_TYPE_ns4__DoorPhysicalState
#define SOAP_TYPE_ns4__DoorPhysicalState (1581)
/* ns4:DoorPhysicalState */
enum ns4__DoorPhysicalState
{
	ns4__DoorPhysicalState__Unknown = 0,
	ns4__DoorPhysicalState__Open = 1,
	ns4__DoorPhysicalState__Closed = 2,
	ns4__DoorPhysicalState__Fault = 3
};
#endif

/* ../../wsdl/onvif.h:6136 */
#ifndef SOAP_TYPE_ns4__LockPhysicalState
#define SOAP_TYPE_ns4__LockPhysicalState (1583)
/* ns4:LockPhysicalState */
enum ns4__LockPhysicalState
{
	ns4__LockPhysicalState__Unknown = 0,
	ns4__LockPhysicalState__Locked = 1,
	ns4__LockPhysicalState__Unlocked = 2,
	ns4__LockPhysicalState__Fault = 3
};
#endif

/* ../../wsdl/onvif.h:6169 */
#ifndef SOAP_TYPE_ns4__DoorAlarmState
#define SOAP_TYPE_ns4__DoorAlarmState (1585)
/* ns4:DoorAlarmState */
enum ns4__DoorAlarmState
{
	ns4__DoorAlarmState__Normal = 0,
	ns4__DoorAlarmState__DoorForcedOpen = 1,
	ns4__DoorAlarmState__DoorOpenTooLong = 2
};
#endif

/* ../../wsdl/onvif.h:6198 */
#ifndef SOAP_TYPE_ns4__DoorTamperState
#define SOAP_TYPE_ns4__DoorTamperState (1587)
/* ns4:DoorTamperState */
enum ns4__DoorTamperState
{
	ns4__DoorTamperState__Unknown = 0,
	ns4__DoorTamperState__NotInTamper = 1,
	ns4__DoorTamperState__TamperDetected = 2
};
#endif

/* ../../wsdl/onvif.h:6227 */
#ifndef SOAP_TYPE_ns4__DoorFaultState
#define SOAP_TYPE_ns4__DoorFaultState (1589)
/* ns4:DoorFaultState */
enum ns4__DoorFaultState
{
	ns4__DoorFaultState__Unknown = 0,
	ns4__DoorFaultState__NotInFault = 1,
	ns4__DoorFaultState__FaultDetected = 2
};
#endif

/* ../../wsdl/onvif.h:6256 */
#ifndef SOAP_TYPE_ns4__DoorMode
#define SOAP_TYPE_ns4__DoorMode (1591)
/* ns4:DoorMode */
enum ns4__DoorMode
{
	ns4__DoorMode__Unknown = 0,
	ns4__DoorMode__Locked = 1,
	ns4__DoorMode__Unlocked = 2,
	ns4__DoorMode__Accessed = 3,
	ns4__DoorMode__Blocked = 4,
	ns4__DoorMode__LockedDown = 5,
	ns4__DoorMode__LockedOpen = 6,
	ns4__DoorMode__DoubleLocked = 7
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (130)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct wsa__EndpointReferenceType;	/* wsa.h:94 */
struct wsa__ReferencePropertiesType;	/* wsa.h:97 */
struct wsa__ReferenceParametersType;	/* wsa.h:100 */
struct wsa__ServiceNameType;	/* wsa.h:103 */
struct wsa__Relationship;	/* wsa.h:106 */
struct wsdd__HelloType;	/* wsdd10.h:57 */
struct wsdd__ByeType;	/* wsdd10.h:60 */
struct wsdd__ProbeType;	/* wsdd10.h:63 */
struct wsdd__ProbeMatchesType;	/* wsdd10.h:66 */
struct wsdd__ProbeMatchType;	/* wsdd10.h:69 */
struct wsdd__ResolveType;	/* wsdd10.h:72 */
struct wsdd__ResolveMatchesType;	/* wsdd10.h:75 */
struct wsdd__ResolveMatchType;	/* wsdd10.h:78 */
struct wsdd__SecurityType;	/* wsdd10.h:84 */
struct wsdd__SigType;	/* wsdd10.h:87 */
struct wsdd__ScopesType;	/* wsdd10.h:81 */
struct wsdd__AppSequenceType;	/* wsdd10.h:90 */
struct __wsdd__Hello;	/* wsdx.h:67 */
struct __wsdd__Bye;	/* wsdx.h:76 */
struct __wsdd__Probe;	/* wsdx.h:85 */
struct __wsdd__ProbeMatches;	/* wsdx.h:94 */
struct __wsdd__Resolve;	/* wsdx.h:103 */
struct __wsdd__ResolveMatches;	/* wsdx.h:112 */
struct _xop__Include;	/* xop.h:58 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:63 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:66 */
struct wsa5__MetadataType;	/* wsa5.h:69 */
struct wsa5__ProblemActionType;	/* wsa5.h:84 */
struct wsa5__RelatesToType;	/* wsa5.h:72 */
struct chan__ChannelInstanceType;	/* wsa5.h:258 */
struct SOAP_ENV__Fault_yz;	/* wsa5.h:288 */
class xsd__anyType;	/* ../../wsdl/onvif.h:271 */
struct SOAP_ENV__Envelope;	/* ../../wsdl/onvif.h:274 */
class xsd__base64Binary;	/* ../../wsdl/onvif.h:277 */
class xsd__hexBinary;	/* ../../wsdl/onvif.h:288 */
class xsd__NCName_;	/* ../../wsdl/onvif.h:296 */
class xsd__QName;	/* ../../wsdl/onvif.h:303 */
class xsd__anySimpleType_;	/* ../../wsdl/onvif.h:313 */
class xsd__anyURI_;	/* ../../wsdl/onvif.h:323 */
class xsd__base64Binary_;	/* ../../wsdl/onvif.h:330 */
class xsd__boolean;	/* ../../wsdl/onvif.h:337 */
class xsd__dateTime;	/* ../../wsdl/onvif.h:344 */
class xsd__duration_;	/* ../../wsdl/onvif.h:351 */
class xsd__float;	/* ../../wsdl/onvif.h:358 */
class xsd__hexBinary_;	/* ../../wsdl/onvif.h:365 */
class xsd__int;	/* ../../wsdl/onvif.h:372 */
class xsd__integer_;	/* ../../wsdl/onvif.h:382 */
class xsd__nonNegativeInteger_;	/* ../../wsdl/onvif.h:392 */
class xsd__positiveInteger_;	/* ../../wsdl/onvif.h:402 */
class xsd__string;	/* ../../wsdl/onvif.h:409 */
class xsd__token_;	/* ../../wsdl/onvif.h:419 */
class xsd__unsignedInt;	/* ../../wsdl/onvif.h:426 */
class tmd__SerialPortType_;	/* ../../wsdl/onvif.h:4414 */
class tmd__ParityBit_;	/* ../../wsdl/onvif.h:4437 */
class tt__ReferenceToken__;	/* ../../wsdl/onvif.h:4470 */
class tt__Name__;	/* ../../wsdl/onvif.h:4485 */
class tt__RotateMode_;	/* ../../wsdl/onvif.h:4502 */
class tt__VideoEncoding_;	/* ../../wsdl/onvif.h:4519 */
class tt__Mpeg4Profile_;	/* ../../wsdl/onvif.h:4535 */
class tt__H264Profile_;	/* ../../wsdl/onvif.h:4553 */
class tt__AudioEncoding_;	/* ../../wsdl/onvif.h:4570 */
class tt__StreamType_;	/* ../../wsdl/onvif.h:4586 */
class tt__TransportProtocol_;	/* ../../wsdl/onvif.h:4604 */
class tt__ScopeDefinition_;	/* ../../wsdl/onvif.h:4620 */
class tt__DiscoveryMode_;	/* ../../wsdl/onvif.h:4636 */
class tt__NetworkInterfaceConfigPriority__;	/* ../../wsdl/onvif.h:4648 */
class tt__Duplex_;	/* ../../wsdl/onvif.h:4664 */
class tt__IANA_IfTypes__;	/* ../../wsdl/onvif.h:4678 */
class tt__IPv6DHCPConfiguration_;	/* ../../wsdl/onvif.h:4696 */
class tt__NetworkProtocolType_;	/* ../../wsdl/onvif.h:4713 */
class tt__NetworkHostType_;	/* ../../wsdl/onvif.h:4730 */
class tt__IPv4Address__;	/* ../../wsdl/onvif.h:4741 */
class tt__IPv6Address__;	/* ../../wsdl/onvif.h:4752 */
class tt__HwAddress__;	/* ../../wsdl/onvif.h:4763 */
class tt__IPType_;	/* ../../wsdl/onvif.h:4779 */
class tt__DNSName__;	/* ../../wsdl/onvif.h:4790 */
class tt__Domain__;	/* ../../wsdl/onvif.h:4801 */
class tt__IPAddressFilterType_;	/* ../../wsdl/onvif.h:4817 */
class tt__DynamicDNSType_;	/* ../../wsdl/onvif.h:4834 */
class tt__Dot11SSIDType__;	/* ../../wsdl/onvif.h:4846 */
class tt__Dot11StationMode_;	/* ../../wsdl/onvif.h:4863 */
class tt__Dot11SecurityMode_;	/* ../../wsdl/onvif.h:4882 */
class tt__Dot11Cipher_;	/* ../../wsdl/onvif.h:4900 */
class tt__Dot11PSK__;	/* ../../wsdl/onvif.h:4912 */
class tt__Dot11PSKPassphrase__;	/* ../../wsdl/onvif.h:4924 */
class tt__Dot11SignalStrength_;	/* ../../wsdl/onvif.h:4944 */
class tt__Dot11AuthAndMangementSuite_;	/* ../../wsdl/onvif.h:4962 */
class tt__CapabilityCategory_;	/* ../../wsdl/onvif.h:4983 */
class tt__SystemLogType_;	/* ../../wsdl/onvif.h:5008 */
class tt__FactoryDefaultType_;	/* ../../wsdl/onvif.h:5033 */
class tt__SetDateTimeType_;	/* ../../wsdl/onvif.h:5055 */
class tt__UserLevel_;	/* ../../wsdl/onvif.h:5074 */
class tt__RelayLogicalState_;	/* ../../wsdl/onvif.h:5090 */
class tt__RelayIdleState_;	/* ../../wsdl/onvif.h:5106 */
class tt__RelayMode_;	/* ../../wsdl/onvif.h:5122 */
class tt__EFlipMode_;	/* ../../wsdl/onvif.h:5139 */
class tt__ReverseMode_;	/* ../../wsdl/onvif.h:5157 */
class tt__AuxiliaryData__;	/* ../../wsdl/onvif.h:5169 */
class tt__MoveStatus_;	/* ../../wsdl/onvif.h:5186 */
class tt__PTZPresetTourState_;	/* ../../wsdl/onvif.h:5204 */
class tt__PTZPresetTourDirection_;	/* ../../wsdl/onvif.h:5221 */
class tt__PTZPresetTourOperation_;	/* ../../wsdl/onvif.h:5239 */
class tt__AutoFocusMode_;	/* ../../wsdl/onvif.h:5255 */
class tt__WideDynamicMode_;	/* ../../wsdl/onvif.h:5271 */
class tt__BacklightCompensationMode_;	/* ../../wsdl/onvif.h:5296 */
class tt__ExposurePriority_;	/* ../../wsdl/onvif.h:5312 */
class tt__ExposureMode_;	/* ../../wsdl/onvif.h:5328 */
class tt__Enabled_;	/* ../../wsdl/onvif.h:5344 */
class tt__WhiteBalanceMode_;	/* ../../wsdl/onvif.h:5360 */
class tt__IrCutFilterMode_;	/* ../../wsdl/onvif.h:5377 */
class tt__ImageStabilizationMode_;	/* ../../wsdl/onvif.h:5395 */
class tt__TopicNamespaceLocation__;	/* ../../wsdl/onvif.h:5406 */
class tt__PropertyOperation_;	/* ../../wsdl/onvif.h:5423 */
class tt__Direction_;	/* ../../wsdl/onvif.h:5440 */
class tt__ClassType_;	/* ../../wsdl/onvif.h:5459 */
class tt__ReceiverMode_;	/* ../../wsdl/onvif.h:5492 */
class tt__ReceiverState_;	/* ../../wsdl/onvif.h:5525 */
class tt__Description__;	/* ../../wsdl/onvif.h:5536 */
class tt__XPathExpression__;	/* ../../wsdl/onvif.h:5547 */
class tt__SearchState_;	/* ../../wsdl/onvif.h:5577 */
class tt__RecordingStatus_;	/* ../../wsdl/onvif.h:5600 */
class tt__TrackType_;	/* ../../wsdl/onvif.h:5621 */
class tt__RecordingJobMode__;	/* ../../wsdl/onvif.h:5632 */
class tt__RecordingJobState__;	/* ../../wsdl/onvif.h:5643 */
class tt__ModeOfOperation_;	/* ../../wsdl/onvif.h:5663 */
class wstop__FullTopicExpression__;	/* ../../wsdl/onvif.h:5702 */
class wstop__ConcreteTopicExpression__;	/* ../../wsdl/onvif.h:5718 */
class wstop__SimpleTopicExpression__;	/* ../../wsdl/onvif.h:5733 */
class ns1__AddressFormatType_;	/* ../../wsdl/onvif.h:5879 */
class ns1__EMailAuthenticationMode_;	/* ../../wsdl/onvif.h:5897 */
class ns1__HttpProtocolType_;	/* ../../wsdl/onvif.h:5914 */
class ns1__HttpAuthenticationMethodType_;	/* ../../wsdl/onvif.h:5931 */
class ns1__FileSuffixType_;	/* ../../wsdl/onvif.h:5949 */
class ns2__Decision_;	/* ../../wsdl/onvif.h:5982 */
class ns2__DenyReason_;	/* ../../wsdl/onvif.h:6028 */
class ns3__ReferenceToken__;	/* ../../wsdl/onvif.h:6051 */
class ns3__Name__;	/* ../../wsdl/onvif.h:6066 */
class ns3__Description__;	/* ../../wsdl/onvif.h:6083 */
class ns4__DoorPhysicalState_;	/* ../../wsdl/onvif.h:6124 */
class ns4__LockPhysicalState_;	/* ../../wsdl/onvif.h:6157 */
class ns4__DoorAlarmState_;	/* ../../wsdl/onvif.h:6186 */
class ns4__DoorTamperState_;	/* ../../wsdl/onvif.h:6215 */
class ns4__DoorFaultState_;	/* ../../wsdl/onvif.h:6244 */
class ns4__DoorMode_;	/* ../../wsdl/onvif.h:6293 */
class tt__ReceiverReference__;	/* ../../wsdl/onvif.h:6304 */
class tt__RecordingReference__;	/* ../../wsdl/onvif.h:6315 */
class tt__TrackReference__;	/* ../../wsdl/onvif.h:6326 */
class tt__JobToken__;	/* ../../wsdl/onvif.h:6337 */
class tt__RecordingJobReference__;	/* ../../wsdl/onvif.h:6348 */
class tmd__Capabilities;	/* ../../wsdl/onvif.h:444 */
class tmd__RelayOutputOptions;	/* ../../wsdl/onvif.h:447 */
class tmd__RelayOutputOptionsExtension;	/* ../../wsdl/onvif.h:450 */
union _tmd__union_SerialData;	/* ../../wsdl/onvif.h:6700 */
class tmd__SerialData;	/* ../../wsdl/onvif.h:453 */
class tmd__SerialPortConfiguration;	/* ../../wsdl/onvif.h:459 */
class tmd__SerialPortConfigurationOptions;	/* ../../wsdl/onvif.h:462 */
class tmd__ParityBitList;	/* ../../wsdl/onvif.h:465 */
class _tmd__GetServiceCapabilities;	/* ../../wsdl/onvif.h:468 */
class _tmd__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:471 */
class _tmd__GetRelayOutputOptions;	/* ../../wsdl/onvif.h:474 */
class _tmd__GetRelayOutputOptionsResponse;	/* ../../wsdl/onvif.h:477 */
class _tmd__GetVideoOutputs;	/* ../../wsdl/onvif.h:480 */
class _tmd__GetVideoOutputsResponse;	/* ../../wsdl/onvif.h:483 */
class _tmd__GetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:486 */
class _tmd__GetAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:489 */
class _tmd__GetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:492 */
class _tmd__GetAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:495 */
class _tmd__GetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:498 */
class _tmd__GetVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:501 */
class _tmd__GetVideoOutputConfiguration;	/* ../../wsdl/onvif.h:504 */
class _tmd__GetVideoOutputConfigurationResponse;	/* ../../wsdl/onvif.h:507 */
class _tmd__SetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:510 */
class _tmd__SetAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:513 */
class _tmd__SetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:516 */
class _tmd__SetAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:519 */
class _tmd__SetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:522 */
class _tmd__SetVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:525 */
class _tmd__SetVideoOutputConfiguration;	/* ../../wsdl/onvif.h:528 */
class _tmd__SetVideoOutputConfigurationResponse;	/* ../../wsdl/onvif.h:531 */
class _tmd__GetVideoSourceConfigurationOptions;	/* ../../wsdl/onvif.h:534 */
class _tmd__GetVideoSourceConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:537 */
class _tmd__GetVideoOutputConfigurationOptions;	/* ../../wsdl/onvif.h:540 */
class _tmd__GetVideoOutputConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:543 */
class _tmd__GetAudioSourceConfigurationOptions;	/* ../../wsdl/onvif.h:546 */
class _tmd__GetAudioSourceConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:549 */
class _tmd__GetAudioOutputConfigurationOptions;	/* ../../wsdl/onvif.h:552 */
class _tmd__GetAudioOutputConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:555 */
class _tmd__SetRelayOutputSettings;	/* ../../wsdl/onvif.h:558 */
class _tmd__SetRelayOutputSettingsResponse;	/* ../../wsdl/onvif.h:561 */
class _tmd__GetDigitalInputs;	/* ../../wsdl/onvif.h:564 */
class _tmd__GetDigitalInputsResponse;	/* ../../wsdl/onvif.h:567 */
class _tmd__GetSerialPorts;	/* ../../wsdl/onvif.h:570 */
class _tmd__GetSerialPortsResponse;	/* ../../wsdl/onvif.h:573 */
class _tmd__GetSerialPortConfiguration;	/* ../../wsdl/onvif.h:576 */
class _tmd__GetSerialPortConfigurationResponse;	/* ../../wsdl/onvif.h:579 */
class _tmd__SetSerialPortConfiguration;	/* ../../wsdl/onvif.h:582 */
class _tmd__SetSerialPortConfigurationResponse;	/* ../../wsdl/onvif.h:585 */
class _tmd__GetSerialPortConfigurationOptions;	/* ../../wsdl/onvif.h:588 */
class _tmd__GetSerialPortConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:591 */
class _tmd__SendReceiveSerialCommand;	/* ../../wsdl/onvif.h:594 */
class _tmd__SendReceiveSerialCommandResponse;	/* ../../wsdl/onvif.h:597 */
class trt__Capabilities;	/* ../../wsdl/onvif.h:600 */
class trt__ProfileCapabilities;	/* ../../wsdl/onvif.h:603 */
class trt__StreamingCapabilities;	/* ../../wsdl/onvif.h:606 */
class _trt__GetServiceCapabilities;	/* ../../wsdl/onvif.h:609 */
class _trt__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:612 */
class _trt__GetVideoSources;	/* ../../wsdl/onvif.h:615 */
class _trt__GetVideoSourcesResponse;	/* ../../wsdl/onvif.h:618 */
class _trt__GetAudioSources;	/* ../../wsdl/onvif.h:621 */
class _trt__GetAudioSourcesResponse;	/* ../../wsdl/onvif.h:624 */
class _trt__GetAudioOutputs;	/* ../../wsdl/onvif.h:627 */
class _trt__GetAudioOutputsResponse;	/* ../../wsdl/onvif.h:630 */
class _trt__CreateProfile;	/* ../../wsdl/onvif.h:633 */
class _trt__CreateProfileResponse;	/* ../../wsdl/onvif.h:636 */
class _trt__GetProfile;	/* ../../wsdl/onvif.h:639 */
class _trt__GetProfileResponse;	/* ../../wsdl/onvif.h:642 */
class _trt__GetProfiles;	/* ../../wsdl/onvif.h:645 */
class _trt__GetProfilesResponse;	/* ../../wsdl/onvif.h:648 */
class _trt__AddVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:651 */
class _trt__AddVideoEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:654 */
class _trt__RemoveVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:657 */
class _trt__RemoveVideoEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:660 */
class _trt__AddVideoSourceConfiguration;	/* ../../wsdl/onvif.h:663 */
class _trt__AddVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:666 */
class _trt__RemoveVideoSourceConfiguration;	/* ../../wsdl/onvif.h:669 */
class _trt__RemoveVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:672 */
class _trt__AddAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:675 */
class _trt__AddAudioEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:678 */
class _trt__RemoveAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:681 */
class _trt__RemoveAudioEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:684 */
class _trt__AddAudioSourceConfiguration;	/* ../../wsdl/onvif.h:687 */
class _trt__AddAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:690 */
class _trt__RemoveAudioSourceConfiguration;	/* ../../wsdl/onvif.h:693 */
class _trt__RemoveAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:696 */
class _trt__AddPTZConfiguration;	/* ../../wsdl/onvif.h:699 */
class _trt__AddPTZConfigurationResponse;	/* ../../wsdl/onvif.h:702 */
class _trt__RemovePTZConfiguration;	/* ../../wsdl/onvif.h:705 */
class _trt__RemovePTZConfigurationResponse;	/* ../../wsdl/onvif.h:708 */
class _trt__AddVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:711 */
class _trt__AddVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:714 */
class _trt__RemoveVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:717 */
class _trt__RemoveVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:720 */
class _trt__AddMetadataConfiguration;	/* ../../wsdl/onvif.h:723 */
class _trt__AddMetadataConfigurationResponse;	/* ../../wsdl/onvif.h:726 */
class _trt__RemoveMetadataConfiguration;	/* ../../wsdl/onvif.h:729 */
class _trt__RemoveMetadataConfigurationResponse;	/* ../../wsdl/onvif.h:732 */
class _trt__AddAudioOutputConfiguration;	/* ../../wsdl/onvif.h:735 */
class _trt__AddAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:738 */
class _trt__RemoveAudioOutputConfiguration;	/* ../../wsdl/onvif.h:741 */
class _trt__RemoveAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:744 */
class _trt__AddAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:747 */
class _trt__AddAudioDecoderConfigurationResponse;	/* ../../wsdl/onvif.h:750 */
class _trt__RemoveAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:753 */
class _trt__RemoveAudioDecoderConfigurationResponse;	/* ../../wsdl/onvif.h:756 */
class _trt__DeleteProfile;	/* ../../wsdl/onvif.h:759 */
class _trt__DeleteProfileResponse;	/* ../../wsdl/onvif.h:762 */
class _trt__GetVideoEncoderConfigurations;	/* ../../wsdl/onvif.h:765 */
class _trt__GetVideoEncoderConfigurationsResponse;	/* ../../wsdl/onvif.h:768 */
class _trt__GetVideoSourceConfigurations;	/* ../../wsdl/onvif.h:771 */
class _trt__GetVideoSourceConfigurationsResponse;	/* ../../wsdl/onvif.h:774 */
class _trt__GetAudioEncoderConfigurations;	/* ../../wsdl/onvif.h:777 */
class _trt__GetAudioEncoderConfigurationsResponse;	/* ../../wsdl/onvif.h:780 */
class _trt__GetAudioSourceConfigurations;	/* ../../wsdl/onvif.h:783 */
class _trt__GetAudioSourceConfigurationsResponse;	/* ../../wsdl/onvif.h:786 */
class _trt__GetVideoAnalyticsConfigurations;	/* ../../wsdl/onvif.h:789 */
class _trt__GetVideoAnalyticsConfigurationsResponse;	/* ../../wsdl/onvif.h:792 */
class _trt__GetMetadataConfigurations;	/* ../../wsdl/onvif.h:795 */
class _trt__GetMetadataConfigurationsResponse;	/* ../../wsdl/onvif.h:798 */
class _trt__GetAudioOutputConfigurations;	/* ../../wsdl/onvif.h:801 */
class _trt__GetAudioOutputConfigurationsResponse;	/* ../../wsdl/onvif.h:804 */
class _trt__GetAudioDecoderConfigurations;	/* ../../wsdl/onvif.h:807 */
class _trt__GetAudioDecoderConfigurationsResponse;	/* ../../wsdl/onvif.h:810 */
class _trt__GetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:813 */
class _trt__GetVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:816 */
class _trt__GetVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:819 */
class _trt__GetVideoEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:822 */
class _trt__GetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:825 */
class _trt__GetAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:828 */
class _trt__GetAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:831 */
class _trt__GetAudioEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:834 */
class _trt__GetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:837 */
class _trt__GetVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:840 */
class _trt__GetMetadataConfiguration;	/* ../../wsdl/onvif.h:843 */
class _trt__GetMetadataConfigurationResponse;	/* ../../wsdl/onvif.h:846 */
class _trt__GetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:849 */
class _trt__GetAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:852 */
class _trt__GetAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:855 */
class _trt__GetAudioDecoderConfigurationResponse;	/* ../../wsdl/onvif.h:858 */
class _trt__GetCompatibleVideoEncoderConfigurations;	/* ../../wsdl/onvif.h:861 */
class _trt__GetCompatibleVideoEncoderConfigurationsResponse;	/* ../../wsdl/onvif.h:864 */
class _trt__GetCompatibleVideoSourceConfigurations;	/* ../../wsdl/onvif.h:867 */
class _trt__GetCompatibleVideoSourceConfigurationsResponse;	/* ../../wsdl/onvif.h:870 */
class _trt__GetCompatibleAudioEncoderConfigurations;	/* ../../wsdl/onvif.h:873 */
class _trt__GetCompatibleAudioEncoderConfigurationsResponse;	/* ../../wsdl/onvif.h:876 */
class _trt__GetCompatibleAudioSourceConfigurations;	/* ../../wsdl/onvif.h:879 */
class _trt__GetCompatibleAudioSourceConfigurationsResponse;	/* ../../wsdl/onvif.h:882 */
class _trt__GetCompatibleVideoAnalyticsConfigurations;	/* ../../wsdl/onvif.h:885 */
class _trt__GetCompatibleVideoAnalyticsConfigurationsResponse;	/* ../../wsdl/onvif.h:888 */
class _trt__GetCompatibleMetadataConfigurations;	/* ../../wsdl/onvif.h:891 */
class _trt__GetCompatibleMetadataConfigurationsResponse;	/* ../../wsdl/onvif.h:894 */
class _trt__GetCompatibleAudioOutputConfigurations;	/* ../../wsdl/onvif.h:897 */
class _trt__GetCompatibleAudioOutputConfigurationsResponse;	/* ../../wsdl/onvif.h:900 */
class _trt__GetCompatibleAudioDecoderConfigurations;	/* ../../wsdl/onvif.h:903 */
class _trt__GetCompatibleAudioDecoderConfigurationsResponse;	/* ../../wsdl/onvif.h:906 */
class _trt__SetVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:909 */
class _trt__SetVideoEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:912 */
class _trt__SetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:915 */
class _trt__SetVideoSourceConfigurationResponse;	/* ../../wsdl/onvif.h:918 */
class _trt__SetAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:921 */
class _trt__SetAudioEncoderConfigurationResponse;	/* ../../wsdl/onvif.h:924 */
class _trt__SetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:927 */
class _trt__SetAudioSourceConfigurationResponse;	/* ../../wsdl/onvif.h:930 */
class _trt__SetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:933 */
class _trt__SetVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:936 */
class _trt__SetMetadataConfiguration;	/* ../../wsdl/onvif.h:939 */
class _trt__SetMetadataConfigurationResponse;	/* ../../wsdl/onvif.h:942 */
class _trt__SetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:945 */
class _trt__SetAudioOutputConfigurationResponse;	/* ../../wsdl/onvif.h:948 */
class _trt__SetAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:951 */
class _trt__SetAudioDecoderConfigurationResponse;	/* ../../wsdl/onvif.h:954 */
class _trt__GetVideoSourceConfigurationOptions;	/* ../../wsdl/onvif.h:957 */
class _trt__GetVideoSourceConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:960 */
class _trt__GetVideoEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:963 */
class _trt__GetVideoEncoderConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:966 */
class _trt__GetAudioSourceConfigurationOptions;	/* ../../wsdl/onvif.h:969 */
class _trt__GetAudioSourceConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:972 */
class _trt__GetAudioEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:975 */
class _trt__GetAudioEncoderConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:978 */
class _trt__GetMetadataConfigurationOptions;	/* ../../wsdl/onvif.h:981 */
class _trt__GetMetadataConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:984 */
class _trt__GetAudioOutputConfigurationOptions;	/* ../../wsdl/onvif.h:987 */
class _trt__GetAudioOutputConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:990 */
class _trt__GetAudioDecoderConfigurationOptions;	/* ../../wsdl/onvif.h:993 */
class _trt__GetAudioDecoderConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:996 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* ../../wsdl/onvif.h:999 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse;	/* ../../wsdl/onvif.h:1002 */
class _trt__GetStreamUri;	/* ../../wsdl/onvif.h:1005 */
class _trt__GetStreamUriResponse;	/* ../../wsdl/onvif.h:1008 */
class _trt__StartMulticastStreaming;	/* ../../wsdl/onvif.h:1011 */
class _trt__StartMulticastStreamingResponse;	/* ../../wsdl/onvif.h:1014 */
class _trt__StopMulticastStreaming;	/* ../../wsdl/onvif.h:1017 */
class _trt__StopMulticastStreamingResponse;	/* ../../wsdl/onvif.h:1020 */
class _trt__SetSynchronizationPoint;	/* ../../wsdl/onvif.h:1023 */
class _trt__SetSynchronizationPointResponse;	/* ../../wsdl/onvif.h:1026 */
class _trt__GetSnapshotUri;	/* ../../wsdl/onvif.h:1029 */
class _trt__GetSnapshotUriResponse;	/* ../../wsdl/onvif.h:1032 */
class tt__DeviceEntity;	/* ../../wsdl/onvif.h:1035 */
class tt__IntRectangle;	/* ../../wsdl/onvif.h:1038 */
class tt__IntRectangleRange;	/* ../../wsdl/onvif.h:1041 */
class tt__IntRange;	/* ../../wsdl/onvif.h:1044 */
class tt__FloatRange;	/* ../../wsdl/onvif.h:1047 */
class tt__DurationRange;	/* ../../wsdl/onvif.h:1050 */
class tt__IntList;	/* ../../wsdl/onvif.h:1053 */
class tt__FloatList;	/* ../../wsdl/onvif.h:1056 */
class tt__AnyHolder;	/* ../../wsdl/onvif.h:1059 */
class tt__VideoSourceExtension;	/* ../../wsdl/onvif.h:1065 */
class tt__VideoSourceExtension2;	/* ../../wsdl/onvif.h:1068 */
class tt__Profile;	/* ../../wsdl/onvif.h:1074 */
class tt__ProfileExtension;	/* ../../wsdl/onvif.h:1077 */
class tt__ProfileExtension2;	/* ../../wsdl/onvif.h:1080 */
class tt__ConfigurationEntity;	/* ../../wsdl/onvif.h:1083 */
class tt__VideoSourceConfigurationExtension;	/* ../../wsdl/onvif.h:1089 */
class tt__VideoSourceConfigurationExtension2;	/* ../../wsdl/onvif.h:1092 */
class tt__Rotate;	/* ../../wsdl/onvif.h:1095 */
class tt__RotateExtension;	/* ../../wsdl/onvif.h:1098 */
class tt__VideoSourceConfigurationOptions;	/* ../../wsdl/onvif.h:1101 */
class tt__VideoSourceConfigurationOptionsExtension;	/* ../../wsdl/onvif.h:1104 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* ../../wsdl/onvif.h:1107 */
class tt__RotateOptions;	/* ../../wsdl/onvif.h:1110 */
class tt__RotateOptionsExtension;	/* ../../wsdl/onvif.h:1113 */
class tt__VideoResolution;	/* ../../wsdl/onvif.h:1119 */
class tt__VideoRateControl;	/* ../../wsdl/onvif.h:1122 */
class tt__Mpeg4Configuration;	/* ../../wsdl/onvif.h:1125 */
class tt__H264Configuration;	/* ../../wsdl/onvif.h:1128 */
class tt__VideoEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:1131 */
class tt__VideoEncoderOptionsExtension;	/* ../../wsdl/onvif.h:1134 */
class tt__VideoEncoderOptionsExtension2;	/* ../../wsdl/onvif.h:1137 */
class tt__JpegOptions;	/* ../../wsdl/onvif.h:1140 */
class tt__Mpeg4Options;	/* ../../wsdl/onvif.h:1146 */
class tt__H264Options;	/* ../../wsdl/onvif.h:1152 */
class tt__AudioSourceConfigurationOptions;	/* ../../wsdl/onvif.h:1161 */
class tt__AudioSourceOptionsExtension;	/* ../../wsdl/onvif.h:1164 */
class tt__AudioEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:1170 */
class tt__AudioEncoderConfigurationOption;	/* ../../wsdl/onvif.h:1173 */
class tt__MetadataConfigurationExtension;	/* ../../wsdl/onvif.h:1182 */
class tt__PTZFilter;	/* ../../wsdl/onvif.h:1185 */
class _tt__EventSubscription_SubscriptionPolicy;	/* ../../wsdl/onvif.h:12939 */
class tt__EventSubscription;	/* ../../wsdl/onvif.h:1188 */
class tt__MetadataConfigurationOptions;	/* ../../wsdl/onvif.h:1191 */
class tt__PTZStatusFilterOptions;	/* ../../wsdl/onvif.h:1194 */
class tt__PTZStatusFilterOptionsExtension;	/* ../../wsdl/onvif.h:1197 */
class tt__VideoOutputExtension;	/* ../../wsdl/onvif.h:1203 */
class tt__VideoOutputConfigurationOptions;	/* ../../wsdl/onvif.h:1209 */
class tt__VideoDecoderConfigurationOptions;	/* ../../wsdl/onvif.h:1212 */
class tt__H264DecOptions;	/* ../../wsdl/onvif.h:1215 */
class tt__JpegDecOptions;	/* ../../wsdl/onvif.h:1218 */
class tt__Mpeg4DecOptions;	/* ../../wsdl/onvif.h:1221 */
class tt__VideoDecoderConfigurationOptionsExtension;	/* ../../wsdl/onvif.h:1224 */
class tt__AudioOutputConfigurationOptions;	/* ../../wsdl/onvif.h:1233 */
class tt__AudioDecoderConfigurationOptions;	/* ../../wsdl/onvif.h:1239 */
class tt__G711DecOptions;	/* ../../wsdl/onvif.h:1242 */
class tt__AACDecOptions;	/* ../../wsdl/onvif.h:1245 */
class tt__G726DecOptions;	/* ../../wsdl/onvif.h:1248 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* ../../wsdl/onvif.h:1251 */
class tt__MulticastConfiguration;	/* ../../wsdl/onvif.h:1254 */
class tt__StreamSetup;	/* ../../wsdl/onvif.h:1257 */
class tt__Transport;	/* ../../wsdl/onvif.h:1260 */
class tt__MediaUri;	/* ../../wsdl/onvif.h:1263 */
class tt__Scope;	/* ../../wsdl/onvif.h:1266 */
class tt__NetworkInterfaceExtension;	/* ../../wsdl/onvif.h:1272 */
class tt__Dot3Configuration;	/* ../../wsdl/onvif.h:1275 */
class tt__NetworkInterfaceExtension2;	/* ../../wsdl/onvif.h:1278 */
class tt__NetworkInterfaceLink;	/* ../../wsdl/onvif.h:1281 */
class tt__NetworkInterfaceConnectionSetting;	/* ../../wsdl/onvif.h:1284 */
class tt__NetworkInterfaceInfo;	/* ../../wsdl/onvif.h:1287 */
class tt__IPv6NetworkInterface;	/* ../../wsdl/onvif.h:1290 */
class tt__IPv4NetworkInterface;	/* ../../wsdl/onvif.h:1293 */
class tt__IPv4Configuration;	/* ../../wsdl/onvif.h:1296 */
class tt__IPv6Configuration;	/* ../../wsdl/onvif.h:1299 */
class tt__IPv6ConfigurationExtension;	/* ../../wsdl/onvif.h:1302 */
class tt__NetworkProtocol;	/* ../../wsdl/onvif.h:1305 */
class tt__NetworkProtocolExtension;	/* ../../wsdl/onvif.h:1308 */
class tt__NetworkHost;	/* ../../wsdl/onvif.h:1311 */
class tt__NetworkHostExtension;	/* ../../wsdl/onvif.h:1314 */
class tt__IPAddress;	/* ../../wsdl/onvif.h:1317 */
class tt__PrefixedIPv4Address;	/* ../../wsdl/onvif.h:1320 */
class tt__PrefixedIPv6Address;	/* ../../wsdl/onvif.h:1323 */
class tt__HostnameInformation;	/* ../../wsdl/onvif.h:1326 */
class tt__HostnameInformationExtension;	/* ../../wsdl/onvif.h:1329 */
class tt__DNSInformation;	/* ../../wsdl/onvif.h:1332 */
class tt__DNSInformationExtension;	/* ../../wsdl/onvif.h:1335 */
class tt__NTPInformation;	/* ../../wsdl/onvif.h:1338 */
class tt__NTPInformationExtension;	/* ../../wsdl/onvif.h:1341 */
class tt__DynamicDNSInformation;	/* ../../wsdl/onvif.h:1344 */
class tt__DynamicDNSInformationExtension;	/* ../../wsdl/onvif.h:1347 */
class tt__NetworkInterfaceSetConfiguration;	/* ../../wsdl/onvif.h:1350 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* ../../wsdl/onvif.h:1353 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* ../../wsdl/onvif.h:1356 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* ../../wsdl/onvif.h:1359 */
class tt__NetworkGateway;	/* ../../wsdl/onvif.h:1362 */
class tt__NetworkZeroConfiguration;	/* ../../wsdl/onvif.h:1365 */
class tt__NetworkZeroConfigurationExtension;	/* ../../wsdl/onvif.h:1368 */
class tt__NetworkZeroConfigurationExtension2;	/* ../../wsdl/onvif.h:1371 */
class tt__IPAddressFilter;	/* ../../wsdl/onvif.h:1374 */
class tt__IPAddressFilterExtension;	/* ../../wsdl/onvif.h:1377 */
class tt__Dot11Configuration;	/* ../../wsdl/onvif.h:1380 */
class tt__Dot11SecurityConfiguration;	/* ../../wsdl/onvif.h:1383 */
class tt__Dot11SecurityConfigurationExtension;	/* ../../wsdl/onvif.h:1386 */
class tt__Dot11PSKSet;	/* ../../wsdl/onvif.h:1389 */
class tt__Dot11PSKSetExtension;	/* ../../wsdl/onvif.h:1392 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* ../../wsdl/onvif.h:1395 */
class tt__Dot11Capabilities;	/* ../../wsdl/onvif.h:1398 */
class tt__Dot11Status;	/* ../../wsdl/onvif.h:1401 */
class tt__Dot11AvailableNetworks;	/* ../../wsdl/onvif.h:1404 */
class tt__Dot11AvailableNetworksExtension;	/* ../../wsdl/onvif.h:1407 */
class tt__Capabilities;	/* ../../wsdl/onvif.h:1410 */
class tt__CapabilitiesExtension;	/* ../../wsdl/onvif.h:1413 */
class tt__CapabilitiesExtension2;	/* ../../wsdl/onvif.h:1416 */
class tt__AnalyticsCapabilities;	/* ../../wsdl/onvif.h:1419 */
class tt__DeviceCapabilities;	/* ../../wsdl/onvif.h:1422 */
class tt__DeviceCapabilitiesExtension;	/* ../../wsdl/onvif.h:1425 */
class tt__EventCapabilities;	/* ../../wsdl/onvif.h:1428 */
class tt__IOCapabilities;	/* ../../wsdl/onvif.h:1431 */
class tt__IOCapabilitiesExtension;	/* ../../wsdl/onvif.h:1434 */
class tt__IOCapabilitiesExtension2;	/* ../../wsdl/onvif.h:1437 */
class tt__MediaCapabilities;	/* ../../wsdl/onvif.h:1440 */
class tt__MediaCapabilitiesExtension;	/* ../../wsdl/onvif.h:1443 */
class tt__RealTimeStreamingCapabilities;	/* ../../wsdl/onvif.h:1446 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* ../../wsdl/onvif.h:1449 */
class tt__ProfileCapabilities;	/* ../../wsdl/onvif.h:1452 */
class tt__NetworkCapabilities;	/* ../../wsdl/onvif.h:1455 */
class tt__NetworkCapabilitiesExtension;	/* ../../wsdl/onvif.h:1458 */
class tt__NetworkCapabilitiesExtension2;	/* ../../wsdl/onvif.h:1461 */
class tt__SecurityCapabilities;	/* ../../wsdl/onvif.h:1464 */
class tt__SecurityCapabilitiesExtension;	/* ../../wsdl/onvif.h:1467 */
class tt__SecurityCapabilitiesExtension2;	/* ../../wsdl/onvif.h:1470 */
class tt__SystemCapabilities;	/* ../../wsdl/onvif.h:1473 */
class tt__SystemCapabilitiesExtension;	/* ../../wsdl/onvif.h:1476 */
class tt__SystemCapabilitiesExtension2;	/* ../../wsdl/onvif.h:1479 */
class tt__OnvifVersion;	/* ../../wsdl/onvif.h:1482 */
class tt__ImagingCapabilities;	/* ../../wsdl/onvif.h:1485 */
class tt__PTZCapabilities;	/* ../../wsdl/onvif.h:1488 */
class tt__DeviceIOCapabilities;	/* ../../wsdl/onvif.h:1491 */
class tt__DisplayCapabilities;	/* ../../wsdl/onvif.h:1494 */
class tt__RecordingCapabilities;	/* ../../wsdl/onvif.h:1497 */
class tt__SearchCapabilities;	/* ../../wsdl/onvif.h:1500 */
class tt__ReplayCapabilities;	/* ../../wsdl/onvif.h:1503 */
class tt__ReceiverCapabilities;	/* ../../wsdl/onvif.h:1506 */
class tt__AnalyticsDeviceCapabilities;	/* ../../wsdl/onvif.h:1509 */
class tt__AnalyticsDeviceExtension;	/* ../../wsdl/onvif.h:1512 */
class tt__SystemLog;	/* ../../wsdl/onvif.h:1515 */
class tt__SupportInformation;	/* ../../wsdl/onvif.h:1518 */
class tt__BinaryData;	/* ../../wsdl/onvif.h:1521 */
class tt__AttachmentData;	/* ../../wsdl/onvif.h:1524 */
class tt__BackupFile;	/* ../../wsdl/onvif.h:1527 */
class tt__SystemLogUriList;	/* ../../wsdl/onvif.h:1530 */
class tt__SystemLogUri;	/* ../../wsdl/onvif.h:1533 */
class tt__SystemDateTime;	/* ../../wsdl/onvif.h:1536 */
class tt__SystemDateTimeExtension;	/* ../../wsdl/onvif.h:1539 */
class tt__DateTime;	/* ../../wsdl/onvif.h:1542 */
class tt__Date;	/* ../../wsdl/onvif.h:1545 */
class tt__Time;	/* ../../wsdl/onvif.h:1548 */
class tt__TimeZone;	/* ../../wsdl/onvif.h:1551 */
class tt__RemoteUser;	/* ../../wsdl/onvif.h:1554 */
class tt__User;	/* ../../wsdl/onvif.h:1557 */
class tt__UserExtension;	/* ../../wsdl/onvif.h:1560 */
class tt__CertificateGenerationParameters;	/* ../../wsdl/onvif.h:1563 */
class tt__CertificateGenerationParametersExtension;	/* ../../wsdl/onvif.h:1566 */
class tt__Certificate;	/* ../../wsdl/onvif.h:1569 */
class tt__CertificateStatus;	/* ../../wsdl/onvif.h:1572 */
class tt__CertificateWithPrivateKey;	/* ../../wsdl/onvif.h:1575 */
class tt__CertificateInformation;	/* ../../wsdl/onvif.h:1578 */
class tt__CertificateInformationExtension;	/* ../../wsdl/onvif.h:1584 */
class tt__Dot1XConfiguration;	/* ../../wsdl/onvif.h:1587 */
class tt__Dot1XConfigurationExtension;	/* ../../wsdl/onvif.h:1590 */
class tt__EAPMethodConfiguration;	/* ../../wsdl/onvif.h:1593 */
class tt__EapMethodExtension;	/* ../../wsdl/onvif.h:1596 */
class tt__TLSConfiguration;	/* ../../wsdl/onvif.h:1599 */
class tt__GenericEapPwdConfigurationExtension;	/* ../../wsdl/onvif.h:1602 */
class tt__RelayOutputSettings;	/* ../../wsdl/onvif.h:1605 */
class tt__PTZNodeExtension;	/* ../../wsdl/onvif.h:1617 */
class tt__PTZNodeExtension2;	/* ../../wsdl/onvif.h:1620 */
class tt__PTZPresetTourSupported;	/* ../../wsdl/onvif.h:1623 */
class tt__PTZPresetTourSupportedExtension;	/* ../../wsdl/onvif.h:1626 */
class tt__PTZConfigurationExtension;	/* ../../wsdl/onvif.h:1632 */
class tt__PTZConfigurationExtension2;	/* ../../wsdl/onvif.h:1635 */
class tt__PTControlDirection;	/* ../../wsdl/onvif.h:1638 */
class tt__PTControlDirectionExtension;	/* ../../wsdl/onvif.h:1641 */
class tt__EFlip;	/* ../../wsdl/onvif.h:1644 */
class tt__Reverse;	/* ../../wsdl/onvif.h:1647 */
class tt__PTZConfigurationOptions;	/* ../../wsdl/onvif.h:1650 */
class tt__PTZConfigurationOptions2;	/* ../../wsdl/onvif.h:1653 */
class tt__PTControlDirectionOptions;	/* ../../wsdl/onvif.h:1656 */
class tt__PTControlDirectionOptionsExtension;	/* ../../wsdl/onvif.h:1659 */
class tt__EFlipOptions;	/* ../../wsdl/onvif.h:1662 */
class tt__EFlipOptionsExtension;	/* ../../wsdl/onvif.h:1665 */
class tt__ReverseOptions;	/* ../../wsdl/onvif.h:1668 */
class tt__ReverseOptionsExtension;	/* ../../wsdl/onvif.h:1671 */
class tt__PanTiltLimits;	/* ../../wsdl/onvif.h:1674 */
class tt__ZoomLimits;	/* ../../wsdl/onvif.h:1677 */
class tt__PTZSpaces;	/* ../../wsdl/onvif.h:1680 */
class tt__PTZSpacesExtension;	/* ../../wsdl/onvif.h:1683 */
class tt__Space2DDescription;	/* ../../wsdl/onvif.h:1686 */
class tt__Space1DDescription;	/* ../../wsdl/onvif.h:1689 */
class tt__Vector2D;	/* ../../wsdl/onvif.h:1692 */
class tt__Vector1D;	/* ../../wsdl/onvif.h:1695 */
class tt__PTZVector;	/* ../../wsdl/onvif.h:1698 */
class tt__PTZSpeed;	/* ../../wsdl/onvif.h:1701 */
class tt__PTZStatus;	/* ../../wsdl/onvif.h:1704 */
class tt__PTZPreset;	/* ../../wsdl/onvif.h:1707 */
class tt__PTZMoveStatus;	/* ../../wsdl/onvif.h:1710 */
class tt__PresetTour;	/* ../../wsdl/onvif.h:1713 */
class tt__PTZPresetTourExtension;	/* ../../wsdl/onvif.h:1716 */
class tt__PTZPresetTourSpot;	/* ../../wsdl/onvif.h:1719 */
class tt__PTZPresetTourSpotExtension;	/* ../../wsdl/onvif.h:1722 */
union _tt__union_PTZPresetTourPresetDetail;	/* ../../wsdl/onvif.h:18701 */
class tt__PTZPresetTourPresetDetail;	/* ../../wsdl/onvif.h:1725 */
class tt__PTZPresetTourTypeExtension;	/* ../../wsdl/onvif.h:1728 */
class tt__PTZPresetTourStatus;	/* ../../wsdl/onvif.h:1731 */
class tt__PTZPresetTourStatusExtension;	/* ../../wsdl/onvif.h:1734 */
class tt__PTZPresetTourStartingCondition;	/* ../../wsdl/onvif.h:1737 */
class tt__PTZPresetTourStartingConditionExtension;	/* ../../wsdl/onvif.h:1740 */
class tt__PTZPresetTourOptions;	/* ../../wsdl/onvif.h:1743 */
class tt__PTZPresetTourSpotOptions;	/* ../../wsdl/onvif.h:1746 */
class tt__PTZPresetTourPresetDetailOptions;	/* ../../wsdl/onvif.h:1749 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* ../../wsdl/onvif.h:1752 */
class tt__PTZPresetTourStartingConditionOptions;	/* ../../wsdl/onvif.h:1755 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* ../../wsdl/onvif.h:1758 */
class tt__ImagingStatus;	/* ../../wsdl/onvif.h:1761 */
class tt__FocusStatus;	/* ../../wsdl/onvif.h:1764 */
class tt__FocusConfiguration;	/* ../../wsdl/onvif.h:1767 */
class tt__ImagingSettings;	/* ../../wsdl/onvif.h:1770 */
class tt__ImagingSettingsExtension;	/* ../../wsdl/onvif.h:1773 */
class tt__Exposure;	/* ../../wsdl/onvif.h:1776 */
class tt__WideDynamicRange;	/* ../../wsdl/onvif.h:1779 */
class tt__BacklightCompensation;	/* ../../wsdl/onvif.h:1782 */
class tt__ImagingOptions;	/* ../../wsdl/onvif.h:1785 */
class tt__WideDynamicRangeOptions;	/* ../../wsdl/onvif.h:1788 */
class tt__BacklightCompensationOptions;	/* ../../wsdl/onvif.h:1791 */
class tt__FocusOptions;	/* ../../wsdl/onvif.h:1794 */
class tt__ExposureOptions;	/* ../../wsdl/onvif.h:1797 */
class tt__WhiteBalanceOptions;	/* ../../wsdl/onvif.h:1800 */
class tt__FocusMove;	/* ../../wsdl/onvif.h:1803 */
class tt__AbsoluteFocus;	/* ../../wsdl/onvif.h:1806 */
class tt__RelativeFocus;	/* ../../wsdl/onvif.h:1809 */
class tt__ContinuousFocus;	/* ../../wsdl/onvif.h:1812 */
class tt__MoveOptions;	/* ../../wsdl/onvif.h:1815 */
class tt__AbsoluteFocusOptions;	/* ../../wsdl/onvif.h:1818 */
class tt__RelativeFocusOptions;	/* ../../wsdl/onvif.h:1821 */
class tt__ContinuousFocusOptions;	/* ../../wsdl/onvif.h:1824 */
class tt__WhiteBalance;	/* ../../wsdl/onvif.h:1827 */
class tt__ImagingStatus20;	/* ../../wsdl/onvif.h:1830 */
class tt__ImagingStatus20Extension;	/* ../../wsdl/onvif.h:1833 */
class tt__FocusStatus20;	/* ../../wsdl/onvif.h:1836 */
class tt__FocusStatus20Extension;	/* ../../wsdl/onvif.h:1839 */
class tt__ImagingSettings20;	/* ../../wsdl/onvif.h:1842 */
class tt__ImagingSettingsExtension20;	/* ../../wsdl/onvif.h:1845 */
class tt__ImagingSettingsExtension202;	/* ../../wsdl/onvif.h:1848 */
class tt__ImageStabilization;	/* ../../wsdl/onvif.h:1851 */
class tt__ImageStabilizationExtension;	/* ../../wsdl/onvif.h:1854 */
class tt__WideDynamicRange20;	/* ../../wsdl/onvif.h:1857 */
class tt__BacklightCompensation20;	/* ../../wsdl/onvif.h:1860 */
class tt__Exposure20;	/* ../../wsdl/onvif.h:1863 */
class tt__ImagingOptions20;	/* ../../wsdl/onvif.h:1866 */
class tt__ImagingOptions20Extension;	/* ../../wsdl/onvif.h:1869 */
class tt__ImagingOptions20Extension2;	/* ../../wsdl/onvif.h:1872 */
class tt__ImageStabilizationOptions;	/* ../../wsdl/onvif.h:1875 */
class tt__ImageStabilizationOptionsExtension;	/* ../../wsdl/onvif.h:1878 */
class tt__WideDynamicRangeOptions20;	/* ../../wsdl/onvif.h:1881 */
class tt__BacklightCompensationOptions20;	/* ../../wsdl/onvif.h:1884 */
class tt__ExposureOptions20;	/* ../../wsdl/onvif.h:1887 */
class tt__MoveOptions20;	/* ../../wsdl/onvif.h:1890 */
class tt__RelativeFocusOptions20;	/* ../../wsdl/onvif.h:1893 */
class tt__WhiteBalance20;	/* ../../wsdl/onvif.h:1896 */
class tt__WhiteBalance20Extension;	/* ../../wsdl/onvif.h:1899 */
class tt__FocusConfiguration20;	/* ../../wsdl/onvif.h:1902 */
class tt__FocusConfiguration20Extension;	/* ../../wsdl/onvif.h:1905 */
class tt__WhiteBalanceOptions20;	/* ../../wsdl/onvif.h:1908 */
class tt__WhiteBalanceOptions20Extension;	/* ../../wsdl/onvif.h:1911 */
class tt__FocusOptions20;	/* ../../wsdl/onvif.h:1914 */
class tt__FocusOptions20Extension;	/* ../../wsdl/onvif.h:1917 */
class tt__MessageExtension;	/* ../../wsdl/onvif.h:1920 */
class _tt__ItemList_SimpleItem;	/* ../../wsdl/onvif.h:21009 */
class _tt__ItemList_ElementItem;	/* ../../wsdl/onvif.h:21037 */
class tt__ItemList;	/* ../../wsdl/onvif.h:1923 */
class tt__ItemListExtension;	/* ../../wsdl/onvif.h:1926 */
class tt__MessageDescription;	/* ../../wsdl/onvif.h:1929 */
class tt__MessageDescriptionExtension;	/* ../../wsdl/onvif.h:1932 */
class _tt__ItemListDescription_SimpleItemDescription;	/* ../../wsdl/onvif.h:21191 */
class _tt__ItemListDescription_ElementItemDescription;	/* ../../wsdl/onvif.h:21216 */
class tt__ItemListDescription;	/* ../../wsdl/onvif.h:1935 */
class tt__ItemListDescriptionExtension;	/* ../../wsdl/onvif.h:1938 */
class tt__Vector;	/* ../../wsdl/onvif.h:1941 */
class tt__Rectangle;	/* ../../wsdl/onvif.h:1944 */
class tt__Polygon;	/* ../../wsdl/onvif.h:1947 */
class tt__Polyline;	/* ../../wsdl/onvif.h:1950 */
class tt__Color;	/* ../../wsdl/onvif.h:1953 */
class tt__ColorCovariance;	/* ../../wsdl/onvif.h:1956 */
class tt__Appearance;	/* ../../wsdl/onvif.h:1959 */
class tt__AppearanceExtension;	/* ../../wsdl/onvif.h:1962 */
class tt__ShapeDescriptor;	/* ../../wsdl/onvif.h:1965 */
class tt__ShapeDescriptorExtension;	/* ../../wsdl/onvif.h:1968 */
class _tt__ColorDescriptor_ColorCluster;	/* ../../wsdl/onvif.h:21542 */
class tt__ColorDescriptor;	/* ../../wsdl/onvif.h:1971 */
class tt__ColorDescriptorExtension;	/* ../../wsdl/onvif.h:1974 */
class _tt__ClassDescriptor_ClassCandidate;	/* ../../wsdl/onvif.h:21612 */
class tt__ClassDescriptor;	/* ../../wsdl/onvif.h:1977 */
class tt__ClassDescriptorExtension;	/* ../../wsdl/onvif.h:1980 */
class tt__ClassDescriptorExtension2;	/* ../../wsdl/onvif.h:1983 */
class tt__OtherType;	/* ../../wsdl/onvif.h:1986 */
class tt__ObjectExtension;	/* ../../wsdl/onvif.h:1992 */
class tt__Transformation;	/* ../../wsdl/onvif.h:1995 */
class tt__TransformationExtension;	/* ../../wsdl/onvif.h:1998 */
class tt__Frame;	/* ../../wsdl/onvif.h:2001 */
class tt__FrameExtension;	/* ../../wsdl/onvif.h:2004 */
class tt__FrameExtension2;	/* ../../wsdl/onvif.h:2007 */
class tt__Merge;	/* ../../wsdl/onvif.h:2010 */
class tt__Split;	/* ../../wsdl/onvif.h:2013 */
class tt__Rename;	/* ../../wsdl/onvif.h:2016 */
class tt__ObjectId;	/* ../../wsdl/onvif.h:2019 */
class _tt__Behaviour_Removed;	/* ../../wsdl/onvif.h:22000 */
class _tt__Behaviour_Idle;	/* ../../wsdl/onvif.h:22022 */
class tt__Behaviour;	/* ../../wsdl/onvif.h:2022 */
class tt__BehaviourExtension;	/* ../../wsdl/onvif.h:2025 */
class tt__ObjectTree;	/* ../../wsdl/onvif.h:2028 */
class tt__ObjectTreeExtension;	/* ../../wsdl/onvif.h:2031 */
class tt__MotionInCells;	/* ../../wsdl/onvif.h:2034 */
class tt__AnalyticsEngineConfiguration;	/* ../../wsdl/onvif.h:2037 */
class tt__AnalyticsEngineConfigurationExtension;	/* ../../wsdl/onvif.h:2040 */
class tt__RuleEngineConfiguration;	/* ../../wsdl/onvif.h:2043 */
class tt__RuleEngineConfigurationExtension;	/* ../../wsdl/onvif.h:2046 */
class tt__Config;	/* ../../wsdl/onvif.h:2049 */
class _tt__ConfigDescription_Messages;	/* ../../wsdl/onvif.h:22356 */
class tt__ConfigDescription;	/* ../../wsdl/onvif.h:2052 */
class tt__ConfigDescriptionExtension;	/* ../../wsdl/onvif.h:2055 */
class tt__SupportedRules;	/* ../../wsdl/onvif.h:2058 */
class tt__SupportedRulesExtension;	/* ../../wsdl/onvif.h:2061 */
class tt__SupportedAnalyticsModules;	/* ../../wsdl/onvif.h:2064 */
class tt__SupportedAnalyticsModulesExtension;	/* ../../wsdl/onvif.h:2067 */
class tt__PolygonConfiguration;	/* ../../wsdl/onvif.h:2070 */
class tt__PolylineArray;	/* ../../wsdl/onvif.h:2073 */
class tt__PolylineArrayExtension;	/* ../../wsdl/onvif.h:2076 */
class tt__PolylineArrayConfiguration;	/* ../../wsdl/onvif.h:2079 */
class tt__MotionExpression;	/* ../../wsdl/onvif.h:2082 */
class tt__MotionExpressionConfiguration;	/* ../../wsdl/onvif.h:2085 */
class tt__CellLayout;	/* ../../wsdl/onvif.h:2088 */
union _tt__union_MetadataStream;	/* ../../wsdl/onvif.h:22842 */
class __tt__union_MetadataStream;	/* ../../wsdl/onvif.h:22829 */
class tt__MetadataStream;	/* ../../wsdl/onvif.h:2091 */
class tt__MetadataStreamExtension;	/* ../../wsdl/onvif.h:2094 */
union _tt__union_VideoAnalyticsStream;	/* ../../wsdl/onvif.h:22904 */
class __tt__union_VideoAnalyticsStream;	/* ../../wsdl/onvif.h:22894 */
class tt__VideoAnalyticsStream;	/* ../../wsdl/onvif.h:2097 */
class tt__VideoAnalyticsStreamExtension;	/* ../../wsdl/onvif.h:2100 */
union _tt__union_PTZStream;	/* ../../wsdl/onvif.h:22960 */
class __tt__union_PTZStream;	/* ../../wsdl/onvif.h:22950 */
class tt__PTZStream;	/* ../../wsdl/onvif.h:2103 */
class tt__PTZStreamExtension;	/* ../../wsdl/onvif.h:2106 */
union _tt__union_EventStream;	/* ../../wsdl/onvif.h:23016 */
class __tt__union_EventStream;	/* ../../wsdl/onvif.h:23006 */
class tt__EventStream;	/* ../../wsdl/onvif.h:2109 */
class tt__EventStreamExtension;	/* ../../wsdl/onvif.h:2112 */
class tt__PaneConfiguration;	/* ../../wsdl/onvif.h:2115 */
class tt__PaneLayout;	/* ../../wsdl/onvif.h:2118 */
class tt__Layout;	/* ../../wsdl/onvif.h:2121 */
class tt__LayoutExtension;	/* ../../wsdl/onvif.h:2124 */
class tt__CodingCapabilities;	/* ../../wsdl/onvif.h:2127 */
class tt__LayoutOptions;	/* ../../wsdl/onvif.h:2130 */
class tt__LayoutOptionsExtension;	/* ../../wsdl/onvif.h:2133 */
class tt__PaneLayoutOptions;	/* ../../wsdl/onvif.h:2136 */
class tt__PaneOptionExtension;	/* ../../wsdl/onvif.h:2139 */
class tt__Receiver;	/* ../../wsdl/onvif.h:2142 */
class tt__ReceiverConfiguration;	/* ../../wsdl/onvif.h:2145 */
class tt__ReceiverStateInformation;	/* ../../wsdl/onvif.h:2148 */
class tt__SourceReference;	/* ../../wsdl/onvif.h:2151 */
class tt__DateTimeRange;	/* ../../wsdl/onvif.h:2154 */
class tt__RecordingSummary;	/* ../../wsdl/onvif.h:2157 */
class tt__SearchScope;	/* ../../wsdl/onvif.h:2160 */
class tt__SearchScopeExtension;	/* ../../wsdl/onvif.h:2163 */
class tt__PTZPositionFilter;	/* ../../wsdl/onvif.h:2169 */
class tt__MetadataFilter;	/* ../../wsdl/onvif.h:2172 */
class tt__FindRecordingResultList;	/* ../../wsdl/onvif.h:2175 */
class tt__FindEventResultList;	/* ../../wsdl/onvif.h:2178 */
class tt__FindEventResult;	/* ../../wsdl/onvif.h:2181 */
class tt__FindPTZPositionResultList;	/* ../../wsdl/onvif.h:2184 */
class tt__FindPTZPositionResult;	/* ../../wsdl/onvif.h:2187 */
class tt__FindMetadataResultList;	/* ../../wsdl/onvif.h:2190 */
class tt__FindMetadataResult;	/* ../../wsdl/onvif.h:2193 */
class tt__RecordingInformation;	/* ../../wsdl/onvif.h:2196 */
class tt__RecordingSourceInformation;	/* ../../wsdl/onvif.h:2199 */
class tt__TrackInformation;	/* ../../wsdl/onvif.h:2202 */
class tt__MediaAttributes;	/* ../../wsdl/onvif.h:2205 */
class tt__TrackAttributes;	/* ../../wsdl/onvif.h:2208 */
class tt__TrackAttributesExtension;	/* ../../wsdl/onvif.h:2211 */
class tt__VideoAttributes;	/* ../../wsdl/onvif.h:2214 */
class tt__AudioAttributes;	/* ../../wsdl/onvif.h:2217 */
class tt__MetadataAttributes;	/* ../../wsdl/onvif.h:2220 */
class tt__RecordingConfiguration;	/* ../../wsdl/onvif.h:2223 */
class tt__TrackConfiguration;	/* ../../wsdl/onvif.h:2226 */
class tt__GetRecordingsResponseItem;	/* ../../wsdl/onvif.h:2229 */
class tt__GetTracksResponseList;	/* ../../wsdl/onvif.h:2232 */
class tt__GetTracksResponseItem;	/* ../../wsdl/onvif.h:2235 */
class tt__RecordingJobConfiguration;	/* ../../wsdl/onvif.h:2238 */
class tt__RecordingJobConfigurationExtension;	/* ../../wsdl/onvif.h:2241 */
class tt__RecordingJobSource;	/* ../../wsdl/onvif.h:2244 */
class tt__RecordingJobSourceExtension;	/* ../../wsdl/onvif.h:2247 */
class tt__RecordingJobTrack;	/* ../../wsdl/onvif.h:2250 */
class tt__RecordingJobStateInformation;	/* ../../wsdl/onvif.h:2253 */
class tt__RecordingJobStateInformationExtension;	/* ../../wsdl/onvif.h:2256 */
class tt__RecordingJobStateSource;	/* ../../wsdl/onvif.h:2259 */
class tt__RecordingJobStateTracks;	/* ../../wsdl/onvif.h:2262 */
class tt__RecordingJobStateTrack;	/* ../../wsdl/onvif.h:2265 */
class tt__GetRecordingJobsResponseItem;	/* ../../wsdl/onvif.h:2268 */
class tt__ReplayConfiguration;	/* ../../wsdl/onvif.h:2271 */
class tt__AnalyticsDeviceEngineConfiguration;	/* ../../wsdl/onvif.h:2277 */
class tt__AnalyticsDeviceEngineConfigurationExtension;	/* ../../wsdl/onvif.h:2280 */
class tt__EngineConfiguration;	/* ../../wsdl/onvif.h:2283 */
class tt__AnalyticsEngineInputInfo;	/* ../../wsdl/onvif.h:2286 */
class tt__AnalyticsEngineInputInfoExtension;	/* ../../wsdl/onvif.h:2289 */
class tt__SourceIdentification;	/* ../../wsdl/onvif.h:2295 */
class tt__SourceIdentificationExtension;	/* ../../wsdl/onvif.h:2298 */
class tt__MetadataInput;	/* ../../wsdl/onvif.h:2301 */
class tt__MetadataInputExtension;	/* ../../wsdl/onvif.h:2304 */
class tt__AnalyticsStateInformation;	/* ../../wsdl/onvif.h:2310 */
class tt__AnalyticsState;	/* ../../wsdl/onvif.h:2313 */
class tt__ActionEngineEventPayload;	/* ../../wsdl/onvif.h:2316 */
class tt__ActionEngineEventPayloadExtension;	/* ../../wsdl/onvif.h:2319 */
class _tt__Message;	/* ../../wsdl/onvif.h:2322 */
class wsnt__QueryExpressionType;	/* ../../wsdl/onvif.h:2325 */
class wsnt__TopicExpressionType;	/* ../../wsdl/onvif.h:2328 */
class wsnt__FilterType;	/* ../../wsdl/onvif.h:2331 */
class wsnt__SubscriptionPolicyType;	/* ../../wsdl/onvif.h:2334 */
class _wsnt__NotificationMessageHolderType_Message;	/* ../../wsdl/onvif.h:25753 */
class wsnt__NotificationMessageHolderType;	/* ../../wsdl/onvif.h:2337 */
class _wsnt__NotificationProducerRP;	/* ../../wsdl/onvif.h:2400 */
class _wsnt__SubscriptionManagerRP;	/* ../../wsdl/onvif.h:2403 */
class _wsnt__Notify;	/* ../../wsdl/onvif.h:2406 */
class _wsnt__UseRaw;	/* ../../wsdl/onvif.h:2409 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* ../../wsdl/onvif.h:25905 */
class _wsnt__Subscribe;	/* ../../wsdl/onvif.h:2412 */
class _wsnt__SubscribeResponse;	/* ../../wsdl/onvif.h:2415 */
class _wsnt__GetCurrentMessage;	/* ../../wsdl/onvif.h:2418 */
class _wsnt__GetCurrentMessageResponse;	/* ../../wsdl/onvif.h:2421 */
class _wsnt__GetMessages;	/* ../../wsdl/onvif.h:2424 */
class _wsnt__GetMessagesResponse;	/* ../../wsdl/onvif.h:2427 */
class _wsnt__DestroyPullPoint;	/* ../../wsdl/onvif.h:2430 */
class _wsnt__DestroyPullPointResponse;	/* ../../wsdl/onvif.h:2433 */
class _wsnt__CreatePullPoint;	/* ../../wsdl/onvif.h:2436 */
class _wsnt__CreatePullPointResponse;	/* ../../wsdl/onvif.h:2439 */
class _wsnt__Renew;	/* ../../wsdl/onvif.h:2442 */
class _wsnt__RenewResponse;	/* ../../wsdl/onvif.h:2445 */
class _wsnt__Unsubscribe;	/* ../../wsdl/onvif.h:2448 */
class _wsnt__UnsubscribeResponse;	/* ../../wsdl/onvif.h:2451 */
class _wsnt__PauseSubscription;	/* ../../wsdl/onvif.h:2454 */
class _wsnt__PauseSubscriptionResponse;	/* ../../wsdl/onvif.h:2457 */
class _wsnt__ResumeSubscription;	/* ../../wsdl/onvif.h:2460 */
class _wsnt__ResumeSubscriptionResponse;	/* ../../wsdl/onvif.h:2463 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* ../../wsdl/onvif.h:26509 */
class _wsrfbf__BaseFaultType_Description;	/* ../../wsdl/onvif.h:26530 */
class _wsrfbf__BaseFaultType_FaultCause;	/* ../../wsdl/onvif.h:26547 */
class wsrfbf__BaseFaultType;	/* ../../wsdl/onvif.h:2466 */
class wstop__Documentation;	/* ../../wsdl/onvif.h:2469 */
class wstop__ExtensibleDocumented;	/* ../../wsdl/onvif.h:2472 */
class wstop__QueryExpressionType;	/* ../../wsdl/onvif.h:2475 */
class _tds__Service_Capabilities;	/* ../../wsdl/onvif.h:26697 */
class tds__Service;	/* ../../wsdl/onvif.h:2487 */
class tds__DeviceServiceCapabilities;	/* ../../wsdl/onvif.h:2490 */
class tds__NetworkCapabilities;	/* ../../wsdl/onvif.h:2493 */
class tds__SecurityCapabilities;	/* ../../wsdl/onvif.h:2496 */
class tds__SystemCapabilities;	/* ../../wsdl/onvif.h:2499 */
class tds__MiscCapabilities;	/* ../../wsdl/onvif.h:2502 */
class _tds__GetServices;	/* ../../wsdl/onvif.h:2505 */
class _tds__GetServicesResponse;	/* ../../wsdl/onvif.h:2508 */
class _tds__GetServiceCapabilities;	/* ../../wsdl/onvif.h:2511 */
class _tds__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:2514 */
class _tds__GetDeviceInformation;	/* ../../wsdl/onvif.h:2517 */
class _tds__GetDeviceInformationResponse;	/* ../../wsdl/onvif.h:2520 */
class _tds__SetSystemDateAndTime;	/* ../../wsdl/onvif.h:2523 */
class _tds__SetSystemDateAndTimeResponse;	/* ../../wsdl/onvif.h:2526 */
class _tds__GetSystemDateAndTime;	/* ../../wsdl/onvif.h:2529 */
class _tds__GetSystemDateAndTimeResponse;	/* ../../wsdl/onvif.h:2532 */
class _tds__SetSystemFactoryDefault;	/* ../../wsdl/onvif.h:2535 */
class _tds__SetSystemFactoryDefaultResponse;	/* ../../wsdl/onvif.h:2538 */
class _tds__UpgradeSystemFirmware;	/* ../../wsdl/onvif.h:2541 */
class _tds__UpgradeSystemFirmwareResponse;	/* ../../wsdl/onvif.h:2544 */
class _tds__SystemReboot;	/* ../../wsdl/onvif.h:2547 */
class _tds__SystemRebootResponse;	/* ../../wsdl/onvif.h:2550 */
class _tds__RestoreSystem;	/* ../../wsdl/onvif.h:2553 */
class _tds__RestoreSystemResponse;	/* ../../wsdl/onvif.h:2556 */
class _tds__GetSystemBackup;	/* ../../wsdl/onvif.h:2559 */
class _tds__GetSystemBackupResponse;	/* ../../wsdl/onvif.h:2562 */
class _tds__GetSystemSupportInformation;	/* ../../wsdl/onvif.h:2565 */
class _tds__GetSystemSupportInformationResponse;	/* ../../wsdl/onvif.h:2568 */
class _tds__GetSystemLog;	/* ../../wsdl/onvif.h:2571 */
class _tds__GetSystemLogResponse;	/* ../../wsdl/onvif.h:2574 */
class _tds__GetScopes;	/* ../../wsdl/onvif.h:2577 */
class _tds__GetScopesResponse;	/* ../../wsdl/onvif.h:2580 */
class _tds__SetScopes;	/* ../../wsdl/onvif.h:2583 */
class _tds__SetScopesResponse;	/* ../../wsdl/onvif.h:2586 */
class _tds__AddScopes;	/* ../../wsdl/onvif.h:2589 */
class _tds__AddScopesResponse;	/* ../../wsdl/onvif.h:2592 */
class _tds__RemoveScopes;	/* ../../wsdl/onvif.h:2595 */
class _tds__RemoveScopesResponse;	/* ../../wsdl/onvif.h:2598 */
class _tds__GetDiscoveryMode;	/* ../../wsdl/onvif.h:2601 */
class _tds__GetDiscoveryModeResponse;	/* ../../wsdl/onvif.h:2604 */
class _tds__SetDiscoveryMode;	/* ../../wsdl/onvif.h:2607 */
class _tds__SetDiscoveryModeResponse;	/* ../../wsdl/onvif.h:2610 */
class _tds__GetRemoteDiscoveryMode;	/* ../../wsdl/onvif.h:2613 */
class _tds__GetRemoteDiscoveryModeResponse;	/* ../../wsdl/onvif.h:2616 */
class _tds__SetRemoteDiscoveryMode;	/* ../../wsdl/onvif.h:2619 */
class _tds__SetRemoteDiscoveryModeResponse;	/* ../../wsdl/onvif.h:2622 */
class _tds__GetDPAddresses;	/* ../../wsdl/onvif.h:2625 */
class _tds__GetDPAddressesResponse;	/* ../../wsdl/onvif.h:2628 */
class _tds__SetDPAddresses;	/* ../../wsdl/onvif.h:2631 */
class _tds__SetDPAddressesResponse;	/* ../../wsdl/onvif.h:2634 */
class _tds__GetEndpointReference;	/* ../../wsdl/onvif.h:2637 */
class _tds__GetEndpointReferenceResponse;	/* ../../wsdl/onvif.h:2640 */
class _tds__GetRemoteUser;	/* ../../wsdl/onvif.h:2643 */
class _tds__GetRemoteUserResponse;	/* ../../wsdl/onvif.h:2646 */
class _tds__SetRemoteUser;	/* ../../wsdl/onvif.h:2649 */
class _tds__SetRemoteUserResponse;	/* ../../wsdl/onvif.h:2652 */
class _tds__GetUsers;	/* ../../wsdl/onvif.h:2655 */
class _tds__GetUsersResponse;	/* ../../wsdl/onvif.h:2658 */
class _tds__CreateUsers;	/* ../../wsdl/onvif.h:2661 */
class _tds__CreateUsersResponse;	/* ../../wsdl/onvif.h:2664 */
class _tds__DeleteUsers;	/* ../../wsdl/onvif.h:2667 */
class _tds__DeleteUsersResponse;	/* ../../wsdl/onvif.h:2670 */
class _tds__SetUser;	/* ../../wsdl/onvif.h:2673 */
class _tds__SetUserResponse;	/* ../../wsdl/onvif.h:2676 */
class _tds__GetWsdlUrl;	/* ../../wsdl/onvif.h:2679 */
class _tds__GetWsdlUrlResponse;	/* ../../wsdl/onvif.h:2682 */
class _tds__GetCapabilities;	/* ../../wsdl/onvif.h:2685 */
class _tds__GetCapabilitiesResponse;	/* ../../wsdl/onvif.h:2688 */
class _tds__GetHostname;	/* ../../wsdl/onvif.h:2691 */
class _tds__GetHostnameResponse;	/* ../../wsdl/onvif.h:2694 */
class _tds__SetHostname;	/* ../../wsdl/onvif.h:2697 */
class _tds__SetHostnameResponse;	/* ../../wsdl/onvif.h:2700 */
class _tds__SetHostnameFromDHCP;	/* ../../wsdl/onvif.h:2703 */
class _tds__SetHostnameFromDHCPResponse;	/* ../../wsdl/onvif.h:2706 */
class _tds__GetDNS;	/* ../../wsdl/onvif.h:2709 */
class _tds__GetDNSResponse;	/* ../../wsdl/onvif.h:2712 */
class _tds__SetDNS;	/* ../../wsdl/onvif.h:2715 */
class _tds__SetDNSResponse;	/* ../../wsdl/onvif.h:2718 */
class _tds__GetNTP;	/* ../../wsdl/onvif.h:2721 */
class _tds__GetNTPResponse;	/* ../../wsdl/onvif.h:2724 */
class _tds__SetNTP;	/* ../../wsdl/onvif.h:2727 */
class _tds__SetNTPResponse;	/* ../../wsdl/onvif.h:2730 */
class _tds__GetDynamicDNS;	/* ../../wsdl/onvif.h:2733 */
class _tds__GetDynamicDNSResponse;	/* ../../wsdl/onvif.h:2736 */
class _tds__SetDynamicDNS;	/* ../../wsdl/onvif.h:2739 */
class _tds__SetDynamicDNSResponse;	/* ../../wsdl/onvif.h:2742 */
class _tds__GetNetworkInterfaces;	/* ../../wsdl/onvif.h:2745 */
class _tds__GetNetworkInterfacesResponse;	/* ../../wsdl/onvif.h:2748 */
class _tds__SetNetworkInterfaces;	/* ../../wsdl/onvif.h:2751 */
class _tds__SetNetworkInterfacesResponse;	/* ../../wsdl/onvif.h:2754 */
class _tds__GetNetworkProtocols;	/* ../../wsdl/onvif.h:2757 */
class _tds__GetNetworkProtocolsResponse;	/* ../../wsdl/onvif.h:2760 */
class _tds__SetNetworkProtocols;	/* ../../wsdl/onvif.h:2763 */
class _tds__SetNetworkProtocolsResponse;	/* ../../wsdl/onvif.h:2766 */
class _tds__GetNetworkDefaultGateway;	/* ../../wsdl/onvif.h:2769 */
class _tds__GetNetworkDefaultGatewayResponse;	/* ../../wsdl/onvif.h:2772 */
class _tds__SetNetworkDefaultGateway;	/* ../../wsdl/onvif.h:2775 */
class _tds__SetNetworkDefaultGatewayResponse;	/* ../../wsdl/onvif.h:2778 */
class _tds__GetZeroConfiguration;	/* ../../wsdl/onvif.h:2781 */
class _tds__GetZeroConfigurationResponse;	/* ../../wsdl/onvif.h:2784 */
class _tds__SetZeroConfiguration;	/* ../../wsdl/onvif.h:2787 */
class _tds__SetZeroConfigurationResponse;	/* ../../wsdl/onvif.h:2790 */
class _tds__GetIPAddressFilter;	/* ../../wsdl/onvif.h:2793 */
class _tds__GetIPAddressFilterResponse;	/* ../../wsdl/onvif.h:2796 */
class _tds__SetIPAddressFilter;	/* ../../wsdl/onvif.h:2799 */
class _tds__SetIPAddressFilterResponse;	/* ../../wsdl/onvif.h:2802 */
class _tds__AddIPAddressFilter;	/* ../../wsdl/onvif.h:2805 */
class _tds__AddIPAddressFilterResponse;	/* ../../wsdl/onvif.h:2808 */
class _tds__RemoveIPAddressFilter;	/* ../../wsdl/onvif.h:2811 */
class _tds__RemoveIPAddressFilterResponse;	/* ../../wsdl/onvif.h:2814 */
class _tds__GetAccessPolicy;	/* ../../wsdl/onvif.h:2817 */
class _tds__GetAccessPolicyResponse;	/* ../../wsdl/onvif.h:2820 */
class _tds__SetAccessPolicy;	/* ../../wsdl/onvif.h:2823 */
class _tds__SetAccessPolicyResponse;	/* ../../wsdl/onvif.h:2826 */
class _tds__CreateCertificate;	/* ../../wsdl/onvif.h:2829 */
class _tds__CreateCertificateResponse;	/* ../../wsdl/onvif.h:2832 */
class _tds__GetCertificates;	/* ../../wsdl/onvif.h:2835 */
class _tds__GetCertificatesResponse;	/* ../../wsdl/onvif.h:2838 */
class _tds__GetCertificatesStatus;	/* ../../wsdl/onvif.h:2841 */
class _tds__GetCertificatesStatusResponse;	/* ../../wsdl/onvif.h:2844 */
class _tds__SetCertificatesStatus;	/* ../../wsdl/onvif.h:2847 */
class _tds__SetCertificatesStatusResponse;	/* ../../wsdl/onvif.h:2850 */
class _tds__DeleteCertificates;	/* ../../wsdl/onvif.h:2853 */
class _tds__DeleteCertificatesResponse;	/* ../../wsdl/onvif.h:2856 */
class _tds__GetPkcs10Request;	/* ../../wsdl/onvif.h:2859 */
class _tds__GetPkcs10RequestResponse;	/* ../../wsdl/onvif.h:2862 */
class _tds__LoadCertificates;	/* ../../wsdl/onvif.h:2865 */
class _tds__LoadCertificatesResponse;	/* ../../wsdl/onvif.h:2868 */
class _tds__GetClientCertificateMode;	/* ../../wsdl/onvif.h:2871 */
class _tds__GetClientCertificateModeResponse;	/* ../../wsdl/onvif.h:2874 */
class _tds__SetClientCertificateMode;	/* ../../wsdl/onvif.h:2877 */
class _tds__SetClientCertificateModeResponse;	/* ../../wsdl/onvif.h:2880 */
class _tds__GetCACertificates;	/* ../../wsdl/onvif.h:2883 */
class _tds__GetCACertificatesResponse;	/* ../../wsdl/onvif.h:2886 */
class _tds__LoadCertificateWithPrivateKey;	/* ../../wsdl/onvif.h:2889 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* ../../wsdl/onvif.h:2892 */
class _tds__GetCertificateInformation;	/* ../../wsdl/onvif.h:2895 */
class _tds__GetCertificateInformationResponse;	/* ../../wsdl/onvif.h:2898 */
class _tds__LoadCACertificates;	/* ../../wsdl/onvif.h:2901 */
class _tds__LoadCACertificatesResponse;	/* ../../wsdl/onvif.h:2904 */
class _tds__CreateDot1XConfiguration;	/* ../../wsdl/onvif.h:2907 */
class _tds__CreateDot1XConfigurationResponse;	/* ../../wsdl/onvif.h:2910 */
class _tds__SetDot1XConfiguration;	/* ../../wsdl/onvif.h:2913 */
class _tds__SetDot1XConfigurationResponse;	/* ../../wsdl/onvif.h:2916 */
class _tds__GetDot1XConfiguration;	/* ../../wsdl/onvif.h:2919 */
class _tds__GetDot1XConfigurationResponse;	/* ../../wsdl/onvif.h:2922 */
class _tds__GetDot1XConfigurations;	/* ../../wsdl/onvif.h:2925 */
class _tds__GetDot1XConfigurationsResponse;	/* ../../wsdl/onvif.h:2928 */
class _tds__DeleteDot1XConfiguration;	/* ../../wsdl/onvif.h:2931 */
class _tds__DeleteDot1XConfigurationResponse;	/* ../../wsdl/onvif.h:2934 */
class _tds__GetRelayOutputs;	/* ../../wsdl/onvif.h:2937 */
class _tds__GetRelayOutputsResponse;	/* ../../wsdl/onvif.h:2940 */
class _tds__SetRelayOutputSettings;	/* ../../wsdl/onvif.h:2943 */
class _tds__SetRelayOutputSettingsResponse;	/* ../../wsdl/onvif.h:2946 */
class _tds__SetRelayOutputState;	/* ../../wsdl/onvif.h:2949 */
class _tds__SetRelayOutputStateResponse;	/* ../../wsdl/onvif.h:2952 */
class _tds__SendAuxiliaryCommand;	/* ../../wsdl/onvif.h:2955 */
class _tds__SendAuxiliaryCommandResponse;	/* ../../wsdl/onvif.h:2958 */
class _tds__GetDot11Capabilities;	/* ../../wsdl/onvif.h:2961 */
class _tds__GetDot11CapabilitiesResponse;	/* ../../wsdl/onvif.h:2964 */
class _tds__GetDot11Status;	/* ../../wsdl/onvif.h:2967 */
class _tds__GetDot11StatusResponse;	/* ../../wsdl/onvif.h:2970 */
class _tds__ScanAvailableDot11Networks;	/* ../../wsdl/onvif.h:2973 */
class _tds__ScanAvailableDot11NetworksResponse;	/* ../../wsdl/onvif.h:2976 */
class _tds__GetSystemUris;	/* ../../wsdl/onvif.h:2979 */
class _tds__GetSystemUrisResponse_Extension;	/* ../../wsdl/onvif.h:30633 */
class _tds__GetSystemUrisResponse;	/* ../../wsdl/onvif.h:2982 */
class _tds__StartFirmwareUpgrade;	/* ../../wsdl/onvif.h:2985 */
class _tds__StartFirmwareUpgradeResponse;	/* ../../wsdl/onvif.h:2988 */
class _tds__StartSystemRestore;	/* ../../wsdl/onvif.h:2991 */
class _tds__StartSystemRestoreResponse;	/* ../../wsdl/onvif.h:2994 */
class tev__Capabilities;	/* ../../wsdl/onvif.h:2997 */
class _tev__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3000 */
class _tev__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3003 */
class _tev__CreatePullPointSubscription_SubscriptionPolicy;	/* ../../wsdl/onvif.h:30885 */
class _tev__CreatePullPointSubscription;	/* ../../wsdl/onvif.h:3006 */
class _tev__CreatePullPointSubscriptionResponse;	/* ../../wsdl/onvif.h:3009 */
class _tev__PullMessages;	/* ../../wsdl/onvif.h:3012 */
class _tev__PullMessagesResponse;	/* ../../wsdl/onvif.h:3015 */
class _tev__PullMessagesFaultResponse;	/* ../../wsdl/onvif.h:3018 */
class _tev__Seek;	/* ../../wsdl/onvif.h:3021 */
class _tev__SeekResponse;	/* ../../wsdl/onvif.h:3024 */
class _tev__SetSynchronizationPoint;	/* ../../wsdl/onvif.h:3027 */
class _tev__SetSynchronizationPointResponse;	/* ../../wsdl/onvif.h:3030 */
class _tev__GetEventProperties;	/* ../../wsdl/onvif.h:3033 */
class _tev__GetEventPropertiesResponse;	/* ../../wsdl/onvif.h:3036 */
class tls__Capabilities;	/* ../../wsdl/onvif.h:3045 */
class _tls__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3048 */
class _tls__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3051 */
class _tls__GetLayout;	/* ../../wsdl/onvif.h:3054 */
class _tls__GetLayoutResponse;	/* ../../wsdl/onvif.h:3057 */
class _tls__SetLayout;	/* ../../wsdl/onvif.h:3060 */
class _tls__SetLayoutResponse;	/* ../../wsdl/onvif.h:3063 */
class _tls__GetDisplayOptions;	/* ../../wsdl/onvif.h:3066 */
class _tls__GetDisplayOptionsResponse;	/* ../../wsdl/onvif.h:3069 */
class _tls__GetPaneConfigurations;	/* ../../wsdl/onvif.h:3072 */
class _tls__GetPaneConfigurationsResponse;	/* ../../wsdl/onvif.h:3075 */
class _tls__GetPaneConfiguration;	/* ../../wsdl/onvif.h:3078 */
class _tls__GetPaneConfigurationResponse;	/* ../../wsdl/onvif.h:3081 */
class _tls__SetPaneConfigurations;	/* ../../wsdl/onvif.h:3084 */
class _tls__SetPaneConfigurationsResponse;	/* ../../wsdl/onvif.h:3087 */
class _tls__SetPaneConfiguration;	/* ../../wsdl/onvif.h:3090 */
class _tls__SetPaneConfigurationResponse;	/* ../../wsdl/onvif.h:3093 */
class _tls__CreatePaneConfiguration;	/* ../../wsdl/onvif.h:3096 */
class _tls__CreatePaneConfigurationResponse;	/* ../../wsdl/onvif.h:3099 */
class _tls__DeletePaneConfiguration;	/* ../../wsdl/onvif.h:3102 */
class _tls__DeletePaneConfigurationResponse;	/* ../../wsdl/onvif.h:3105 */
class timg__Capabilities;	/* ../../wsdl/onvif.h:3108 */
class _timg__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3111 */
class _timg__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3114 */
class _timg__GetImagingSettings;	/* ../../wsdl/onvif.h:3117 */
class _timg__GetImagingSettingsResponse;	/* ../../wsdl/onvif.h:3120 */
class _timg__SetImagingSettings;	/* ../../wsdl/onvif.h:3123 */
class _timg__SetImagingSettingsResponse;	/* ../../wsdl/onvif.h:3126 */
class _timg__GetOptions;	/* ../../wsdl/onvif.h:3129 */
class _timg__GetOptionsResponse;	/* ../../wsdl/onvif.h:3132 */
class _timg__Move;	/* ../../wsdl/onvif.h:3135 */
class _timg__MoveResponse;	/* ../../wsdl/onvif.h:3138 */
class _timg__GetMoveOptions;	/* ../../wsdl/onvif.h:3141 */
class _timg__GetMoveOptionsResponse;	/* ../../wsdl/onvif.h:3144 */
class _timg__Stop;	/* ../../wsdl/onvif.h:3147 */
class _timg__StopResponse;	/* ../../wsdl/onvif.h:3150 */
class _timg__GetStatus;	/* ../../wsdl/onvif.h:3153 */
class _timg__GetStatusResponse;	/* ../../wsdl/onvif.h:3156 */
class tptz__Capabilities;	/* ../../wsdl/onvif.h:3159 */
class _tptz__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3162 */
class _tptz__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3165 */
class _tptz__GetNodes;	/* ../../wsdl/onvif.h:3168 */
class _tptz__GetNodesResponse;	/* ../../wsdl/onvif.h:3171 */
class _tptz__GetNode;	/* ../../wsdl/onvif.h:3174 */
class _tptz__GetNodeResponse;	/* ../../wsdl/onvif.h:3177 */
class _tptz__GetConfigurations;	/* ../../wsdl/onvif.h:3180 */
class _tptz__GetConfigurationsResponse;	/* ../../wsdl/onvif.h:3183 */
class _tptz__GetConfiguration;	/* ../../wsdl/onvif.h:3186 */
class _tptz__GetConfigurationResponse;	/* ../../wsdl/onvif.h:3189 */
class _tptz__SetConfiguration;	/* ../../wsdl/onvif.h:3192 */
class __tptz__SetConfigurationResponse_sequence;	/* ../../wsdl/onvif.h:32698 */
class _tptz__SetConfigurationResponse;	/* ../../wsdl/onvif.h:3195 */
class _tptz__GetConfigurationOptions;	/* ../../wsdl/onvif.h:3198 */
class _tptz__GetConfigurationOptionsResponse;	/* ../../wsdl/onvif.h:3201 */
class _tptz__SendAuxiliaryCommand;	/* ../../wsdl/onvif.h:3204 */
class _tptz__SendAuxiliaryCommandResponse;	/* ../../wsdl/onvif.h:3207 */
class _tptz__GetPresets;	/* ../../wsdl/onvif.h:3210 */
class _tptz__GetPresetsResponse;	/* ../../wsdl/onvif.h:3213 */
class _tptz__SetPreset;	/* ../../wsdl/onvif.h:3216 */
class _tptz__SetPresetResponse;	/* ../../wsdl/onvif.h:3219 */
class _tptz__RemovePreset;	/* ../../wsdl/onvif.h:3222 */
class _tptz__RemovePresetResponse;	/* ../../wsdl/onvif.h:3225 */
class _tptz__GotoPreset;	/* ../../wsdl/onvif.h:3228 */
class _tptz__GotoPresetResponse;	/* ../../wsdl/onvif.h:3231 */
class _tptz__GetStatus;	/* ../../wsdl/onvif.h:3234 */
class _tptz__GetStatusResponse;	/* ../../wsdl/onvif.h:3237 */
class _tptz__GotoHomePosition;	/* ../../wsdl/onvif.h:3240 */
class _tptz__GotoHomePositionResponse;	/* ../../wsdl/onvif.h:3243 */
class _tptz__SetHomePosition;	/* ../../wsdl/onvif.h:3246 */
class _tptz__SetHomePositionResponse;	/* ../../wsdl/onvif.h:3249 */
class _tptz__ContinuousMove;	/* ../../wsdl/onvif.h:3252 */
class _tptz__ContinuousMoveResponse;	/* ../../wsdl/onvif.h:3255 */
class _tptz__RelativeMove;	/* ../../wsdl/onvif.h:3258 */
class _tptz__RelativeMoveResponse;	/* ../../wsdl/onvif.h:3261 */
class _tptz__AbsoluteMove;	/* ../../wsdl/onvif.h:3264 */
class _tptz__AbsoluteMoveResponse;	/* ../../wsdl/onvif.h:3267 */
class _tptz__Stop;	/* ../../wsdl/onvif.h:3270 */
class _tptz__StopResponse;	/* ../../wsdl/onvif.h:3273 */
class _tptz__GetPresetTours;	/* ../../wsdl/onvif.h:3276 */
class _tptz__GetPresetToursResponse;	/* ../../wsdl/onvif.h:3279 */
class _tptz__GetPresetTour;	/* ../../wsdl/onvif.h:3282 */
class _tptz__GetPresetTourResponse;	/* ../../wsdl/onvif.h:3285 */
class _tptz__GetPresetTourOptions;	/* ../../wsdl/onvif.h:3288 */
class _tptz__GetPresetTourOptionsResponse;	/* ../../wsdl/onvif.h:3291 */
class _tptz__CreatePresetTour;	/* ../../wsdl/onvif.h:3294 */
class _tptz__CreatePresetTourResponse;	/* ../../wsdl/onvif.h:3297 */
class _tptz__ModifyPresetTour;	/* ../../wsdl/onvif.h:3300 */
class _tptz__ModifyPresetTourResponse;	/* ../../wsdl/onvif.h:3303 */
class _tptz__OperatePresetTour;	/* ../../wsdl/onvif.h:3306 */
class _tptz__OperatePresetTourResponse;	/* ../../wsdl/onvif.h:3309 */
class _tptz__RemovePresetTour;	/* ../../wsdl/onvif.h:3312 */
class _tptz__RemovePresetTourResponse;	/* ../../wsdl/onvif.h:3315 */
class trv__Capabilities;	/* ../../wsdl/onvif.h:3318 */
class _trv__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3321 */
class _trv__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3324 */
class _trv__GetReceivers;	/* ../../wsdl/onvif.h:3327 */
class _trv__GetReceiversResponse;	/* ../../wsdl/onvif.h:3330 */
class _trv__GetReceiver;	/* ../../wsdl/onvif.h:3333 */
class _trv__GetReceiverResponse;	/* ../../wsdl/onvif.h:3336 */
class _trv__CreateReceiver;	/* ../../wsdl/onvif.h:3339 */
class _trv__CreateReceiverResponse;	/* ../../wsdl/onvif.h:3342 */
class _trv__DeleteReceiver;	/* ../../wsdl/onvif.h:3345 */
class _trv__DeleteReceiverResponse;	/* ../../wsdl/onvif.h:3348 */
class _trv__ConfigureReceiver;	/* ../../wsdl/onvif.h:3351 */
class _trv__ConfigureReceiverResponse;	/* ../../wsdl/onvif.h:3354 */
class _trv__SetReceiverMode;	/* ../../wsdl/onvif.h:3357 */
class _trv__SetReceiverModeResponse;	/* ../../wsdl/onvif.h:3360 */
class _trv__GetReceiverState;	/* ../../wsdl/onvif.h:3363 */
class _trv__GetReceiverStateResponse;	/* ../../wsdl/onvif.h:3366 */
class trc__Capabilities;	/* ../../wsdl/onvif.h:3369 */
class trc__RecordingOptions;	/* ../../wsdl/onvif.h:3372 */
class trc__JobOptions;	/* ../../wsdl/onvif.h:3375 */
class trc__TrackOptions;	/* ../../wsdl/onvif.h:3378 */
class _trc__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3381 */
class _trc__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3384 */
class _trc__CreateRecording;	/* ../../wsdl/onvif.h:3387 */
class _trc__CreateRecordingResponse;	/* ../../wsdl/onvif.h:3390 */
class _trc__DeleteRecording;	/* ../../wsdl/onvif.h:3393 */
class _trc__DeleteRecordingResponse;	/* ../../wsdl/onvif.h:3396 */
class _trc__GetRecordings;	/* ../../wsdl/onvif.h:3399 */
class _trc__GetRecordingsResponse;	/* ../../wsdl/onvif.h:3402 */
class _trc__SetRecordingConfiguration;	/* ../../wsdl/onvif.h:3405 */
class _trc__SetRecordingConfigurationResponse;	/* ../../wsdl/onvif.h:3408 */
class _trc__GetRecordingConfiguration;	/* ../../wsdl/onvif.h:3411 */
class _trc__GetRecordingConfigurationResponse;	/* ../../wsdl/onvif.h:3414 */
class _trc__CreateTrack;	/* ../../wsdl/onvif.h:3417 */
class _trc__CreateTrackResponse;	/* ../../wsdl/onvif.h:3420 */
class _trc__DeleteTrack;	/* ../../wsdl/onvif.h:3423 */
class _trc__DeleteTrackResponse;	/* ../../wsdl/onvif.h:3426 */
class _trc__GetTrackConfiguration;	/* ../../wsdl/onvif.h:3429 */
class _trc__GetTrackConfigurationResponse;	/* ../../wsdl/onvif.h:3432 */
class _trc__SetTrackConfiguration;	/* ../../wsdl/onvif.h:3435 */
class _trc__SetTrackConfigurationResponse;	/* ../../wsdl/onvif.h:3438 */
class _trc__CreateRecordingJob;	/* ../../wsdl/onvif.h:3441 */
class _trc__CreateRecordingJobResponse;	/* ../../wsdl/onvif.h:3444 */
class _trc__DeleteRecordingJob;	/* ../../wsdl/onvif.h:3447 */
class _trc__DeleteRecordingJobResponse;	/* ../../wsdl/onvif.h:3450 */
class _trc__GetRecordingJobs;	/* ../../wsdl/onvif.h:3453 */
class _trc__GetRecordingJobsResponse;	/* ../../wsdl/onvif.h:3456 */
class _trc__SetRecordingJobConfiguration;	/* ../../wsdl/onvif.h:3459 */
class _trc__SetRecordingJobConfigurationResponse;	/* ../../wsdl/onvif.h:3462 */
class _trc__GetRecordingJobConfiguration;	/* ../../wsdl/onvif.h:3465 */
class _trc__GetRecordingJobConfigurationResponse;	/* ../../wsdl/onvif.h:3468 */
class _trc__SetRecordingJobMode;	/* ../../wsdl/onvif.h:3471 */
class _trc__SetRecordingJobModeResponse;	/* ../../wsdl/onvif.h:3474 */
class _trc__GetRecordingJobState;	/* ../../wsdl/onvif.h:3477 */
class _trc__GetRecordingJobStateResponse;	/* ../../wsdl/onvif.h:3480 */
class _trc__GetRecordingOptions;	/* ../../wsdl/onvif.h:3483 */
class _trc__GetRecordingOptionsResponse;	/* ../../wsdl/onvif.h:3486 */
class tse__Capabilities;	/* ../../wsdl/onvif.h:3489 */
class _tse__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3492 */
class _tse__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3495 */
class _tse__GetRecordingSummary;	/* ../../wsdl/onvif.h:3498 */
class _tse__GetRecordingSummaryResponse;	/* ../../wsdl/onvif.h:3501 */
class _tse__GetRecordingInformation;	/* ../../wsdl/onvif.h:3504 */
class _tse__GetRecordingInformationResponse;	/* ../../wsdl/onvif.h:3507 */
class _tse__GetMediaAttributes;	/* ../../wsdl/onvif.h:3510 */
class _tse__GetMediaAttributesResponse;	/* ../../wsdl/onvif.h:3513 */
class _tse__FindRecordings;	/* ../../wsdl/onvif.h:3516 */
class _tse__FindRecordingsResponse;	/* ../../wsdl/onvif.h:3519 */
class _tse__GetRecordingSearchResults;	/* ../../wsdl/onvif.h:3522 */
class _tse__GetRecordingSearchResultsResponse;	/* ../../wsdl/onvif.h:3525 */
class _tse__FindEvents;	/* ../../wsdl/onvif.h:3528 */
class _tse__FindEventsResponse;	/* ../../wsdl/onvif.h:3531 */
class _tse__GetEventSearchResults;	/* ../../wsdl/onvif.h:3534 */
class _tse__GetEventSearchResultsResponse;	/* ../../wsdl/onvif.h:3537 */
class _tse__FindPTZPosition;	/* ../../wsdl/onvif.h:3540 */
class _tse__FindPTZPositionResponse;	/* ../../wsdl/onvif.h:3543 */
class _tse__GetPTZPositionSearchResults;	/* ../../wsdl/onvif.h:3546 */
class _tse__GetPTZPositionSearchResultsResponse;	/* ../../wsdl/onvif.h:3549 */
class _tse__FindMetadata;	/* ../../wsdl/onvif.h:3552 */
class _tse__FindMetadataResponse;	/* ../../wsdl/onvif.h:3555 */
class _tse__GetMetadataSearchResults;	/* ../../wsdl/onvif.h:3558 */
class _tse__GetMetadataSearchResultsResponse;	/* ../../wsdl/onvif.h:3561 */
class _tse__GetSearchState;	/* ../../wsdl/onvif.h:3564 */
class _tse__GetSearchStateResponse;	/* ../../wsdl/onvif.h:3567 */
class _tse__EndSearch;	/* ../../wsdl/onvif.h:3570 */
class _tse__EndSearchResponse;	/* ../../wsdl/onvif.h:3573 */
class trp__Capabilities;	/* ../../wsdl/onvif.h:3576 */
class _trp__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3579 */
class _trp__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3582 */
class _trp__GetReplayUri;	/* ../../wsdl/onvif.h:3585 */
class _trp__GetReplayUriResponse;	/* ../../wsdl/onvif.h:3588 */
class _trp__SetReplayConfiguration;	/* ../../wsdl/onvif.h:3591 */
class _trp__SetReplayConfigurationResponse;	/* ../../wsdl/onvif.h:3594 */
class _trp__GetReplayConfiguration;	/* ../../wsdl/onvif.h:3597 */
class _trp__GetReplayConfigurationResponse;	/* ../../wsdl/onvif.h:3600 */
class tan__Capabilities;	/* ../../wsdl/onvif.h:3603 */
class _tan__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3606 */
class _tan__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3609 */
class _tan__GetSupportedRules;	/* ../../wsdl/onvif.h:3612 */
class _tan__GetSupportedRulesResponse;	/* ../../wsdl/onvif.h:3615 */
class _tan__CreateRules;	/* ../../wsdl/onvif.h:3618 */
class _tan__CreateRulesResponse;	/* ../../wsdl/onvif.h:3621 */
class _tan__DeleteRules;	/* ../../wsdl/onvif.h:3624 */
class _tan__DeleteRulesResponse;	/* ../../wsdl/onvif.h:3627 */
class _tan__ModifyRules;	/* ../../wsdl/onvif.h:3630 */
class _tan__ModifyRulesResponse;	/* ../../wsdl/onvif.h:3633 */
class _tan__GetRules;	/* ../../wsdl/onvif.h:3636 */
class _tan__GetRulesResponse;	/* ../../wsdl/onvif.h:3639 */
class _tan__GetSupportedAnalyticsModules;	/* ../../wsdl/onvif.h:3642 */
class _tan__GetSupportedAnalyticsModulesResponse;	/* ../../wsdl/onvif.h:3645 */
class _tan__CreateAnalyticsModules;	/* ../../wsdl/onvif.h:3648 */
class _tan__CreateAnalyticsModulesResponse;	/* ../../wsdl/onvif.h:3651 */
class _tan__DeleteAnalyticsModules;	/* ../../wsdl/onvif.h:3654 */
class _tan__DeleteAnalyticsModulesResponse;	/* ../../wsdl/onvif.h:3657 */
class _tan__ModifyAnalyticsModules;	/* ../../wsdl/onvif.h:3660 */
class _tan__ModifyAnalyticsModulesResponse;	/* ../../wsdl/onvif.h:3663 */
class _tan__GetAnalyticsModules;	/* ../../wsdl/onvif.h:3666 */
class _tan__GetAnalyticsModulesResponse;	/* ../../wsdl/onvif.h:3669 */
class tad__Capabilities;	/* ../../wsdl/onvif.h:3672 */
class _tad__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3675 */
class _tad__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3678 */
class _tad__DeleteAnalyticsEngineControl;	/* ../../wsdl/onvif.h:3681 */
class _tad__DeleteAnalyticsEngineControlResponse;	/* ../../wsdl/onvif.h:3684 */
class _tad__CreateAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:3687 */
class _tad__CreateAnalyticsEngineInputsResponse;	/* ../../wsdl/onvif.h:3690 */
class _tad__CreateAnalyticsEngineControl;	/* ../../wsdl/onvif.h:3693 */
class _tad__CreateAnalyticsEngineControlResponse;	/* ../../wsdl/onvif.h:3696 */
class _tad__SetAnalyticsEngineControl;	/* ../../wsdl/onvif.h:3699 */
class _tad__SetAnalyticsEngineControlResponse;	/* ../../wsdl/onvif.h:3702 */
class _tad__GetAnalyticsEngineControl;	/* ../../wsdl/onvif.h:3705 */
class _tad__GetAnalyticsEngineControlResponse;	/* ../../wsdl/onvif.h:3708 */
class _tad__GetAnalyticsEngineControls;	/* ../../wsdl/onvif.h:3711 */
class _tad__GetAnalyticsEngineControlsResponse;	/* ../../wsdl/onvif.h:3714 */
class _tad__GetAnalyticsEngine;	/* ../../wsdl/onvif.h:3717 */
class _tad__GetAnalyticsEngineResponse;	/* ../../wsdl/onvif.h:3720 */
class _tad__GetAnalyticsEngines;	/* ../../wsdl/onvif.h:3723 */
class _tad__GetAnalyticsEnginesResponse;	/* ../../wsdl/onvif.h:3726 */
class _tad__SetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:3729 */
class _tad__SetVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:3732 */
class _tad__SetAnalyticsEngineInput;	/* ../../wsdl/onvif.h:3735 */
class _tad__SetAnalyticsEngineInputResponse;	/* ../../wsdl/onvif.h:3738 */
class _tad__GetAnalyticsEngineInput;	/* ../../wsdl/onvif.h:3741 */
class _tad__GetAnalyticsEngineInputResponse;	/* ../../wsdl/onvif.h:3744 */
class _tad__GetAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:3747 */
class _tad__GetAnalyticsEngineInputsResponse;	/* ../../wsdl/onvif.h:3750 */
class _tad__GetAnalyticsDeviceStreamUri;	/* ../../wsdl/onvif.h:3753 */
class _tad__GetAnalyticsDeviceStreamUriResponse;	/* ../../wsdl/onvif.h:3756 */
class _tad__GetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:3759 */
class _tad__GetVideoAnalyticsConfigurationResponse;	/* ../../wsdl/onvif.h:3762 */
class _tad__DeleteAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:3765 */
class _tad__DeleteAnalyticsEngineInputsResponse;	/* ../../wsdl/onvif.h:3768 */
class _tad__GetAnalyticsState;	/* ../../wsdl/onvif.h:3771 */
class _tad__GetAnalyticsStateResponse;	/* ../../wsdl/onvif.h:3774 */
class ns1__ActionConfigDescription;	/* ../../wsdl/onvif.h:3777 */
class ns1__SupportedActions;	/* ../../wsdl/onvif.h:3780 */
class ns1__SupportedActionsExtension;	/* ../../wsdl/onvif.h:3783 */
class ns1__ActionEngineCapabilities;	/* ../../wsdl/onvif.h:3786 */
class ns1__ActionEngineCapabilitiesExtension;	/* ../../wsdl/onvif.h:3789 */
class ns1__ActionTypeLimits;	/* ../../wsdl/onvif.h:3792 */
class ns1__ActionConfiguration;	/* ../../wsdl/onvif.h:3795 */
class ns1__Action;	/* ../../wsdl/onvif.h:3798 */
class ns1__ActionTriggerConfiguration;	/* ../../wsdl/onvif.h:3801 */
class ns1__ActionTriggerConfigurationExtension;	/* ../../wsdl/onvif.h:3804 */
class ns1__ActionTrigger;	/* ../../wsdl/onvif.h:3807 */
class ns1__onvif_USCOREaction;	/* ../../wsdl/onvif.h:3810 */
class ns1__EMailServerConfiguration;	/* ../../wsdl/onvif.h:3813 */
class ns1__SMTPConfig;	/* ../../wsdl/onvif.h:3816 */
class ns1__POPConfig;	/* ../../wsdl/onvif.h:3819 */
class ns1__HostAddress;	/* ../../wsdl/onvif.h:3822 */
class ns1__UserCredentials;	/* ../../wsdl/onvif.h:3825 */
class ns1__UserCredentialsExtension;	/* ../../wsdl/onvif.h:3828 */
class ns1__AuthenticationConfig;	/* ../../wsdl/onvif.h:3831 */
class ns1__EMailReceiverConfiguration;	/* ../../wsdl/onvif.h:3834 */
class ns1__EMailReceiverConfigurationExtension;	/* ../../wsdl/onvif.h:3837 */
class ns1__EMailAttachmentConfiguration;	/* ../../wsdl/onvif.h:3840 */
class ns1__EMailAttachmentConfigurationExtension;	/* ../../wsdl/onvif.h:3843 */
class ns1__EMailBodyTextConfiguration;	/* ../../wsdl/onvif.h:3846 */
class ns1__MediaSource;	/* ../../wsdl/onvif.h:3849 */
class ns1__HttpHostConfigurations;	/* ../../wsdl/onvif.h:3852 */
class ns1__HttpHostConfigurationsExtension;	/* ../../wsdl/onvif.h:3855 */
class ns1__HttpDestinationConfiguration;	/* ../../wsdl/onvif.h:3858 */
class ns1__HttpDestinationConfigurationExtension;	/* ../../wsdl/onvif.h:3861 */
class ns1__HttpAuthenticationConfiguration;	/* ../../wsdl/onvif.h:3864 */
class ns1__HttpAuthenticationConfigurationExtension;	/* ../../wsdl/onvif.h:3867 */
class ns1__HttpHostAddress;	/* ../../wsdl/onvif.h:3870 */
class ns1__PostContentConfiguration;	/* ../../wsdl/onvif.h:3873 */
class ns1__PostBodyConfiguration;	/* ../../wsdl/onvif.h:3876 */
class ns1__FtpHostConfigurations;	/* ../../wsdl/onvif.h:3879 */
class ns1__FtpHostConfigurationsExtension;	/* ../../wsdl/onvif.h:3882 */
class ns1__FtpDestinationConfiguration;	/* ../../wsdl/onvif.h:3885 */
class ns1__FtpDestinationConfigurationExtension;	/* ../../wsdl/onvif.h:3888 */
class ns1__FtpAuthenticationConfiguration;	/* ../../wsdl/onvif.h:3891 */
class ns1__FtpAuthenticationConfigurationExtension;	/* ../../wsdl/onvif.h:3894 */
class ns1__FtpHostAddress;	/* ../../wsdl/onvif.h:3897 */
class ns1__FtpContent;	/* ../../wsdl/onvif.h:3900 */
class ns1__FtpFileNameConfigurations;	/* ../../wsdl/onvif.h:3903 */
union _ns1__union_FtpContentConfiguration;	/* ../../wsdl/onvif.h:39300 */
class ns1__FtpContentConfiguration;	/* ../../wsdl/onvif.h:3906 */
class ns1__FtpContentConfigurationUploadImages;	/* ../../wsdl/onvif.h:3909 */
class ns1__FtpContentConfigurationUploadFile;	/* ../../wsdl/onvif.h:3912 */
class ns1__SMSProviderConfiguration;	/* ../../wsdl/onvif.h:3915 */
class ns1__SMSSenderConfiguration;	/* ../../wsdl/onvif.h:3918 */
class ns1__SMSMessage;	/* ../../wsdl/onvif.h:3921 */
class ns1__TriggeredRecordingConfiguration;	/* ../../wsdl/onvif.h:3924 */
class ns1__RecordingActionConfiguration;	/* ../../wsdl/onvif.h:3927 */
class _ns1__GetSupportedActions;	/* ../../wsdl/onvif.h:3930 */
class _ns1__GetSupportedActionsResponse;	/* ../../wsdl/onvif.h:3933 */
class _ns1__GetActions;	/* ../../wsdl/onvif.h:3936 */
class _ns1__GetActionsResponse;	/* ../../wsdl/onvif.h:3939 */
class _ns1__CreateActions;	/* ../../wsdl/onvif.h:3942 */
class _ns1__CreateActionsResponse;	/* ../../wsdl/onvif.h:3945 */
class _ns1__DeleteActions;	/* ../../wsdl/onvif.h:3948 */
class _ns1__DeleteActionsResponse;	/* ../../wsdl/onvif.h:3951 */
class _ns1__ModifyActions;	/* ../../wsdl/onvif.h:3954 */
class _ns1__ModifyActionsResponse;	/* ../../wsdl/onvif.h:3957 */
class _ns1__GetServiceCapabilities;	/* ../../wsdl/onvif.h:3960 */
class _ns1__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:3963 */
class _ns1__GetActionTriggers;	/* ../../wsdl/onvif.h:3966 */
class _ns1__GetActionTriggersResponse;	/* ../../wsdl/onvif.h:3969 */
class _ns1__CreateActionTriggers;	/* ../../wsdl/onvif.h:3972 */
class _ns1__CreateActionTriggersResponse;	/* ../../wsdl/onvif.h:3975 */
class _ns1__ModifyActionTriggers;	/* ../../wsdl/onvif.h:3978 */
class _ns1__ModifyActionTriggersResponse;	/* ../../wsdl/onvif.h:3981 */
class _ns1__DeleteActionTriggers;	/* ../../wsdl/onvif.h:3984 */
class _ns1__DeleteActionTriggersResponse;	/* ../../wsdl/onvif.h:3987 */
class ns2__ServiceCapabilities;	/* ../../wsdl/onvif.h:3990 */
class ns2__AccessPointCapabilities;	/* ../../wsdl/onvif.h:3999 */
class ns2__AccessPointState;	/* ../../wsdl/onvif.h:4008 */
class _ns2__GetServiceCapabilities;	/* ../../wsdl/onvif.h:4011 */
class _ns2__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:4014 */
class _ns2__GetAccessPointInfoList;	/* ../../wsdl/onvif.h:4017 */
class _ns2__GetAccessPointInfoListResponse;	/* ../../wsdl/onvif.h:4020 */
class _ns2__GetAccessPointInfo;	/* ../../wsdl/onvif.h:4023 */
class _ns2__GetAccessPointInfoResponse;	/* ../../wsdl/onvif.h:4026 */
class _ns2__GetAreaInfoList;	/* ../../wsdl/onvif.h:4029 */
class _ns2__GetAreaInfoListResponse;	/* ../../wsdl/onvif.h:4032 */
class _ns2__GetAreaInfo;	/* ../../wsdl/onvif.h:4035 */
class _ns2__GetAreaInfoResponse;	/* ../../wsdl/onvif.h:4038 */
class _ns2__GetAccessPointState;	/* ../../wsdl/onvif.h:4041 */
class _ns2__GetAccessPointStateResponse;	/* ../../wsdl/onvif.h:4044 */
class _ns2__EnableAccessPoint;	/* ../../wsdl/onvif.h:4047 */
class _ns2__EnableAccessPointResponse;	/* ../../wsdl/onvif.h:4050 */
class _ns2__DisableAccessPoint;	/* ../../wsdl/onvif.h:4053 */
class _ns2__DisableAccessPointResponse;	/* ../../wsdl/onvif.h:4056 */
class _ns2__ExternalAuthorization;	/* ../../wsdl/onvif.h:4059 */
class _ns2__ExternalAuthorizationResponse;	/* ../../wsdl/onvif.h:4062 */
class ns3__DataEntity;	/* ../../wsdl/onvif.h:4065 */
class ns4__ServiceCapabilities;	/* ../../wsdl/onvif.h:4068 */
class ns4__DoorCapabilities;	/* ../../wsdl/onvif.h:4077 */
class ns4__DoorState;	/* ../../wsdl/onvif.h:4080 */
class ns4__DoorTamper;	/* ../../wsdl/onvif.h:4083 */
class ns4__DoorFault;	/* ../../wsdl/onvif.h:4086 */
class ns4__AccessDoorExtension;	/* ../../wsdl/onvif.h:4089 */
class _ns4__GetServiceCapabilities;	/* ../../wsdl/onvif.h:4092 */
class _ns4__GetServiceCapabilitiesResponse;	/* ../../wsdl/onvif.h:4095 */
class _ns4__GetDoorInfoList;	/* ../../wsdl/onvif.h:4098 */
class _ns4__GetDoorInfoListResponse;	/* ../../wsdl/onvif.h:4101 */
class _ns4__GetDoorInfo;	/* ../../wsdl/onvif.h:4104 */
class _ns4__GetDoorInfoResponse;	/* ../../wsdl/onvif.h:4107 */
class _ns4__GetDoorState;	/* ../../wsdl/onvif.h:4110 */
class _ns4__GetDoorStateResponse;	/* ../../wsdl/onvif.h:4113 */
class _ns4__AccessDoor;	/* ../../wsdl/onvif.h:4116 */
class _ns4__AccessDoorResponse;	/* ../../wsdl/onvif.h:4119 */
class _ns4__LockDoor;	/* ../../wsdl/onvif.h:4122 */
class _ns4__LockDoorResponse;	/* ../../wsdl/onvif.h:4125 */
class _ns4__UnlockDoor;	/* ../../wsdl/onvif.h:4128 */
class _ns4__UnlockDoorResponse;	/* ../../wsdl/onvif.h:4131 */
class _ns4__BlockDoor;	/* ../../wsdl/onvif.h:4134 */
class _ns4__BlockDoorResponse;	/* ../../wsdl/onvif.h:4137 */
class _ns4__LockDownDoor;	/* ../../wsdl/onvif.h:4140 */
class _ns4__LockDownDoorResponse;	/* ../../wsdl/onvif.h:4143 */
class _ns4__LockDownReleaseDoor;	/* ../../wsdl/onvif.h:4146 */
class _ns4__LockDownReleaseDoorResponse;	/* ../../wsdl/onvif.h:4149 */
class _ns4__LockOpenDoor;	/* ../../wsdl/onvif.h:4152 */
class _ns4__LockOpenDoorResponse;	/* ../../wsdl/onvif.h:4155 */
class _ns4__LockOpenReleaseDoor;	/* ../../wsdl/onvif.h:4158 */
class _ns4__LockOpenReleaseDoorResponse;	/* ../../wsdl/onvif.h:4161 */
class _ns4__DoubleLockDoor;	/* ../../wsdl/onvif.h:4164 */
class _ns4__DoubleLockDoorResponse;	/* ../../wsdl/onvif.h:4167 */
class tmd__SerialPort;	/* ../../wsdl/onvif.h:456 */
class tt__VideoSource;	/* ../../wsdl/onvif.h:1062 */
class tt__AudioSource;	/* ../../wsdl/onvif.h:1071 */
class tt__VideoSourceConfiguration;	/* ../../wsdl/onvif.h:1086 */
class tt__VideoEncoderConfiguration;	/* ../../wsdl/onvif.h:1116 */
class tt__JpegOptions2;	/* ../../wsdl/onvif.h:1143 */
class tt__Mpeg4Options2;	/* ../../wsdl/onvif.h:1149 */
class tt__H264Options2;	/* ../../wsdl/onvif.h:1155 */
class tt__AudioSourceConfiguration;	/* ../../wsdl/onvif.h:1158 */
class tt__AudioEncoderConfiguration;	/* ../../wsdl/onvif.h:1167 */
class tt__VideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:1176 */
class tt__MetadataConfiguration;	/* ../../wsdl/onvif.h:1179 */
class tt__VideoOutput;	/* ../../wsdl/onvif.h:1200 */
class tt__VideoOutputConfiguration;	/* ../../wsdl/onvif.h:1206 */
class tt__AudioOutput;	/* ../../wsdl/onvif.h:1227 */
class tt__AudioOutputConfiguration;	/* ../../wsdl/onvif.h:1230 */
class tt__AudioDecoderConfiguration;	/* ../../wsdl/onvif.h:1236 */
class tt__NetworkInterface;	/* ../../wsdl/onvif.h:1269 */
class tt__CertificateUsage;	/* ../../wsdl/onvif.h:1581 */
class tt__RelayOutput;	/* ../../wsdl/onvif.h:1608 */
class tt__DigitalInput;	/* ../../wsdl/onvif.h:1611 */
class tt__PTZNode;	/* ../../wsdl/onvif.h:1614 */
class tt__PTZConfiguration;	/* ../../wsdl/onvif.h:1629 */
class tt__Object;	/* ../../wsdl/onvif.h:1989 */
class tt__EventFilter;	/* ../../wsdl/onvif.h:2166 */
class tt__AnalyticsEngine;	/* ../../wsdl/onvif.h:2274 */
class tt__AnalyticsEngineInput;	/* ../../wsdl/onvif.h:2292 */
class tt__AnalyticsEngineControl;	/* ../../wsdl/onvif.h:2307 */
class wsnt__SubscribeCreationFailedFaultType;	/* ../../wsdl/onvif.h:2340 */
class wsnt__InvalidFilterFaultType;	/* ../../wsdl/onvif.h:2343 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* ../../wsdl/onvif.h:2346 */
class wsnt__InvalidTopicExpressionFaultType;	/* ../../wsdl/onvif.h:2349 */
class wsnt__TopicNotSupportedFaultType;	/* ../../wsdl/onvif.h:2352 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* ../../wsdl/onvif.h:2355 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* ../../wsdl/onvif.h:2358 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* ../../wsdl/onvif.h:2361 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* ../../wsdl/onvif.h:2364 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* ../../wsdl/onvif.h:2367 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* ../../wsdl/onvif.h:2370 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* ../../wsdl/onvif.h:2373 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* ../../wsdl/onvif.h:2376 */
class wsnt__UnableToGetMessagesFaultType;	/* ../../wsdl/onvif.h:2379 */
class wsnt__UnableToDestroyPullPointFaultType;	/* ../../wsdl/onvif.h:2382 */
class wsnt__UnableToCreatePullPointFaultType;	/* ../../wsdl/onvif.h:2385 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* ../../wsdl/onvif.h:2388 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* ../../wsdl/onvif.h:2391 */
class wsnt__PauseFailedFaultType;	/* ../../wsdl/onvif.h:2394 */
class wsnt__ResumeFailedFaultType;	/* ../../wsdl/onvif.h:2397 */
class _wstop__TopicNamespaceType_Topic;	/* ../../wsdl/onvif.h:45190 */
class wstop__TopicNamespaceType;	/* ../../wsdl/onvif.h:2478 */
class wstop__TopicType;	/* ../../wsdl/onvif.h:2481 */
class wstop__TopicSetType;	/* ../../wsdl/onvif.h:2484 */
class wsrfr__ResourceUnknownFaultType;	/* ../../wsdl/onvif.h:3039 */
class wsrfr__ResourceUnavailableFaultType;	/* ../../wsdl/onvif.h:3042 */
class ns2__AccessPointInfoBase;	/* ../../wsdl/onvif.h:3993 */
class ns2__AreaInfoBase;	/* ../../wsdl/onvif.h:4002 */
class ns4__DoorInfoBase;	/* ../../wsdl/onvif.h:4071 */
class ns2__AccessPointInfo;	/* ../../wsdl/onvif.h:3996 */
class ns2__AreaInfo;	/* ../../wsdl/onvif.h:4005 */
class ns4__DoorInfo;	/* ../../wsdl/onvif.h:4074 */
struct __ns1__GetSupportedActions;	/* ../../wsdl/onvif.h:47671 */
struct __ns1__GetActions;	/* ../../wsdl/onvif.h:47738 */
struct __ns1__CreateActions;	/* ../../wsdl/onvif.h:47807 */
struct __ns1__DeleteActions;	/* ../../wsdl/onvif.h:47876 */
struct __ns1__ModifyActions;	/* ../../wsdl/onvif.h:47943 */
struct __ns1__GetServiceCapabilities;	/* ../../wsdl/onvif.h:48010 */
struct __ns1__GetActionTriggers;	/* ../../wsdl/onvif.h:48077 */
struct __ns1__CreateActionTriggers;	/* ../../wsdl/onvif.h:48146 */
struct __ns1__DeleteActionTriggers;	/* ../../wsdl/onvif.h:48215 */
struct __ns1__ModifyActionTriggers;	/* ../../wsdl/onvif.h:48284 */
struct __ns2__GetServiceCapabilities;	/* ../../wsdl/onvif.h:48373 */
struct __ns2__GetAccessPointInfoList;	/* ../../wsdl/onvif.h:48452 */
struct __ns2__GetAccessPointInfo;	/* ../../wsdl/onvif.h:48532 */
struct __ns2__GetAreaInfoList;	/* ../../wsdl/onvif.h:48612 */
struct __ns2__GetAreaInfo;	/* ../../wsdl/onvif.h:48692 */
struct __ns2__GetAccessPointState;	/* ../../wsdl/onvif.h:48764 */
struct __ns2__EnableAccessPoint;	/* ../../wsdl/onvif.h:48837 */
struct __ns2__DisableAccessPoint;	/* ../../wsdl/onvif.h:48910 */
struct __ns2__ExternalAuthorization;	/* ../../wsdl/onvif.h:48981 */
struct __ns4__GetServiceCapabilities;	/* ../../wsdl/onvif.h:49070 */
struct __ns4__GetDoorInfoList;	/* ../../wsdl/onvif.h:49148 */
struct __ns4__GetDoorInfo;	/* ../../wsdl/onvif.h:49225 */
struct __ns4__GetDoorState;	/* ../../wsdl/onvif.h:49297 */
struct __ns4__AccessDoor;	/* ../../wsdl/onvif.h:49387 */
struct __ns4__LockDoor;	/* ../../wsdl/onvif.h:49463 */
struct __ns4__UnlockDoor;	/* ../../wsdl/onvif.h:49539 */
struct __ns4__BlockDoor;	/* ../../wsdl/onvif.h:49616 */
struct __ns4__LockDownDoor;	/* ../../wsdl/onvif.h:49699 */
struct __ns4__LockDownReleaseDoor;	/* ../../wsdl/onvif.h:49771 */
struct __ns4__LockOpenDoor;	/* ../../wsdl/onvif.h:49851 */
struct __ns4__LockOpenReleaseDoor;	/* ../../wsdl/onvif.h:49924 */
struct __ns4__DoubleLockDoor;	/* ../../wsdl/onvif.h:50002 */
struct __tad__GetServiceCapabilities;	/* ../../wsdl/onvif.h:50088 */
struct __tad__DeleteAnalyticsEngineControl;	/* ../../wsdl/onvif.h:50155 */
struct __tad__CreateAnalyticsEngineControl;	/* ../../wsdl/onvif.h:50222 */
struct __tad__SetAnalyticsEngineControl;	/* ../../wsdl/onvif.h:50289 */
struct __tad__GetAnalyticsEngineControl;	/* ../../wsdl/onvif.h:50357 */
struct __tad__GetAnalyticsEngineControls;	/* ../../wsdl/onvif.h:50424 */
struct __tad__GetAnalyticsEngine;	/* ../../wsdl/onvif.h:50492 */
struct __tad__GetAnalyticsEngines;	/* ../../wsdl/onvif.h:50559 */
struct __tad__SetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:50626 */
struct __tad__SetAnalyticsEngineInput;	/* ../../wsdl/onvif.h:50693 */
struct __tad__GetAnalyticsEngineInput;	/* ../../wsdl/onvif.h:50761 */
struct __tad__GetAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:50829 */
struct __tad__GetAnalyticsDeviceStreamUri;	/* ../../wsdl/onvif.h:50897 */
struct __tad__GetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:50965 */
struct __tad__CreateAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:51032 */
struct __tad__DeleteAnalyticsEngineInputs;	/* ../../wsdl/onvif.h:51099 */
struct __tad__GetAnalyticsState;	/* ../../wsdl/onvif.h:51167 */
struct __tan__GetSupportedRules;	/* ../../wsdl/onvif.h:51258 */
struct __tan__CreateRules;	/* ../../wsdl/onvif.h:51328 */
struct __tan__DeleteRules;	/* ../../wsdl/onvif.h:51397 */
struct __tan__GetRules;	/* ../../wsdl/onvif.h:51466 */
struct __tan__ModifyRules;	/* ../../wsdl/onvif.h:51536 */
struct __tan__GetServiceCapabilities;	/* ../../wsdl/onvif.h:51604 */
struct __tan__GetSupportedAnalyticsModules;	/* ../../wsdl/onvif.h:51678 */
struct __tan__CreateAnalyticsModules;	/* ../../wsdl/onvif.h:51749 */
struct __tan__DeleteAnalyticsModules;	/* ../../wsdl/onvif.h:51818 */
struct __tan__GetAnalyticsModules;	/* ../../wsdl/onvif.h:51888 */
struct __tan__ModifyAnalyticsModules;	/* ../../wsdl/onvif.h:51959 */
struct __tdn__Hello;	/* ../../wsdl/onvif.h:52043 */
struct __tdn__Bye;	/* ../../wsdl/onvif.h:52109 */
struct __tdn__Probe;	/* ../../wsdl/onvif.h:52175 */
struct __tds__GetServices;	/* ../../wsdl/onvif.h:52260 */
struct __tds__GetServiceCapabilities;	/* ../../wsdl/onvif.h:52328 */
struct __tds__GetDeviceInformation;	/* ../../wsdl/onvif.h:52395 */
struct __tds__SetSystemDateAndTime;	/* ../../wsdl/onvif.h:52467 */
struct __tds__GetSystemDateAndTime;	/* ../../wsdl/onvif.h:52539 */
struct __tds__SetSystemFactoryDefault;	/* ../../wsdl/onvif.h:52606 */
struct __tds__UpgradeSystemFirmware;	/* ../../wsdl/onvif.h:52679 */
struct __tds__SystemReboot;	/* ../../wsdl/onvif.h:52746 */
struct __tds__RestoreSystem;	/* ../../wsdl/onvif.h:52821 */
struct __tds__GetSystemBackup;	/* ../../wsdl/onvif.h:52895 */
struct __tds__GetSystemLog;	/* ../../wsdl/onvif.h:52963 */
struct __tds__GetSystemSupportInformation;	/* ../../wsdl/onvif.h:53030 */
struct __tds__GetScopes;	/* ../../wsdl/onvif.h:53101 */
struct __tds__SetScopes;	/* ../../wsdl/onvif.h:53176 */
struct __tds__AddScopes;	/* ../../wsdl/onvif.h:53247 */
struct __tds__RemoveScopes;	/* ../../wsdl/onvif.h:53320 */
struct __tds__GetDiscoveryMode;	/* ../../wsdl/onvif.h:53391 */
struct __tds__SetDiscoveryMode;	/* ../../wsdl/onvif.h:53463 */
struct __tds__GetRemoteDiscoveryMode;	/* ../../wsdl/onvif.h:53536 */
struct __tds__SetRemoteDiscoveryMode;	/* ../../wsdl/onvif.h:53609 */
struct __tds__GetDPAddresses;	/* ../../wsdl/onvif.h:53680 */
struct __tds__GetEndpointReference;	/* ../../wsdl/onvif.h:53753 */
struct __tds__GetRemoteUser;	/* ../../wsdl/onvif.h:53824 */
struct __tds__SetRemoteUser;	/* ../../wsdl/onvif.h:53894 */
struct __tds__GetUsers;	/* ../../wsdl/onvif.h:53965 */
struct __tds__CreateUsers;	/* ../../wsdl/onvif.h:54038 */
struct __tds__DeleteUsers;	/* ../../wsdl/onvif.h:54112 */
struct __tds__SetUser;	/* ../../wsdl/onvif.h:54184 */
struct __tds__GetWsdlUrl;	/* ../../wsdl/onvif.h:54258 */
struct __tds__GetCapabilities;	/* ../../wsdl/onvif.h:54334 */
struct __tds__SetDPAddresses;	/* ../../wsdl/onvif.h:54406 */
struct __tds__GetHostname;	/* ../../wsdl/onvif.h:54476 */
struct __tds__SetHostname;	/* ../../wsdl/onvif.h:54545 */
struct __tds__SetHostnameFromDHCP;	/* ../../wsdl/onvif.h:54612 */
struct __tds__GetDNS;	/* ../../wsdl/onvif.h:54681 */
struct __tds__SetDNS;	/* ../../wsdl/onvif.h:54750 */
struct __tds__GetNTP;	/* ../../wsdl/onvif.h:54820 */
struct __tds__SetNTP;	/* ../../wsdl/onvif.h:54890 */
struct __tds__GetDynamicDNS;	/* ../../wsdl/onvif.h:54961 */
struct __tds__SetDynamicDNS;	/* ../../wsdl/onvif.h:55032 */
struct __tds__GetNetworkInterfaces;	/* ../../wsdl/onvif.h:55103 */
struct __tds__SetNetworkInterfaces;	/* ../../wsdl/onvif.h:55174 */
struct __tds__GetNetworkProtocols;	/* ../../wsdl/onvif.h:55244 */
struct __tds__SetNetworkProtocols;	/* ../../wsdl/onvif.h:55314 */
struct __tds__GetNetworkDefaultGateway;	/* ../../wsdl/onvif.h:55384 */
struct __tds__SetNetworkDefaultGateway;	/* ../../wsdl/onvif.h:55453 */
struct __tds__GetZeroConfiguration;	/* ../../wsdl/onvif.h:55525 */
struct __tds__SetZeroConfiguration;	/* ../../wsdl/onvif.h:55593 */
struct __tds__GetIPAddressFilter;	/* ../../wsdl/onvif.h:55664 */
struct __tds__SetIPAddressFilter;	/* ../../wsdl/onvif.h:55737 */
struct __tds__AddIPAddressFilter;	/* ../../wsdl/onvif.h:55809 */
struct __tds__RemoveIPAddressFilter;	/* ../../wsdl/onvif.h:55881 */
struct __tds__GetAccessPolicy;	/* ../../wsdl/onvif.h:55962 */
struct __tds__SetAccessPolicy;	/* ../../wsdl/onvif.h:56034 */
struct __tds__CreateCertificate;	/* ../../wsdl/onvif.h:56105 */
struct __tds__GetCertificates;	/* ../../wsdl/onvif.h:56184 */
struct __tds__GetCertificatesStatus;	/* ../../wsdl/onvif.h:56254 */
struct __tds__SetCertificatesStatus;	/* ../../wsdl/onvif.h:56326 */
struct __tds__DeleteCertificates;	/* ../../wsdl/onvif.h:56401 */
struct __tds__GetPkcs10Request;	/* ../../wsdl/onvif.h:56478 */
struct __tds__LoadCertificates;	/* ../../wsdl/onvif.h:56559 */
struct __tds__GetClientCertificateMode;	/* ../../wsdl/onvif.h:56629 */
struct __tds__SetClientCertificateMode;	/* ../../wsdl/onvif.h:56699 */
struct __tds__GetRelayOutputs;	/* ../../wsdl/onvif.h:56766 */
struct __tds__SetRelayOutputSettings;	/* ../../wsdl/onvif.h:56834 */
struct __tds__SetRelayOutputState;	/* ../../wsdl/onvif.h:56902 */
struct __tds__SendAuxiliaryCommand;	/* ../../wsdl/onvif.h:56972 */
struct __tds__GetCACertificates;	/* ../../wsdl/onvif.h:57050 */
struct __tds__LoadCertificateWithPrivateKey;	/* ../../wsdl/onvif.h:57127 */
struct __tds__GetCertificateInformation;	/* ../../wsdl/onvif.h:57202 */
struct __tds__LoadCACertificates;	/* ../../wsdl/onvif.h:57274 */
struct __tds__CreateDot1XConfiguration;	/* ../../wsdl/onvif.h:57349 */
struct __tds__SetDot1XConfiguration;	/* ../../wsdl/onvif.h:57420 */
struct __tds__GetDot1XConfiguration;	/* ../../wsdl/onvif.h:57489 */
struct __tds__GetDot1XConfigurations;	/* ../../wsdl/onvif.h:57561 */
struct __tds__DeleteDot1XConfiguration;	/* ../../wsdl/onvif.h:57633 */
struct __tds__GetDot11Capabilities;	/* ../../wsdl/onvif.h:57701 */
struct __tds__GetDot11Status;	/* ../../wsdl/onvif.h:57770 */
struct __tds__ScanAvailableDot11Networks;	/* ../../wsdl/onvif.h:57839 */
struct __tds__GetSystemUris;	/* ../../wsdl/onvif.h:57908 */
struct __tds__StartFirmwareUpgrade;	/* ../../wsdl/onvif.h:57985 */
struct __tds__StartSystemRestore;	/* ../../wsdl/onvif.h:58062 */
struct __tev__PullMessages;	/* ../../wsdl/onvif.h:58157 */
struct __tev__Seek;	/* ../../wsdl/onvif.h:58234 */
struct __tev__SetSynchronizationPoint;	/* ../../wsdl/onvif.h:58316 */
struct __tev__GetServiceCapabilities;	/* ../../wsdl/onvif.h:58384 */
struct __tev__CreatePullPointSubscription;	/* ../../wsdl/onvif.h:58490 */
struct __tev__GetEventProperties;	/* ../../wsdl/onvif.h:58564 */
struct __tev__Renew;	/* ../../wsdl/onvif.h:58636 */
struct __tev__Unsubscribe;	/* ../../wsdl/onvif.h:58708 */
struct __tev__Subscribe;	/* ../../wsdl/onvif.h:58810 */
struct __tev__GetCurrentMessage;	/* ../../wsdl/onvif.h:58894 */
struct __tev__Notify;	/* ../../wsdl/onvif.h:58956 */
struct __tev__GetMessages;	/* ../../wsdl/onvif.h:59028 */
struct __tev__DestroyPullPoint;	/* ../../wsdl/onvif.h:59100 */
struct __tev__Notify_;	/* ../../wsdl/onvif.h:59162 */
struct __tev__CreatePullPoint;	/* ../../wsdl/onvif.h:59231 */
struct __tev__Renew_;	/* ../../wsdl/onvif.h:59303 */
struct __tev__Unsubscribe_;	/* ../../wsdl/onvif.h:59375 */
struct __tev__PauseSubscription;	/* ../../wsdl/onvif.h:59447 */
struct __tev__ResumeSubscription;	/* ../../wsdl/onvif.h:59519 */
struct __timg__GetServiceCapabilities;	/* ../../wsdl/onvif.h:59605 */
struct __timg__GetImagingSettings;	/* ../../wsdl/onvif.h:59672 */
struct __timg__SetImagingSettings;	/* ../../wsdl/onvif.h:59739 */
struct __timg__GetOptions;	/* ../../wsdl/onvif.h:59812 */
struct __timg__Move;	/* ../../wsdl/onvif.h:59890 */
struct __timg__Stop;	/* ../../wsdl/onvif.h:59959 */
struct __timg__GetStatus;	/* ../../wsdl/onvif.h:60028 */
struct __timg__GetMoveOptions;	/* ../../wsdl/onvif.h:60095 */
struct __tls__GetServiceCapabilities;	/* ../../wsdl/onvif.h:60181 */
struct __tls__GetLayout;	/* ../../wsdl/onvif.h:60252 */
struct __tls__SetLayout;	/* ../../wsdl/onvif.h:60324 */
struct __tls__GetDisplayOptions;	/* ../../wsdl/onvif.h:60395 */
struct __tls__GetPaneConfigurations;	/* ../../wsdl/onvif.h:60470 */
struct __tls__GetPaneConfiguration;	/* ../../wsdl/onvif.h:60537 */
struct __tls__SetPaneConfigurations;	/* ../../wsdl/onvif.h:60607 */
struct __tls__SetPaneConfiguration;	/* ../../wsdl/onvif.h:60674 */
struct __tls__CreatePaneConfiguration;	/* ../../wsdl/onvif.h:60742 */
struct __tls__DeletePaneConfiguration;	/* ../../wsdl/onvif.h:60810 */
struct __tmd__GetServiceCapabilities;	/* ../../wsdl/onvif.h:60896 */
struct __tmd__GetRelayOutputOptions;	/* ../../wsdl/onvif.h:60964 */
struct __tmd__GetAudioSources;	/* ../../wsdl/onvif.h:61033 */
struct __tmd__GetAudioOutputs;	/* ../../wsdl/onvif.h:61102 */
struct __tmd__GetVideoSources;	/* ../../wsdl/onvif.h:61171 */
struct __tmd__GetVideoOutputs;	/* ../../wsdl/onvif.h:61240 */
struct __tmd__GetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:61308 */
struct __tmd__GetVideoOutputConfiguration;	/* ../../wsdl/onvif.h:61376 */
struct __tmd__GetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:61444 */
struct __tmd__GetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:61513 */
struct __tmd__SetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:61581 */
struct __tmd__SetVideoOutputConfiguration;	/* ../../wsdl/onvif.h:61649 */
struct __tmd__SetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:61717 */
struct __tmd__SetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:61785 */
struct __tmd__GetVideoSourceConfigurationOptions;	/* ../../wsdl/onvif.h:61853 */
struct __tmd__GetVideoOutputConfigurationOptions;	/* ../../wsdl/onvif.h:61922 */
struct __tmd__GetAudioSourceConfigurationOptions;	/* ../../wsdl/onvif.h:61990 */
struct __tmd__GetAudioOutputConfigurationOptions;	/* ../../wsdl/onvif.h:62058 */
struct __tmd__GetRelayOutputs;	/* ../../wsdl/onvif.h:62125 */
struct __tmd__SetRelayOutputSettings;	/* ../../wsdl/onvif.h:62193 */
struct __tmd__SetRelayOutputState;	/* ../../wsdl/onvif.h:62260 */
struct __tmd__GetDigitalInputs;	/* ../../wsdl/onvif.h:62326 */
struct __tmd__GetSerialPorts;	/* ../../wsdl/onvif.h:62392 */
struct __tmd__GetSerialPortConfiguration;	/* ../../wsdl/onvif.h:62458 */
struct __tmd__SetSerialPortConfiguration;	/* ../../wsdl/onvif.h:62524 */
struct __tmd__GetSerialPortConfigurationOptions;	/* ../../wsdl/onvif.h:62590 */
struct __tmd__SendReceiveSerialCommand;	/* ../../wsdl/onvif.h:62656 */
struct __tptz__GetServiceCapabilities;	/* ../../wsdl/onvif.h:62741 */
struct __tptz__GetConfigurations;	/* ../../wsdl/onvif.h:62810 */
struct __tptz__GetPresets;	/* ../../wsdl/onvif.h:62880 */
struct __tptz__SetPreset;	/* ../../wsdl/onvif.h:62965 */
struct __tptz__RemovePreset;	/* ../../wsdl/onvif.h:63039 */
struct __tptz__GotoPreset;	/* ../../wsdl/onvif.h:63109 */
struct __tptz__GetStatus;	/* ../../wsdl/onvif.h:63179 */
struct __tptz__GetConfiguration;	/* ../../wsdl/onvif.h:63248 */
struct __tptz__GetNodes;	/* ../../wsdl/onvif.h:63317 */
struct __tptz__GetNode;	/* ../../wsdl/onvif.h:63386 */
struct __tptz__SetConfiguration;	/* ../../wsdl/onvif.h:63455 */
struct __tptz__GetConfigurationOptions;	/* ../../wsdl/onvif.h:63534 */
struct __tptz__GotoHomePosition;	/* ../../wsdl/onvif.h:63603 */
struct __tptz__SetHomePosition;	/* ../../wsdl/onvif.h:63675 */
struct __tptz__ContinuousMove;	/* ../../wsdl/onvif.h:63745 */
struct __tptz__RelativeMove;	/* ../../wsdl/onvif.h:63813 */
struct __tptz__SendAuxiliaryCommand;	/* ../../wsdl/onvif.h:63885 */
struct __tptz__AbsoluteMove;	/* ../../wsdl/onvif.h:63952 */
struct __tptz__Stop;	/* ../../wsdl/onvif.h:64022 */
struct __tptz__GetPresetTours;	/* ../../wsdl/onvif.h:64089 */
struct __tptz__GetPresetTour;	/* ../../wsdl/onvif.h:64156 */
struct __tptz__GetPresetTourOptions;	/* ../../wsdl/onvif.h:64223 */
struct __tptz__CreatePresetTour;	/* ../../wsdl/onvif.h:64290 */
struct __tptz__ModifyPresetTour;	/* ../../wsdl/onvif.h:64357 */
struct __tptz__OperatePresetTour;	/* ../../wsdl/onvif.h:64424 */
struct __tptz__RemovePresetTour;	/* ../../wsdl/onvif.h:64491 */
struct __trc__GetServiceCapabilities;	/* ../../wsdl/onvif.h:64577 */
struct __trc__CreateRecording;	/* ../../wsdl/onvif.h:64646 */
struct __trc__DeleteRecording;	/* ../../wsdl/onvif.h:64723 */
struct __trc__GetRecordings;	/* ../../wsdl/onvif.h:64793 */
struct __trc__SetRecordingConfiguration;	/* ../../wsdl/onvif.h:64860 */
struct __trc__GetRecordingConfiguration;	/* ../../wsdl/onvif.h:64927 */
struct __trc__GetRecordingOptions;	/* ../../wsdl/onvif.h:64996 */
struct __trc__CreateTrack;	/* ../../wsdl/onvif.h:65063 */
struct __trc__DeleteTrack;	/* ../../wsdl/onvif.h:65131 */
struct __trc__GetTrackConfiguration;	/* ../../wsdl/onvif.h:65198 */
struct __trc__SetTrackConfiguration;	/* ../../wsdl/onvif.h:65265 */
struct __trc__CreateRecordingJob;	/* ../../wsdl/onvif.h:65332 */
struct __trc__DeleteRecordingJob;	/* ../../wsdl/onvif.h:65405 */
struct __trc__GetRecordingJobs;	/* ../../wsdl/onvif.h:65472 */
struct __trc__SetRecordingJobConfiguration;	/* ../../wsdl/onvif.h:65539 */
struct __trc__GetRecordingJobConfiguration;	/* ../../wsdl/onvif.h:65607 */
struct __trc__SetRecordingJobMode;	/* ../../wsdl/onvif.h:65678 */
struct __trc__GetRecordingJobState;	/* ../../wsdl/onvif.h:65747 */
struct __trp__GetServiceCapabilities;	/* ../../wsdl/onvif.h:65833 */
struct __trp__GetReplayUri;	/* ../../wsdl/onvif.h:65907 */
struct __trp__GetReplayConfiguration;	/* ../../wsdl/onvif.h:65978 */
struct __trp__SetReplayConfiguration;	/* ../../wsdl/onvif.h:66049 */
struct __trt__GetServiceCapabilities;	/* ../../wsdl/onvif.h:66135 */
struct __trt__GetVideoSources;	/* ../../wsdl/onvif.h:66202 */
struct __trt__GetAudioSources;	/* ../../wsdl/onvif.h:66269 */
struct __trt__GetAudioOutputs;	/* ../../wsdl/onvif.h:66336 */
struct __trt__CreateProfile;	/* ../../wsdl/onvif.h:66407 */
struct __trt__GetProfile;	/* ../../wsdl/onvif.h:66475 */
struct __trt__GetProfiles;	/* ../../wsdl/onvif.h:66547 */
struct __trt__AddVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:66621 */
struct __trt__AddVideoSourceConfiguration;	/* ../../wsdl/onvif.h:66691 */
struct __trt__AddAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:66765 */
struct __trt__AddAudioSourceConfiguration;	/* ../../wsdl/onvif.h:66835 */
struct __trt__AddPTZConfiguration;	/* ../../wsdl/onvif.h:66909 */
struct __trt__AddVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:66986 */
struct __trt__AddMetadataConfiguration;	/* ../../wsdl/onvif.h:67057 */
struct __trt__AddAudioOutputConfiguration;	/* ../../wsdl/onvif.h:67126 */
struct __trt__AddAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:67195 */
struct __trt__RemoveVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:67265 */
struct __trt__RemoveVideoSourceConfiguration;	/* ../../wsdl/onvif.h:67337 */
struct __trt__RemoveAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:67408 */
struct __trt__RemoveAudioSourceConfiguration;	/* ../../wsdl/onvif.h:67481 */
struct __trt__RemovePTZConfiguration;	/* ../../wsdl/onvif.h:67551 */
struct __trt__RemoveVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:67621 */
struct __trt__RemoveMetadataConfiguration;	/* ../../wsdl/onvif.h:67690 */
struct __trt__RemoveAudioOutputConfiguration;	/* ../../wsdl/onvif.h:67759 */
struct __trt__RemoveAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:67828 */
struct __trt__DeleteProfile;	/* ../../wsdl/onvif.h:67896 */
struct __trt__GetVideoSourceConfigurations;	/* ../../wsdl/onvif.h:67965 */
struct __trt__GetVideoEncoderConfigurations;	/* ../../wsdl/onvif.h:68035 */
struct __trt__GetAudioSourceConfigurations;	/* ../../wsdl/onvif.h:68105 */
struct __trt__GetAudioEncoderConfigurations;	/* ../../wsdl/onvif.h:68174 */
struct __trt__GetVideoAnalyticsConfigurations;	/* ../../wsdl/onvif.h:68243 */
struct __trt__GetMetadataConfigurations;	/* ../../wsdl/onvif.h:68311 */
struct __trt__GetAudioOutputConfigurations;	/* ../../wsdl/onvif.h:68379 */
struct __trt__GetAudioDecoderConfigurations;	/* ../../wsdl/onvif.h:68449 */
struct __trt__GetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:68517 */
struct __trt__GetVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:68585 */
struct __trt__GetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:68653 */
struct __trt__GetAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:68721 */
struct __trt__GetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:68789 */
struct __trt__GetMetadataConfiguration;	/* ../../wsdl/onvif.h:68857 */
struct __trt__GetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:68925 */
struct __trt__GetAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:68993 */
struct __trt__GetCompatibleVideoEncoderConfigurations;	/* ../../wsdl/onvif.h:69064 */
struct __trt__GetCompatibleVideoSourceConfigurations;	/* ../../wsdl/onvif.h:69137 */
struct __trt__GetCompatibleAudioEncoderConfigurations;	/* ../../wsdl/onvif.h:69208 */
struct __trt__GetCompatibleAudioSourceConfigurations;	/* ../../wsdl/onvif.h:69279 */
struct __trt__GetCompatibleVideoAnalyticsConfigurations;	/* ../../wsdl/onvif.h:69350 */
struct __trt__GetCompatibleMetadataConfigurations;	/* ../../wsdl/onvif.h:69421 */
struct __trt__GetCompatibleAudioOutputConfigurations;	/* ../../wsdl/onvif.h:69491 */
struct __trt__GetCompatibleAudioDecoderConfigurations;	/* ../../wsdl/onvif.h:69561 */
struct __trt__SetVideoSourceConfiguration;	/* ../../wsdl/onvif.h:69633 */
struct __trt__SetVideoEncoderConfiguration;	/* ../../wsdl/onvif.h:69706 */
struct __trt__SetAudioSourceConfiguration;	/* ../../wsdl/onvif.h:69780 */
struct __trt__SetAudioEncoderConfiguration;	/* ../../wsdl/onvif.h:69855 */
struct __trt__SetVideoAnalyticsConfiguration;	/* ../../wsdl/onvif.h:69932 */
struct __trt__SetMetadataConfiguration;	/* ../../wsdl/onvif.h:70008 */
struct __trt__SetAudioOutputConfiguration;	/* ../../wsdl/onvif.h:70077 */
struct __trt__SetAudioDecoderConfiguration;	/* ../../wsdl/onvif.h:70146 */
struct __trt__GetVideoSourceConfigurationOptions;	/* ../../wsdl/onvif.h:70219 */
struct __trt__GetVideoEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:70289 */
struct __trt__GetAudioSourceConfigurationOptions;	/* ../../wsdl/onvif.h:70362 */
struct __trt__GetAudioEncoderConfigurationOptions;	/* ../../wsdl/onvif.h:70431 */
struct __trt__GetMetadataConfigurationOptions;	/* ../../wsdl/onvif.h:70499 */
struct __trt__GetAudioOutputConfigurationOptions;	/* ../../wsdl/onvif.h:70567 */
struct __trt__GetAudioDecoderConfigurationOptions;	/* ../../wsdl/onvif.h:70636 */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* ../../wsdl/onvif.h:70705 */
struct __trt__GetStreamUri;	/* ../../wsdl/onvif.h:70778 */
struct __trt__StartMulticastStreaming;	/* ../../wsdl/onvif.h:70852 */
struct __trt__StopMulticastStreaming;	/* ../../wsdl/onvif.h:70919 */
struct __trt__SetSynchronizationPoint;	/* ../../wsdl/onvif.h:71003 */
struct __trt__GetSnapshotUri;	/* ../../wsdl/onvif.h:71080 */
struct __trv__GetServiceCapabilities;	/* ../../wsdl/onvif.h:71166 */
struct __trv__GetReceivers;	/* ../../wsdl/onvif.h:71236 */
struct __trv__GetReceiver;	/* ../../wsdl/onvif.h:71306 */
struct __trv__CreateReceiver;	/* ../../wsdl/onvif.h:71377 */
struct __trv__DeleteReceiver;	/* ../../wsdl/onvif.h:71449 */
struct __trv__ConfigureReceiver;	/* ../../wsdl/onvif.h:71519 */
struct __trv__SetReceiverMode;	/* ../../wsdl/onvif.h:71590 */
struct __trv__GetReceiverState;	/* ../../wsdl/onvif.h:71662 */
struct __tse__GetServiceCapabilities;	/* ../../wsdl/onvif.h:71748 */
struct __tse__GetRecordingSummary;	/* ../../wsdl/onvif.h:71817 */
struct __tse__GetRecordingInformation;	/* ../../wsdl/onvif.h:71887 */
struct __tse__GetMediaAttributes;	/* ../../wsdl/onvif.h:71964 */
struct __tse__FindRecordings;	/* ../../wsdl/onvif.h:72038 */
struct __tse__GetRecordingSearchResults;	/* ../../wsdl/onvif.h:72113 */
struct __tse__FindEvents;	/* ../../wsdl/onvif.h:72186 */
struct __tse__GetEventSearchResults;	/* ../../wsdl/onvif.h:72259 */
struct __tse__FindPTZPosition;	/* ../../wsdl/onvif.h:72332 */
struct __tse__GetPTZPositionSearchResults;	/* ../../wsdl/onvif.h:72405 */
struct __tse__GetSearchState;	/* ../../wsdl/onvif.h:72476 */
struct __tse__EndSearch;	/* ../../wsdl/onvif.h:72553 */
struct __tse__FindMetadata;	/* ../../wsdl/onvif.h:72626 */
struct __tse__GetMetadataSearchResults;	/* ../../wsdl/onvif.h:72698 */

/* wsa.h:94 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (7)
/* wsa:EndpointReferenceType complex type: */
struct wsa__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa__ReferencePropertiesType *ReferenceProperties;	/* optional element of XSD type wsa:ReferencePropertiesType */
	struct wsa__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa:ReferenceParametersType */
	char **PortType;	/* optional element of XSD type xsd:QName */
	struct wsa__ServiceNameType *ServiceName;	/* optional element of XSD type wsa:ServiceNameType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 7; } /* = unique type id SOAP_TYPE_wsa__EndpointReferenceType */
	         wsa__EndpointReferenceType();
	friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:97 */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (8)
/* wsa:ReferencePropertiesType complex type: */
struct wsa__ReferencePropertiesType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_wsa__ReferencePropertiesType */
	         wsa__ReferencePropertiesType();
	friend SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:100 */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (9)
/* wsa:ReferenceParametersType complex type: */
struct wsa__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 9; } /* = unique type id SOAP_TYPE_wsa__ReferenceParametersType */
	         wsa__ReferenceParametersType();
	friend SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:103 */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (10)
/* wsa:ServiceNameType simple type: */
struct wsa__ServiceNameType
{
public:
	char *__item;	/* mixed XML content */
	char *PortName;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 10; } /* = unique type id SOAP_TYPE_wsa__ServiceNameType */
	         wsa__ServiceNameType();
	friend SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:106 */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (11)
/* wsa:Relationship simple type: */
struct wsa__Relationship
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE_wsa__Relationship */
	         wsa__Relationship();
	friend SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:250 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (29)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa__MessageID;	/* optional element of XSD type wsa:MessageID */
	struct wsa__Relationship *wsa__RelatesTo;	/* optional element of XSD type wsa:RelatesTo */
	struct wsa__EndpointReferenceType *wsa__From;	/* optional element of XSD type wsa:From */
	struct wsa__EndpointReferenceType *wsa__ReplyTo;	/* mustUnderstand */
	struct wsa__EndpointReferenceType *wsa__FaultTo;	/* mustUnderstand */
	char *wsa__To;	/* mustUnderstand */
	char *wsa__Action;	/* mustUnderstand */
	struct wsdd__AppSequenceType *wsdd__AppSequence;	/* optional element of XSD type wsdd:AppSequenceType */
	char *wsa5__MessageID;	/* optional element of XSD type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of XSD type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of XSD type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct chan__ChannelInstanceType *chan__ChannelInstance;	/* optional element of XSD type chan:ChannelInstanceType */
public:
	int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:267 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (36)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 36; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (38)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:273 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (42)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsdd10.h:57 */
#ifndef SOAP_TYPE_wsdd__HelloType
#define SOAP_TYPE_wsdd__HelloType (43)
/* wsdd:HelloType complex type: */
struct wsdd__HelloType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_wsdd__HelloType */
	         wsdd__HelloType();
	friend SOAP_FMAC1 wsdd__HelloType * SOAP_FMAC2 soap_instantiate_wsdd__HelloType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:60 */
#ifndef SOAP_TYPE_wsdd__ByeType
#define SOAP_TYPE_wsdd__ByeType (44)
/* wsdd:ByeType complex type: */
struct wsdd__ByeType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int *MetadataVersion;	/* optional element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_wsdd__ByeType */
	         wsdd__ByeType();
	friend SOAP_FMAC1 wsdd__ByeType * SOAP_FMAC2 soap_instantiate_wsdd__ByeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:63 */
#ifndef SOAP_TYPE_wsdd__ProbeType
#define SOAP_TYPE_wsdd__ProbeType (45)
/* wsdd:ProbeType complex type: */
struct wsdd__ProbeType
{
public:
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_wsdd__ProbeType */
	         wsdd__ProbeType();
	friend SOAP_FMAC1 wsdd__ProbeType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:66 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchesType
#define SOAP_TYPE_wsdd__ProbeMatchesType (46)
/* wsdd:ProbeMatchesType complex type: */
struct wsdd__ProbeMatchesType
{
public:
	int __sizeProbeMatch;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ProbeMatch> of XSD type wsdd:ProbeMatchType */
	struct wsdd__ProbeMatchType *ProbeMatch;
public:
	int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchesType */
	         wsdd__ProbeMatchesType();
	friend SOAP_FMAC1 wsdd__ProbeMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:69 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchType
#define SOAP_TYPE_wsdd__ProbeMatchType (47)
/* wsdd:ProbeMatchType complex type: */
struct wsdd__ProbeMatchType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_wsdd__ProbeMatchType */
	         wsdd__ProbeMatchType();
	friend SOAP_FMAC1 wsdd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:72 */
#ifndef SOAP_TYPE_wsdd__ResolveType
#define SOAP_TYPE_wsdd__ResolveType (48)
/* wsdd:ResolveType complex type: */
struct wsdd__ResolveType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa:EndpointReference */
public:
	int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_wsdd__ResolveType */
	         wsdd__ResolveType();
	friend SOAP_FMAC1 wsdd__ResolveType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:75 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchesType
#define SOAP_TYPE_wsdd__ResolveMatchesType (49)
/* wsdd:ResolveMatchesType complex type: */
struct wsdd__ResolveMatchesType
{
public:
	struct wsdd__ResolveMatchType *ResolveMatch;	/* optional element of XSD type wsdd:ResolveMatchType */
public:
	int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchesType */
	         wsdd__ResolveMatchesType();
	friend SOAP_FMAC1 wsdd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:78 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchType
#define SOAP_TYPE_wsdd__ResolveMatchType (50)
/* wsdd:ResolveMatchType complex type: */
struct wsdd__ResolveMatchType
{
public:
	struct wsa__EndpointReferenceType wsa__EndpointReference;	/* required element of XSD type wsa:EndpointReference */
	char *Types;	/* optional element of XSD type xsd:QName */
	struct wsdd__ScopesType *Scopes;	/* optional element of XSD type wsdd:ScopesType */
	char *XAddrs;	/* optional element of XSD type wsdd:UriListType */
	unsigned int MetadataVersion;	/* required element of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_wsdd__ResolveMatchType */
	         wsdd__ResolveMatchType();
	friend SOAP_FMAC1 wsdd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:84 */
#ifndef SOAP_TYPE_wsdd__SecurityType
#define SOAP_TYPE_wsdd__SecurityType (52)
/* wsdd:SecurityType complex type: */
struct wsdd__SecurityType
{
public:
	struct wsdd__SigType *Sig;	/* optional element of XSD type wsdd:SigType */
public:
	int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_wsdd__SecurityType */
	         wsdd__SecurityType();
	friend SOAP_FMAC1 wsdd__SecurityType * SOAP_FMAC2 soap_instantiate_wsdd__SecurityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:87 */
#ifndef SOAP_TYPE_wsdd__SigType
#define SOAP_TYPE_wsdd__SigType (53)
/* wsdd:SigType complex type: */
struct wsdd__SigType
{
public:
	char *Scheme;	/* required attribute of XSD type xsd:string */
	char *KeyId;	/* optional attribute of XSD type xsd:string */
	char *Refs;	/* required attribute of XSD type xsd:string */
	char *Sig;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_wsdd__SigType */
	         wsdd__SigType();
	friend SOAP_FMAC1 wsdd__SigType * SOAP_FMAC2 soap_instantiate_wsdd__SigType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:81 */
#ifndef SOAP_TYPE_wsdd__ScopesType
#define SOAP_TYPE_wsdd__ScopesType (51)
/* wsdd:ScopesType simple type: */
struct wsdd__ScopesType
{
public:
	char *__item;	/* mixed XML content */
	char *MatchBy;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_wsdd__ScopesType */
	         wsdd__ScopesType();
	friend SOAP_FMAC1 wsdd__ScopesType * SOAP_FMAC2 soap_instantiate_wsdd__ScopesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd10.h:90 */
#ifndef SOAP_TYPE_wsdd__AppSequenceType
#define SOAP_TYPE_wsdd__AppSequenceType (54)
/* wsdd:AppSequenceType complex type: */
struct wsdd__AppSequenceType
{
public:
	unsigned int InstanceId;	/* required attribute of XSD type xsd:unsignedInt */
	char *SequenceId;	/* optional attribute of XSD type xsd:string */
	unsigned int MessageNumber;	/* required attribute of XSD type xsd:unsignedInt */
public:
	int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_wsdd__AppSequenceType */
	         wsdd__AppSequenceType();
	friend SOAP_FMAC1 wsdd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsdd__AppSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:67 */
#ifndef SOAP_TYPE___wsdd__Hello
#define SOAP_TYPE___wsdd__Hello (67)
/* Operation wrapper: */
struct __wsdd__Hello
{
public:
	struct wsdd__HelloType *wsdd__Hello;	/* optional element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE___wsdd__Hello */
	         __wsdd__Hello();
	friend SOAP_FMAC1 __wsdd__Hello * SOAP_FMAC2 soap_instantiate___wsdd__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:76 */
#ifndef SOAP_TYPE___wsdd__Bye
#define SOAP_TYPE___wsdd__Bye (70)
/* Operation wrapper: */
struct __wsdd__Bye
{
public:
	struct wsdd__ByeType *wsdd__Bye;	/* optional element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 70; } /* = unique type id SOAP_TYPE___wsdd__Bye */
	         __wsdd__Bye();
	friend SOAP_FMAC1 __wsdd__Bye * SOAP_FMAC2 soap_instantiate___wsdd__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:85 */
#ifndef SOAP_TYPE___wsdd__Probe
#define SOAP_TYPE___wsdd__Probe (73)
/* Operation wrapper: */
struct __wsdd__Probe
{
public:
	struct wsdd__ProbeType *wsdd__Probe;	/* optional element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 73; } /* = unique type id SOAP_TYPE___wsdd__Probe */
	         __wsdd__Probe();
	friend SOAP_FMAC1 __wsdd__Probe * SOAP_FMAC2 soap_instantiate___wsdd__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:94 */
#ifndef SOAP_TYPE___wsdd__ProbeMatches
#define SOAP_TYPE___wsdd__ProbeMatches (76)
/* Operation wrapper: */
struct __wsdd__ProbeMatches
{
public:
	struct wsdd__ProbeMatchesType *wsdd__ProbeMatches;	/* optional element of XSD type wsdd:ProbeMatchesType */
public:
	int soap_type() const { return 76; } /* = unique type id SOAP_TYPE___wsdd__ProbeMatches */
	         __wsdd__ProbeMatches();
	friend SOAP_FMAC1 __wsdd__ProbeMatches * SOAP_FMAC2 soap_instantiate___wsdd__ProbeMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:103 */
#ifndef SOAP_TYPE___wsdd__Resolve
#define SOAP_TYPE___wsdd__Resolve (79)
/* Operation wrapper: */
struct __wsdd__Resolve
{
public:
	struct wsdd__ResolveType *wsdd__Resolve;	/* optional element of XSD type wsdd:ResolveType */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE___wsdd__Resolve */
	         __wsdd__Resolve();
	friend SOAP_FMAC1 __wsdd__Resolve * SOAP_FMAC2 soap_instantiate___wsdd__Resolve(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:112 */
#ifndef SOAP_TYPE___wsdd__ResolveMatches
#define SOAP_TYPE___wsdd__ResolveMatches (82)
/* Operation wrapper: */
struct __wsdd__ResolveMatches
{
public:
	struct wsdd__ResolveMatchesType *wsdd__ResolveMatches;	/* optional element of XSD type wsdd:ResolveMatchesType */
public:
	int soap_type() const { return 82; } /* = unique type id SOAP_TYPE___wsdd__ResolveMatches */
	         __wsdd__ResolveMatches();
	friend SOAP_FMAC1 __wsdd__ResolveMatches * SOAP_FMAC2 soap_instantiate___wsdd__ResolveMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xop.h:58 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (83)
/* base64Binary schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE__xop__Include */
	         _xop__Include();
	friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:63 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (86)
/* wsa5:EndpointReferenceType complex type: */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of XSD type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
	         wsa5__EndpointReferenceType();
	friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:66 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (87)
/* wsa5:ReferenceParametersType complex type: */
struct wsa5__ReferenceParametersType
{
public:
	int *chan__ChannelInstance;	/* optional element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
	         wsa5__ReferenceParametersType();
	friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:69 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (88)
/* wsa5:MetadataType complex type: */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 88; } /* = unique type id SOAP_TYPE_wsa5__MetadataType */
	         wsa5__MetadataType();
	friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:84 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (90)
/* wsa5:ProblemActionType complex type: */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of XSD type xsd:string */
	char *SoapAction;	/* optional element of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 90; } /* = unique type id SOAP_TYPE_wsa5__ProblemActionType */
	         wsa5__ProblemActionType();
	friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:72 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (89)
/* wsa5:RelatesToType simple type: */
struct wsa5__RelatesToType
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_wsa5__RelatesToType */
	         wsa5__RelatesToType();
	friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:258 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (114)
/* chan:ChannelInstanceType simple type: */
struct chan__ChannelInstanceType
{
public:
	int __item;	/* mixed XML content */
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/* optional attribute of XSD type wsa5:IsReferenceParameter */
public:
	int soap_type() const { return 114; } /* = unique type id SOAP_TYPE_chan__ChannelInstanceType */
	         chan__ChannelInstanceType();
	friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:288 */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_yz
#define SOAP_TYPE_SOAP_ENV__Fault_yz (121)
/* SOAP-ENV:Fault-yz complex type: */
struct SOAP_ENV__Fault_yz
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 121; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault_yz */
	         SOAP_ENV__Fault_yz();
	friend SOAP_FMAC1 SOAP_ENV__Fault_yz * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault_yz(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:271 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (122)
/* Type xsd__anyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anyType simple type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyType (122)
	virtual int soap_type(void) const { return 122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
	virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
	friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:274 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (124)
/* SOAP-ENV:Envelope complex type: */
struct SOAP_ENV__Envelope
{
public:
	struct SOAP_ENV__Header *SOAP_ENV__Header;	/* optional element of XSD type SOAP-ENV:Header */
	char *SOAP_ENV__Body;	/* optional element of XSD type xsd:anyType */
public:
	int soap_type() const { return 124; } /* = unique type id SOAP_TYPE_SOAP_ENV__Envelope */
	         SOAP_ENV__Envelope();
	friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:277 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (126)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (126)
	virtual int soap_type(void) const { return 126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:288 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (131)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary (131)
	virtual int soap_type(void) const { return 131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
	virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
	friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:296 */
#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (133)
/* Type xsd__NCName_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:NCName simple type: */
class SOAP_CMAC xsd__NCName_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__NCName_ (133)
	virtual int soap_type(void) const { return 133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__NCName_, default initialized and not managed by a soap context
	virtual xsd__NCName_ *soap_alloc(void) const { return SOAP_NEW(xsd__NCName_); }
	         xsd__NCName_() { xsd__NCName_::soap_default(NULL); }
	virtual ~xsd__NCName_() { }
	friend SOAP_FMAC1 xsd__NCName_ * SOAP_FMAC2 soap_instantiate_xsd__NCName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:303 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (134)
/* Type xsd__QName is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:QName simple type: */
class SOAP_CMAC xsd__QName : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__QName (134)
	virtual int soap_type(void) const { return 134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__QName, default initialized and not managed by a soap context
	virtual xsd__QName *soap_alloc(void) const { return SOAP_NEW(xsd__QName); }
	         xsd__QName() { xsd__QName::soap_default(NULL); }
	virtual ~xsd__QName() { }
	friend SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:313 */
#ifndef SOAP_TYPE_xsd__anySimpleType_
#define SOAP_TYPE_xsd__anySimpleType_ (136)
/* Type xsd__anySimpleType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anySimpleType simple type: */
class SOAP_CMAC xsd__anySimpleType_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anySimpleType_ (136)
	virtual int soap_type(void) const { return 136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anySimpleType_, default initialized and not managed by a soap context
	virtual xsd__anySimpleType_ *soap_alloc(void) const { return SOAP_NEW(xsd__anySimpleType_); }
	         xsd__anySimpleType_() { xsd__anySimpleType_::soap_default(NULL); }
	virtual ~xsd__anySimpleType_() { }
	friend SOAP_FMAC1 xsd__anySimpleType_ * SOAP_FMAC2 soap_instantiate_xsd__anySimpleType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:323 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (138)
/* Type xsd__anyURI_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:anyURI simple type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__anyURI_ (138)
	virtual int soap_type(void) const { return 138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
	virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
	         xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
	virtual ~xsd__anyURI_() { }
	friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:330 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (139)
/* Type xsd__base64Binary_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:base64Binary simple type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary_ (139)
	virtual int soap_type(void) const { return 139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
	virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
	friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:337 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (140)
/* Type xsd__boolean is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:boolean simple type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__boolean (140)
	virtual int soap_type(void) const { return 140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
	virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
	friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:344 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (142)
/* Type xsd__dateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:dateTime simple type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__dateTime (142)
	virtual int soap_type(void) const { return 142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
	virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
	friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:351 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (144)
/* Type xsd__duration_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:duration simple type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
	LONG64 __item;	/* external (custom serializer) */	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__duration_ (144)
	virtual int soap_type(void) const { return 144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
	virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
	         xsd__duration_() { xsd__duration_::soap_default(NULL); }
	virtual ~xsd__duration_() { }
	friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:358 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (145)
/* Type xsd__float is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:float simple type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__float (145)
	virtual int soap_type(void) const { return 145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__float, default initialized and not managed by a soap context
	virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
	friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:365 */
#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (147)
/* Type xsd__hexBinary_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:hexBinary simple type: */
class SOAP_CMAC xsd__hexBinary_ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__hexBinary_ (147)
	virtual int soap_type(void) const { return 147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__hexBinary_, default initialized and not managed by a soap context
	virtual xsd__hexBinary_ *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary_); }
	         xsd__hexBinary_() { xsd__hexBinary_::soap_default(NULL); }
	virtual ~xsd__hexBinary_() { }
	friend SOAP_FMAC1 xsd__hexBinary_ * SOAP_FMAC2 soap_instantiate_xsd__hexBinary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:372 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (148)
/* Type xsd__int is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:int simple type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__int (148)
	virtual int soap_type(void) const { return 148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__int, default initialized and not managed by a soap context
	virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
	friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:382 */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (150)
/* Type xsd__integer_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:integer simple type: */
class SOAP_CMAC xsd__integer_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__integer_ (150)
	virtual int soap_type(void) const { return 150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__integer_, default initialized and not managed by a soap context
	virtual xsd__integer_ *soap_alloc(void) const { return SOAP_NEW(xsd__integer_); }
	         xsd__integer_() { xsd__integer_::soap_default(NULL); }
	virtual ~xsd__integer_() { }
	friend SOAP_FMAC1 xsd__integer_ * SOAP_FMAC2 soap_instantiate_xsd__integer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:392 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (152)
/* Type xsd__nonNegativeInteger_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:nonNegativeInteger simple type: */
class SOAP_CMAC xsd__nonNegativeInteger_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__nonNegativeInteger_ (152)
	virtual int soap_type(void) const { return 152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__nonNegativeInteger_, default initialized and not managed by a soap context
	virtual xsd__nonNegativeInteger_ *soap_alloc(void) const { return SOAP_NEW(xsd__nonNegativeInteger_); }
	         xsd__nonNegativeInteger_() { xsd__nonNegativeInteger_::soap_default(NULL); }
	virtual ~xsd__nonNegativeInteger_() { }
	friend SOAP_FMAC1 xsd__nonNegativeInteger_ * SOAP_FMAC2 soap_instantiate_xsd__nonNegativeInteger_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:402 */
#ifndef SOAP_TYPE_xsd__positiveInteger_
#define SOAP_TYPE_xsd__positiveInteger_ (154)
/* Type xsd__positiveInteger_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:positiveInteger simple type: */
class SOAP_CMAC xsd__positiveInteger_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__positiveInteger_ (154)
	virtual int soap_type(void) const { return 154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__positiveInteger_, default initialized and not managed by a soap context
	virtual xsd__positiveInteger_ *soap_alloc(void) const { return SOAP_NEW(xsd__positiveInteger_); }
	         xsd__positiveInteger_() { xsd__positiveInteger_::soap_default(NULL); }
	virtual ~xsd__positiveInteger_() { }
	friend SOAP_FMAC1 xsd__positiveInteger_ * SOAP_FMAC2 soap_instantiate_xsd__positiveInteger_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:409 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (155)
/* Type xsd__string is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:string simple type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__string (155)
	virtual int soap_type(void) const { return 155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__string, default initialized and not managed by a soap context
	virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
	friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:419 */
#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (157)
/* Type xsd__token_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:token simple type: */
class SOAP_CMAC xsd__token_ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__token_ (157)
	virtual int soap_type(void) const { return 157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__token_, default initialized and not managed by a soap context
	virtual xsd__token_ *soap_alloc(void) const { return SOAP_NEW(xsd__token_); }
	         xsd__token_() { xsd__token_::soap_default(NULL); }
	virtual ~xsd__token_() { }
	friend SOAP_FMAC1 xsd__token_ * SOAP_FMAC2 soap_instantiate_xsd__token_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:426 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (158)
/* Type xsd__unsignedInt is a recursive data type (in)directly referencing itself through its (base) class members */
/* xsd:unsignedInt simple type: */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType
{
public:
	unsigned int __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__unsignedInt (158)
	virtual int soap_type(void) const { return 158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
	virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
	         xsd__unsignedInt() { xsd__unsignedInt::soap_default(NULL); }
	virtual ~xsd__unsignedInt() { }
	friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4414 */
#ifndef SOAP_TYPE_tmd__SerialPortType_
#define SOAP_TYPE_tmd__SerialPortType_ (1410)
/* Type tmd__SerialPortType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortType simple type: */
class SOAP_CMAC tmd__SerialPortType_ : public xsd__anyType
{
public:
	enum tmd__SerialPortType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortType_ (1410)
	virtual int soap_type(void) const { return 1410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortType_, default initialized and not managed by a soap context
	virtual tmd__SerialPortType_ *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortType_); }
	         tmd__SerialPortType_() { tmd__SerialPortType_::soap_default(NULL); }
	virtual ~tmd__SerialPortType_() { }
	friend SOAP_FMAC1 tmd__SerialPortType_ * SOAP_FMAC2 soap_instantiate_tmd__SerialPortType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4437 */
#ifndef SOAP_TYPE_tmd__ParityBit_
#define SOAP_TYPE_tmd__ParityBit_ (1412)
/* Type tmd__ParityBit_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:ParityBit simple type: */
class SOAP_CMAC tmd__ParityBit_ : public xsd__anyType
{
public:
	enum tmd__ParityBit __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__ParityBit_ (1412)
	virtual int soap_type(void) const { return 1412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__ParityBit_, default initialized and not managed by a soap context
	virtual tmd__ParityBit_ *soap_alloc(void) const { return SOAP_NEW(tmd__ParityBit_); }
	         tmd__ParityBit_() { tmd__ParityBit_::soap_default(NULL); }
	virtual ~tmd__ParityBit_() { }
	friend SOAP_FMAC1 tmd__ParityBit_ * SOAP_FMAC2 soap_instantiate_tmd__ParityBit_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4470 */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (1414)
/* Type tt__ReferenceToken__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReferenceToken simple type: */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReferenceToken__ (1414)
	virtual int soap_type(void) const { return 1414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReferenceToken__, default initialized and not managed by a soap context
	virtual tt__ReferenceToken__ *soap_alloc(void) const { return SOAP_NEW(tt__ReferenceToken__); }
	         tt__ReferenceToken__() { tt__ReferenceToken__::soap_default(NULL); }
	virtual ~tt__ReferenceToken__() { }
	friend SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 soap_instantiate_tt__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4485 */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (1416)
/* Type tt__Name__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Name simple type: */
class SOAP_CMAC tt__Name__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Name__ (1416)
	virtual int soap_type(void) const { return 1416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Name__, default initialized and not managed by a soap context
	virtual tt__Name__ *soap_alloc(void) const { return SOAP_NEW(tt__Name__); }
	         tt__Name__() { tt__Name__::soap_default(NULL); }
	virtual ~tt__Name__() { }
	friend SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 soap_instantiate_tt__Name__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4502 */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (1418)
/* Type tt__RotateMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateMode simple type: */
class SOAP_CMAC tt__RotateMode_ : public xsd__anyType
{
public:
	enum tt__RotateMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateMode_ (1418)
	virtual int soap_type(void) const { return 1418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateMode_, default initialized and not managed by a soap context
	virtual tt__RotateMode_ *soap_alloc(void) const { return SOAP_NEW(tt__RotateMode_); }
	         tt__RotateMode_() { tt__RotateMode_::soap_default(NULL); }
	virtual ~tt__RotateMode_() { }
	friend SOAP_FMAC1 tt__RotateMode_ * SOAP_FMAC2 soap_instantiate_tt__RotateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4519 */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (1420)
/* Type tt__VideoEncoding_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoding simple type: */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType
{
public:
	enum tt__VideoEncoding __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoding_ (1420)
	virtual int soap_type(void) const { return 1420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoding_, default initialized and not managed by a soap context
	virtual tt__VideoEncoding_ *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoding_); }
	         tt__VideoEncoding_() { tt__VideoEncoding_::soap_default(NULL); }
	virtual ~tt__VideoEncoding_() { }
	friend SOAP_FMAC1 tt__VideoEncoding_ * SOAP_FMAC2 soap_instantiate_tt__VideoEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4535 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (1422)
/* Type tt__Mpeg4Profile_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Profile simple type: */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType
{
public:
	enum tt__Mpeg4Profile __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Profile_ (1422)
	virtual int soap_type(void) const { return 1422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Profile_, default initialized and not managed by a soap context
	virtual tt__Mpeg4Profile_ *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Profile_); }
	         tt__Mpeg4Profile_() { tt__Mpeg4Profile_::soap_default(NULL); }
	virtual ~tt__Mpeg4Profile_() { }
	friend SOAP_FMAC1 tt__Mpeg4Profile_ * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4553 */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (1424)
/* Type tt__H264Profile_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Profile simple type: */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType
{
public:
	enum tt__H264Profile __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Profile_ (1424)
	virtual int soap_type(void) const { return 1424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Profile_, default initialized and not managed by a soap context
	virtual tt__H264Profile_ *soap_alloc(void) const { return SOAP_NEW(tt__H264Profile_); }
	         tt__H264Profile_() { tt__H264Profile_::soap_default(NULL); }
	virtual ~tt__H264Profile_() { }
	friend SOAP_FMAC1 tt__H264Profile_ * SOAP_FMAC2 soap_instantiate_tt__H264Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4570 */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (1426)
/* Type tt__AudioEncoding_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoding simple type: */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType
{
public:
	enum tt__AudioEncoding __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoding_ (1426)
	virtual int soap_type(void) const { return 1426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoding_, default initialized and not managed by a soap context
	virtual tt__AudioEncoding_ *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoding_); }
	         tt__AudioEncoding_() { tt__AudioEncoding_::soap_default(NULL); }
	virtual ~tt__AudioEncoding_() { }
	friend SOAP_FMAC1 tt__AudioEncoding_ * SOAP_FMAC2 soap_instantiate_tt__AudioEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4586 */
#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (1428)
/* Type tt__StreamType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StreamType simple type: */
class SOAP_CMAC tt__StreamType_ : public xsd__anyType
{
public:
	enum tt__StreamType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamType_ (1428)
	virtual int soap_type(void) const { return 1428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamType_, default initialized and not managed by a soap context
	virtual tt__StreamType_ *soap_alloc(void) const { return SOAP_NEW(tt__StreamType_); }
	         tt__StreamType_() { tt__StreamType_::soap_default(NULL); }
	virtual ~tt__StreamType_() { }
	friend SOAP_FMAC1 tt__StreamType_ * SOAP_FMAC2 soap_instantiate_tt__StreamType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4604 */
#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (1430)
/* Type tt__TransportProtocol_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TransportProtocol simple type: */
class SOAP_CMAC tt__TransportProtocol_ : public xsd__anyType
{
public:
	enum tt__TransportProtocol __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransportProtocol_ (1430)
	virtual int soap_type(void) const { return 1430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransportProtocol_, default initialized and not managed by a soap context
	virtual tt__TransportProtocol_ *soap_alloc(void) const { return SOAP_NEW(tt__TransportProtocol_); }
	         tt__TransportProtocol_() { tt__TransportProtocol_::soap_default(NULL); }
	virtual ~tt__TransportProtocol_() { }
	friend SOAP_FMAC1 tt__TransportProtocol_ * SOAP_FMAC2 soap_instantiate_tt__TransportProtocol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4620 */
#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (1432)
/* Type tt__ScopeDefinition_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ScopeDefinition simple type: */
class SOAP_CMAC tt__ScopeDefinition_ : public xsd__anyType
{
public:
	enum tt__ScopeDefinition __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ScopeDefinition_ (1432)
	virtual int soap_type(void) const { return 1432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ScopeDefinition_, default initialized and not managed by a soap context
	virtual tt__ScopeDefinition_ *soap_alloc(void) const { return SOAP_NEW(tt__ScopeDefinition_); }
	         tt__ScopeDefinition_() { tt__ScopeDefinition_::soap_default(NULL); }
	virtual ~tt__ScopeDefinition_() { }
	friend SOAP_FMAC1 tt__ScopeDefinition_ * SOAP_FMAC2 soap_instantiate_tt__ScopeDefinition_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4636 */
#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (1434)
/* Type tt__DiscoveryMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DiscoveryMode simple type: */
class SOAP_CMAC tt__DiscoveryMode_ : public xsd__anyType
{
public:
	enum tt__DiscoveryMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DiscoveryMode_ (1434)
	virtual int soap_type(void) const { return 1434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DiscoveryMode_, default initialized and not managed by a soap context
	virtual tt__DiscoveryMode_ *soap_alloc(void) const { return SOAP_NEW(tt__DiscoveryMode_); }
	         tt__DiscoveryMode_() { tt__DiscoveryMode_::soap_default(NULL); }
	virtual ~tt__DiscoveryMode_() { }
	friend SOAP_FMAC1 tt__DiscoveryMode_ * SOAP_FMAC2 soap_instantiate_tt__DiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4648 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (1436)
/* Type tt__NetworkInterfaceConfigPriority__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceConfigPriority simple type: */
class SOAP_CMAC tt__NetworkInterfaceConfigPriority__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (1436)
	virtual int soap_type(void) const { return 1436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConfigPriority__, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConfigPriority__ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConfigPriority__); }
	         tt__NetworkInterfaceConfigPriority__() { tt__NetworkInterfaceConfigPriority__::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConfigPriority__() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceConfigPriority__ * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConfigPriority__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4664 */
#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (1438)
/* Type tt__Duplex_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Duplex simple type: */
class SOAP_CMAC tt__Duplex_ : public xsd__anyType
{
public:
	enum tt__Duplex __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Duplex_ (1438)
	virtual int soap_type(void) const { return 1438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Duplex_, default initialized and not managed by a soap context
	virtual tt__Duplex_ *soap_alloc(void) const { return SOAP_NEW(tt__Duplex_); }
	         tt__Duplex_() { tt__Duplex_::soap_default(NULL); }
	virtual ~tt__Duplex_() { }
	friend SOAP_FMAC1 tt__Duplex_ * SOAP_FMAC2 soap_instantiate_tt__Duplex_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4678 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (1440)
/* Type tt__IANA_IfTypes__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IANA-IfTypes simple type: */
class SOAP_CMAC tt__IANA_IfTypes__ : public xsd__anyType
{
public:
	int __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IANA_IfTypes__ (1440)
	virtual int soap_type(void) const { return 1440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IANA_IfTypes__, default initialized and not managed by a soap context
	virtual tt__IANA_IfTypes__ *soap_alloc(void) const { return SOAP_NEW(tt__IANA_IfTypes__); }
	         tt__IANA_IfTypes__() { tt__IANA_IfTypes__::soap_default(NULL); }
	virtual ~tt__IANA_IfTypes__() { }
	friend SOAP_FMAC1 tt__IANA_IfTypes__ * SOAP_FMAC2 soap_instantiate_tt__IANA_IfTypes__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4696 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (1442)
/* Type tt__IPv6DHCPConfiguration_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6DHCPConfiguration simple type: */
class SOAP_CMAC tt__IPv6DHCPConfiguration_ : public xsd__anyType
{
public:
	enum tt__IPv6DHCPConfiguration __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6DHCPConfiguration_ (1442)
	virtual int soap_type(void) const { return 1442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6DHCPConfiguration_, default initialized and not managed by a soap context
	virtual tt__IPv6DHCPConfiguration_ *soap_alloc(void) const { return SOAP_NEW(tt__IPv6DHCPConfiguration_); }
	         tt__IPv6DHCPConfiguration_() { tt__IPv6DHCPConfiguration_::soap_default(NULL); }
	virtual ~tt__IPv6DHCPConfiguration_() { }
	friend SOAP_FMAC1 tt__IPv6DHCPConfiguration_ * SOAP_FMAC2 soap_instantiate_tt__IPv6DHCPConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4713 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (1444)
/* Type tt__NetworkProtocolType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocolType simple type: */
class SOAP_CMAC tt__NetworkProtocolType_ : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolType_ (1444)
	virtual int soap_type(void) const { return 1444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolType_, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolType_ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolType_); }
	         tt__NetworkProtocolType_() { tt__NetworkProtocolType_::soap_default(NULL); }
	virtual ~tt__NetworkProtocolType_() { }
	friend SOAP_FMAC1 tt__NetworkProtocolType_ * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4730 */
#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (1446)
/* Type tt__NetworkHostType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHostType simple type: */
class SOAP_CMAC tt__NetworkHostType_ : public xsd__anyType
{
public:
	enum tt__NetworkHostType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostType_ (1446)
	virtual int soap_type(void) const { return 1446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostType_, default initialized and not managed by a soap context
	virtual tt__NetworkHostType_ *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostType_); }
	         tt__NetworkHostType_() { tt__NetworkHostType_::soap_default(NULL); }
	virtual ~tt__NetworkHostType_() { }
	friend SOAP_FMAC1 tt__NetworkHostType_ * SOAP_FMAC2 soap_instantiate_tt__NetworkHostType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4741 */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (1448)
/* Type tt__IPv4Address__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4Address simple type: */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Address__ (1448)
	virtual int soap_type(void) const { return 1448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Address__, default initialized and not managed by a soap context
	virtual tt__IPv4Address__ *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Address__); }
	         tt__IPv4Address__() { tt__IPv4Address__::soap_default(NULL); }
	virtual ~tt__IPv4Address__() { }
	friend SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv4Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4752 */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (1450)
/* Type tt__IPv6Address__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6Address simple type: */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Address__ (1450)
	virtual int soap_type(void) const { return 1450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Address__, default initialized and not managed by a soap context
	virtual tt__IPv6Address__ *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Address__); }
	         tt__IPv6Address__() { tt__IPv6Address__::soap_default(NULL); }
	virtual ~tt__IPv6Address__() { }
	friend SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv6Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4763 */
#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (1452)
/* Type tt__HwAddress__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HwAddress simple type: */
class SOAP_CMAC tt__HwAddress__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HwAddress__ (1452)
	virtual int soap_type(void) const { return 1452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HwAddress__, default initialized and not managed by a soap context
	virtual tt__HwAddress__ *soap_alloc(void) const { return SOAP_NEW(tt__HwAddress__); }
	         tt__HwAddress__() { tt__HwAddress__::soap_default(NULL); }
	virtual ~tt__HwAddress__() { }
	friend SOAP_FMAC1 tt__HwAddress__ * SOAP_FMAC2 soap_instantiate_tt__HwAddress__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4779 */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (1454)
/* Type tt__IPType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPType simple type: */
class SOAP_CMAC tt__IPType_ : public xsd__anyType
{
public:
	enum tt__IPType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPType_ (1454)
	virtual int soap_type(void) const { return 1454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPType_, default initialized and not managed by a soap context
	virtual tt__IPType_ *soap_alloc(void) const { return SOAP_NEW(tt__IPType_); }
	         tt__IPType_() { tt__IPType_::soap_default(NULL); }
	virtual ~tt__IPType_() { }
	friend SOAP_FMAC1 tt__IPType_ * SOAP_FMAC2 soap_instantiate_tt__IPType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4790 */
#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (1456)
/* Type tt__DNSName__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSName simple type: */
class SOAP_CMAC tt__DNSName__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSName__ (1456)
	virtual int soap_type(void) const { return 1456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSName__, default initialized and not managed by a soap context
	virtual tt__DNSName__ *soap_alloc(void) const { return SOAP_NEW(tt__DNSName__); }
	         tt__DNSName__() { tt__DNSName__::soap_default(NULL); }
	virtual ~tt__DNSName__() { }
	friend SOAP_FMAC1 tt__DNSName__ * SOAP_FMAC2 soap_instantiate_tt__DNSName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4801 */
#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (1458)
/* Type tt__Domain__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Domain simple type: */
class SOAP_CMAC tt__Domain__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Domain__ (1458)
	virtual int soap_type(void) const { return 1458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Domain__, default initialized and not managed by a soap context
	virtual tt__Domain__ *soap_alloc(void) const { return SOAP_NEW(tt__Domain__); }
	         tt__Domain__() { tt__Domain__::soap_default(NULL); }
	virtual ~tt__Domain__() { }
	friend SOAP_FMAC1 tt__Domain__ * SOAP_FMAC2 soap_instantiate_tt__Domain__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4817 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (1460)
/* Type tt__IPAddressFilterType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilterType simple type: */
class SOAP_CMAC tt__IPAddressFilterType_ : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterType_ (1460)
	virtual int soap_type(void) const { return 1460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterType_, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterType_ *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterType_); }
	         tt__IPAddressFilterType_() { tt__IPAddressFilterType_::soap_default(NULL); }
	virtual ~tt__IPAddressFilterType_() { }
	friend SOAP_FMAC1 tt__IPAddressFilterType_ * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4834 */
#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (1462)
/* Type tt__DynamicDNSType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSType simple type: */
class SOAP_CMAC tt__DynamicDNSType_ : public xsd__anyType
{
public:
	enum tt__DynamicDNSType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSType_ (1462)
	virtual int soap_type(void) const { return 1462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSType_, default initialized and not managed by a soap context
	virtual tt__DynamicDNSType_ *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSType_); }
	         tt__DynamicDNSType_() { tt__DynamicDNSType_::soap_default(NULL); }
	virtual ~tt__DynamicDNSType_() { }
	friend SOAP_FMAC1 tt__DynamicDNSType_ * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4846 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType__
#define SOAP_TYPE_tt__Dot11SSIDType__ (1464)
/* Type tt__Dot11SSIDType__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SSIDType simple type: */
class SOAP_CMAC tt__Dot11SSIDType__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SSIDType__ (1464)
	virtual int soap_type(void) const { return 1464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SSIDType__, default initialized and not managed by a soap context
	virtual tt__Dot11SSIDType__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SSIDType__); }
	         tt__Dot11SSIDType__() { tt__Dot11SSIDType__::soap_default(NULL); }
	virtual ~tt__Dot11SSIDType__() { }
	friend SOAP_FMAC1 tt__Dot11SSIDType__ * SOAP_FMAC2 soap_instantiate_tt__Dot11SSIDType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4863 */
#ifndef SOAP_TYPE_tt__Dot11StationMode_
#define SOAP_TYPE_tt__Dot11StationMode_ (1466)
/* Type tt__Dot11StationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11StationMode simple type: */
class SOAP_CMAC tt__Dot11StationMode_ : public xsd__anyType
{
public:
	enum tt__Dot11StationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11StationMode_ (1466)
	virtual int soap_type(void) const { return 1466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11StationMode_, default initialized and not managed by a soap context
	virtual tt__Dot11StationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11StationMode_); }
	         tt__Dot11StationMode_() { tt__Dot11StationMode_::soap_default(NULL); }
	virtual ~tt__Dot11StationMode_() { }
	friend SOAP_FMAC1 tt__Dot11StationMode_ * SOAP_FMAC2 soap_instantiate_tt__Dot11StationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4882 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode_
#define SOAP_TYPE_tt__Dot11SecurityMode_ (1468)
/* Type tt__Dot11SecurityMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityMode simple type: */
class SOAP_CMAC tt__Dot11SecurityMode_ : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityMode_ (1468)
	virtual int soap_type(void) const { return 1468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityMode_, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityMode_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityMode_); }
	         tt__Dot11SecurityMode_() { tt__Dot11SecurityMode_::soap_default(NULL); }
	virtual ~tt__Dot11SecurityMode_() { }
	friend SOAP_FMAC1 tt__Dot11SecurityMode_ * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4900 */
#ifndef SOAP_TYPE_tt__Dot11Cipher_
#define SOAP_TYPE_tt__Dot11Cipher_ (1470)
/* Type tt__Dot11Cipher_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Cipher simple type: */
class SOAP_CMAC tt__Dot11Cipher_ : public xsd__anyType
{
public:
	enum tt__Dot11Cipher __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Cipher_ (1470)
	virtual int soap_type(void) const { return 1470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Cipher_, default initialized and not managed by a soap context
	virtual tt__Dot11Cipher_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Cipher_); }
	         tt__Dot11Cipher_() { tt__Dot11Cipher_::soap_default(NULL); }
	virtual ~tt__Dot11Cipher_() { }
	friend SOAP_FMAC1 tt__Dot11Cipher_ * SOAP_FMAC2 soap_instantiate_tt__Dot11Cipher_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4912 */
#ifndef SOAP_TYPE_tt__Dot11PSK__
#define SOAP_TYPE_tt__Dot11PSK__ (1472)
/* Type tt__Dot11PSK__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSK simple type: */
class SOAP_CMAC tt__Dot11PSK__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSK__ (1472)
	virtual int soap_type(void) const { return 1472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSK__, default initialized and not managed by a soap context
	virtual tt__Dot11PSK__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSK__); }
	         tt__Dot11PSK__() { tt__Dot11PSK__::soap_default(NULL); }
	virtual ~tt__Dot11PSK__() { }
	friend SOAP_FMAC1 tt__Dot11PSK__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSK__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4924 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase__
#define SOAP_TYPE_tt__Dot11PSKPassphrase__ (1474)
/* Type tt__Dot11PSKPassphrase__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKPassphrase simple type: */
class SOAP_CMAC tt__Dot11PSKPassphrase__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKPassphrase__ (1474)
	virtual int soap_type(void) const { return 1474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKPassphrase__, default initialized and not managed by a soap context
	virtual tt__Dot11PSKPassphrase__ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKPassphrase__); }
	         tt__Dot11PSKPassphrase__() { tt__Dot11PSKPassphrase__::soap_default(NULL); }
	virtual ~tt__Dot11PSKPassphrase__() { }
	friend SOAP_FMAC1 tt__Dot11PSKPassphrase__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKPassphrase__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4944 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength_
#define SOAP_TYPE_tt__Dot11SignalStrength_ (1476)
/* Type tt__Dot11SignalStrength_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SignalStrength simple type: */
class SOAP_CMAC tt__Dot11SignalStrength_ : public xsd__anyType
{
public:
	enum tt__Dot11SignalStrength __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SignalStrength_ (1476)
	virtual int soap_type(void) const { return 1476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SignalStrength_, default initialized and not managed by a soap context
	virtual tt__Dot11SignalStrength_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SignalStrength_); }
	         tt__Dot11SignalStrength_() { tt__Dot11SignalStrength_::soap_default(NULL); }
	virtual ~tt__Dot11SignalStrength_() { }
	friend SOAP_FMAC1 tt__Dot11SignalStrength_ * SOAP_FMAC2 soap_instantiate_tt__Dot11SignalStrength_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4962 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (1478)
/* Type tt__Dot11AuthAndMangementSuite_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AuthAndMangementSuite simple type: */
class SOAP_CMAC tt__Dot11AuthAndMangementSuite_ : public xsd__anyType
{
public:
	enum tt__Dot11AuthAndMangementSuite __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (1478)
	virtual int soap_type(void) const { return 1478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AuthAndMangementSuite_, default initialized and not managed by a soap context
	virtual tt__Dot11AuthAndMangementSuite_ *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AuthAndMangementSuite_); }
	         tt__Dot11AuthAndMangementSuite_() { tt__Dot11AuthAndMangementSuite_::soap_default(NULL); }
	virtual ~tt__Dot11AuthAndMangementSuite_() { }
	friend SOAP_FMAC1 tt__Dot11AuthAndMangementSuite_ * SOAP_FMAC2 soap_instantiate_tt__Dot11AuthAndMangementSuite_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4983 */
#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (1480)
/* Type tt__CapabilityCategory_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilityCategory simple type: */
class SOAP_CMAC tt__CapabilityCategory_ : public xsd__anyType
{
public:
	enum tt__CapabilityCategory __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilityCategory_ (1480)
	virtual int soap_type(void) const { return 1480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilityCategory_, default initialized and not managed by a soap context
	virtual tt__CapabilityCategory_ *soap_alloc(void) const { return SOAP_NEW(tt__CapabilityCategory_); }
	         tt__CapabilityCategory_() { tt__CapabilityCategory_::soap_default(NULL); }
	virtual ~tt__CapabilityCategory_() { }
	friend SOAP_FMAC1 tt__CapabilityCategory_ * SOAP_FMAC2 soap_instantiate_tt__CapabilityCategory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5008 */
#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (1482)
/* Type tt__SystemLogType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogType simple type: */
class SOAP_CMAC tt__SystemLogType_ : public xsd__anyType
{
public:
	enum tt__SystemLogType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogType_ (1482)
	virtual int soap_type(void) const { return 1482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogType_, default initialized and not managed by a soap context
	virtual tt__SystemLogType_ *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogType_); }
	         tt__SystemLogType_() { tt__SystemLogType_::soap_default(NULL); }
	virtual ~tt__SystemLogType_() { }
	friend SOAP_FMAC1 tt__SystemLogType_ * SOAP_FMAC2 soap_instantiate_tt__SystemLogType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5033 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (1484)
/* Type tt__FactoryDefaultType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FactoryDefaultType simple type: */
class SOAP_CMAC tt__FactoryDefaultType_ : public xsd__anyType
{
public:
	enum tt__FactoryDefaultType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FactoryDefaultType_ (1484)
	virtual int soap_type(void) const { return 1484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FactoryDefaultType_, default initialized and not managed by a soap context
	virtual tt__FactoryDefaultType_ *soap_alloc(void) const { return SOAP_NEW(tt__FactoryDefaultType_); }
	         tt__FactoryDefaultType_() { tt__FactoryDefaultType_::soap_default(NULL); }
	virtual ~tt__FactoryDefaultType_() { }
	friend SOAP_FMAC1 tt__FactoryDefaultType_ * SOAP_FMAC2 soap_instantiate_tt__FactoryDefaultType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5055 */
#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (1486)
/* Type tt__SetDateTimeType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SetDateTimeType simple type: */
class SOAP_CMAC tt__SetDateTimeType_ : public xsd__anyType
{
public:
	enum tt__SetDateTimeType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SetDateTimeType_ (1486)
	virtual int soap_type(void) const { return 1486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SetDateTimeType_, default initialized and not managed by a soap context
	virtual tt__SetDateTimeType_ *soap_alloc(void) const { return SOAP_NEW(tt__SetDateTimeType_); }
	         tt__SetDateTimeType_() { tt__SetDateTimeType_::soap_default(NULL); }
	virtual ~tt__SetDateTimeType_() { }
	friend SOAP_FMAC1 tt__SetDateTimeType_ * SOAP_FMAC2 soap_instantiate_tt__SetDateTimeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5074 */
#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (1488)
/* Type tt__UserLevel_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:UserLevel simple type: */
class SOAP_CMAC tt__UserLevel_ : public xsd__anyType
{
public:
	enum tt__UserLevel __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserLevel_ (1488)
	virtual int soap_type(void) const { return 1488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserLevel_, default initialized and not managed by a soap context
	virtual tt__UserLevel_ *soap_alloc(void) const { return SOAP_NEW(tt__UserLevel_); }
	         tt__UserLevel_() { tt__UserLevel_::soap_default(NULL); }
	virtual ~tt__UserLevel_() { }
	friend SOAP_FMAC1 tt__UserLevel_ * SOAP_FMAC2 soap_instantiate_tt__UserLevel_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5090 */
#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (1490)
/* Type tt__RelayLogicalState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayLogicalState simple type: */
class SOAP_CMAC tt__RelayLogicalState_ : public xsd__anyType
{
public:
	enum tt__RelayLogicalState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayLogicalState_ (1490)
	virtual int soap_type(void) const { return 1490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayLogicalState_, default initialized and not managed by a soap context
	virtual tt__RelayLogicalState_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayLogicalState_); }
	         tt__RelayLogicalState_() { tt__RelayLogicalState_::soap_default(NULL); }
	virtual ~tt__RelayLogicalState_() { }
	friend SOAP_FMAC1 tt__RelayLogicalState_ * SOAP_FMAC2 soap_instantiate_tt__RelayLogicalState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5106 */
#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (1492)
/* Type tt__RelayIdleState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayIdleState simple type: */
class SOAP_CMAC tt__RelayIdleState_ : public xsd__anyType
{
public:
	enum tt__RelayIdleState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayIdleState_ (1492)
	virtual int soap_type(void) const { return 1492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayIdleState_, default initialized and not managed by a soap context
	virtual tt__RelayIdleState_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayIdleState_); }
	         tt__RelayIdleState_() { tt__RelayIdleState_::soap_default(NULL); }
	virtual ~tt__RelayIdleState_() { }
	friend SOAP_FMAC1 tt__RelayIdleState_ * SOAP_FMAC2 soap_instantiate_tt__RelayIdleState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5122 */
#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (1494)
/* Type tt__RelayMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayMode simple type: */
class SOAP_CMAC tt__RelayMode_ : public xsd__anyType
{
public:
	enum tt__RelayMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayMode_ (1494)
	virtual int soap_type(void) const { return 1494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayMode_, default initialized and not managed by a soap context
	virtual tt__RelayMode_ *soap_alloc(void) const { return SOAP_NEW(tt__RelayMode_); }
	         tt__RelayMode_() { tt__RelayMode_::soap_default(NULL); }
	virtual ~tt__RelayMode_() { }
	friend SOAP_FMAC1 tt__RelayMode_ * SOAP_FMAC2 soap_instantiate_tt__RelayMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5139 */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (1496)
/* Type tt__EFlipMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipMode simple type: */
class SOAP_CMAC tt__EFlipMode_ : public xsd__anyType
{
public:
	enum tt__EFlipMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipMode_ (1496)
	virtual int soap_type(void) const { return 1496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipMode_, default initialized and not managed by a soap context
	virtual tt__EFlipMode_ *soap_alloc(void) const { return SOAP_NEW(tt__EFlipMode_); }
	         tt__EFlipMode_() { tt__EFlipMode_::soap_default(NULL); }
	virtual ~tt__EFlipMode_() { }
	friend SOAP_FMAC1 tt__EFlipMode_ * SOAP_FMAC2 soap_instantiate_tt__EFlipMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5157 */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (1498)
/* Type tt__ReverseMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseMode simple type: */
class SOAP_CMAC tt__ReverseMode_ : public xsd__anyType
{
public:
	enum tt__ReverseMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseMode_ (1498)
	virtual int soap_type(void) const { return 1498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseMode_, default initialized and not managed by a soap context
	virtual tt__ReverseMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ReverseMode_); }
	         tt__ReverseMode_() { tt__ReverseMode_::soap_default(NULL); }
	virtual ~tt__ReverseMode_() { }
	friend SOAP_FMAC1 tt__ReverseMode_ * SOAP_FMAC2 soap_instantiate_tt__ReverseMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5169 */
#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (1500)
/* Type tt__AuxiliaryData__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AuxiliaryData simple type: */
class SOAP_CMAC tt__AuxiliaryData__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AuxiliaryData__ (1500)
	virtual int soap_type(void) const { return 1500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AuxiliaryData__, default initialized and not managed by a soap context
	virtual tt__AuxiliaryData__ *soap_alloc(void) const { return SOAP_NEW(tt__AuxiliaryData__); }
	         tt__AuxiliaryData__() { tt__AuxiliaryData__::soap_default(NULL); }
	virtual ~tt__AuxiliaryData__() { }
	friend SOAP_FMAC1 tt__AuxiliaryData__ * SOAP_FMAC2 soap_instantiate_tt__AuxiliaryData__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5186 */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (1502)
/* Type tt__MoveStatus_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveStatus simple type: */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType
{
public:
	enum tt__MoveStatus __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveStatus_ (1502)
	virtual int soap_type(void) const { return 1502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveStatus_, default initialized and not managed by a soap context
	virtual tt__MoveStatus_ *soap_alloc(void) const { return SOAP_NEW(tt__MoveStatus_); }
	         tt__MoveStatus_() { tt__MoveStatus_::soap_default(NULL); }
	virtual ~tt__MoveStatus_() { }
	friend SOAP_FMAC1 tt__MoveStatus_ * SOAP_FMAC2 soap_instantiate_tt__MoveStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5204 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState_
#define SOAP_TYPE_tt__PTZPresetTourState_ (1504)
/* Type tt__PTZPresetTourState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourState simple type: */
class SOAP_CMAC tt__PTZPresetTourState_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourState_ (1504)
	virtual int soap_type(void) const { return 1504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourState_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourState_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourState_); }
	         tt__PTZPresetTourState_() { tt__PTZPresetTourState_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourState_() { }
	friend SOAP_FMAC1 tt__PTZPresetTourState_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5221 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection_
#define SOAP_TYPE_tt__PTZPresetTourDirection_ (1506)
/* Type tt__PTZPresetTourDirection_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourDirection simple type: */
class SOAP_CMAC tt__PTZPresetTourDirection_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourDirection __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourDirection_ (1506)
	virtual int soap_type(void) const { return 1506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourDirection_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourDirection_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourDirection_); }
	         tt__PTZPresetTourDirection_() { tt__PTZPresetTourDirection_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourDirection_() { }
	friend SOAP_FMAC1 tt__PTZPresetTourDirection_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourDirection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5239 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation_
#define SOAP_TYPE_tt__PTZPresetTourOperation_ (1508)
/* Type tt__PTZPresetTourOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourOperation simple type: */
class SOAP_CMAC tt__PTZPresetTourOperation_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOperation_ (1508)
	virtual int soap_type(void) const { return 1508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOperation_, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOperation_); }
	         tt__PTZPresetTourOperation_() { tt__PTZPresetTourOperation_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOperation_() { }
	friend SOAP_FMAC1 tt__PTZPresetTourOperation_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5255 */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (1510)
/* Type tt__AutoFocusMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AutoFocusMode simple type: */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType
{
public:
	enum tt__AutoFocusMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AutoFocusMode_ (1510)
	virtual int soap_type(void) const { return 1510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AutoFocusMode_, default initialized and not managed by a soap context
	virtual tt__AutoFocusMode_ *soap_alloc(void) const { return SOAP_NEW(tt__AutoFocusMode_); }
	         tt__AutoFocusMode_() { tt__AutoFocusMode_::soap_default(NULL); }
	virtual ~tt__AutoFocusMode_() { }
	friend SOAP_FMAC1 tt__AutoFocusMode_ * SOAP_FMAC2 soap_instantiate_tt__AutoFocusMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5271 */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (1512)
/* Type tt__WideDynamicMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicMode simple type: */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType
{
public:
	enum tt__WideDynamicMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicMode_ (1512)
	virtual int soap_type(void) const { return 1512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicMode_, default initialized and not managed by a soap context
	virtual tt__WideDynamicMode_ *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicMode_); }
	         tt__WideDynamicMode_() { tt__WideDynamicMode_::soap_default(NULL); }
	virtual ~tt__WideDynamicMode_() { }
	friend SOAP_FMAC1 tt__WideDynamicMode_ * SOAP_FMAC2 soap_instantiate_tt__WideDynamicMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5296 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (1514)
/* Type tt__BacklightCompensationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationMode simple type: */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationMode_ (1514)
	virtual int soap_type(void) const { return 1514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationMode_, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationMode_); }
	         tt__BacklightCompensationMode_() { tt__BacklightCompensationMode_::soap_default(NULL); }
	virtual ~tt__BacklightCompensationMode_() { }
	friend SOAP_FMAC1 tt__BacklightCompensationMode_ * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5312 */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (1516)
/* Type tt__ExposurePriority_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposurePriority simple type: */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType
{
public:
	enum tt__ExposurePriority __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposurePriority_ (1516)
	virtual int soap_type(void) const { return 1516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposurePriority_, default initialized and not managed by a soap context
	virtual tt__ExposurePriority_ *soap_alloc(void) const { return SOAP_NEW(tt__ExposurePriority_); }
	         tt__ExposurePriority_() { tt__ExposurePriority_::soap_default(NULL); }
	virtual ~tt__ExposurePriority_() { }
	friend SOAP_FMAC1 tt__ExposurePriority_ * SOAP_FMAC2 soap_instantiate_tt__ExposurePriority_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5328 */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (1518)
/* Type tt__ExposureMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureMode simple type: */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType
{
public:
	enum tt__ExposureMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureMode_ (1518)
	virtual int soap_type(void) const { return 1518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureMode_, default initialized and not managed by a soap context
	virtual tt__ExposureMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ExposureMode_); }
	         tt__ExposureMode_() { tt__ExposureMode_::soap_default(NULL); }
	virtual ~tt__ExposureMode_() { }
	friend SOAP_FMAC1 tt__ExposureMode_ * SOAP_FMAC2 soap_instantiate_tt__ExposureMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5344 */
#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (1520)
/* Type tt__Enabled_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Enabled simple type: */
class SOAP_CMAC tt__Enabled_ : public xsd__anyType
{
public:
	enum tt__Enabled __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Enabled_ (1520)
	virtual int soap_type(void) const { return 1520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Enabled_, default initialized and not managed by a soap context
	virtual tt__Enabled_ *soap_alloc(void) const { return SOAP_NEW(tt__Enabled_); }
	         tt__Enabled_() { tt__Enabled_::soap_default(NULL); }
	virtual ~tt__Enabled_() { }
	friend SOAP_FMAC1 tt__Enabled_ * SOAP_FMAC2 soap_instantiate_tt__Enabled_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5360 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (1522)
/* Type tt__WhiteBalanceMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceMode simple type: */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceMode_ (1522)
	virtual int soap_type(void) const { return 1522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceMode_, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceMode_ *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceMode_); }
	         tt__WhiteBalanceMode_() { tt__WhiteBalanceMode_::soap_default(NULL); }
	virtual ~tt__WhiteBalanceMode_() { }
	friend SOAP_FMAC1 tt__WhiteBalanceMode_ * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5377 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (1524)
/* Type tt__IrCutFilterMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IrCutFilterMode simple type: */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IrCutFilterMode_ (1524)
	virtual int soap_type(void) const { return 1524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IrCutFilterMode_, default initialized and not managed by a soap context
	virtual tt__IrCutFilterMode_ *soap_alloc(void) const { return SOAP_NEW(tt__IrCutFilterMode_); }
	         tt__IrCutFilterMode_() { tt__IrCutFilterMode_::soap_default(NULL); }
	virtual ~tt__IrCutFilterMode_() { }
	friend SOAP_FMAC1 tt__IrCutFilterMode_ * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5395 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (1526)
/* Type tt__ImageStabilizationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationMode simple type: */
class SOAP_CMAC tt__ImageStabilizationMode_ : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationMode_ (1526)
	virtual int soap_type(void) const { return 1526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationMode_, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationMode_); }
	         tt__ImageStabilizationMode_() { tt__ImageStabilizationMode_::soap_default(NULL); }
	virtual ~tt__ImageStabilizationMode_() { }
	friend SOAP_FMAC1 tt__ImageStabilizationMode_ * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5406 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation__
#define SOAP_TYPE_tt__TopicNamespaceLocation__ (1528)
/* Type tt__TopicNamespaceLocation__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TopicNamespaceLocation simple type: */
class SOAP_CMAC tt__TopicNamespaceLocation__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TopicNamespaceLocation__ (1528)
	virtual int soap_type(void) const { return 1528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TopicNamespaceLocation__, default initialized and not managed by a soap context
	virtual tt__TopicNamespaceLocation__ *soap_alloc(void) const { return SOAP_NEW(tt__TopicNamespaceLocation__); }
	         tt__TopicNamespaceLocation__() { tt__TopicNamespaceLocation__::soap_default(NULL); }
	virtual ~tt__TopicNamespaceLocation__() { }
	friend SOAP_FMAC1 tt__TopicNamespaceLocation__ * SOAP_FMAC2 soap_instantiate_tt__TopicNamespaceLocation__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5423 */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (1530)
/* Type tt__PropertyOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PropertyOperation simple type: */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType
{
public:
	enum tt__PropertyOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PropertyOperation_ (1530)
	virtual int soap_type(void) const { return 1530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PropertyOperation_, default initialized and not managed by a soap context
	virtual tt__PropertyOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__PropertyOperation_); }
	         tt__PropertyOperation_() { tt__PropertyOperation_::soap_default(NULL); }
	virtual ~tt__PropertyOperation_() { }
	friend SOAP_FMAC1 tt__PropertyOperation_ * SOAP_FMAC2 soap_instantiate_tt__PropertyOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5440 */
#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (1532)
/* Type tt__Direction_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Direction simple type: */
class SOAP_CMAC tt__Direction_ : public xsd__anyType
{
public:
	enum tt__Direction __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Direction_ (1532)
	virtual int soap_type(void) const { return 1532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Direction_, default initialized and not managed by a soap context
	virtual tt__Direction_ *soap_alloc(void) const { return SOAP_NEW(tt__Direction_); }
	         tt__Direction_() { tt__Direction_::soap_default(NULL); }
	virtual ~tt__Direction_() { }
	friend SOAP_FMAC1 tt__Direction_ * SOAP_FMAC2 soap_instantiate_tt__Direction_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5459 */
#ifndef SOAP_TYPE_tt__ClassType_
#define SOAP_TYPE_tt__ClassType_ (1534)
/* Type tt__ClassType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassType simple type: */
class SOAP_CMAC tt__ClassType_ : public xsd__anyType
{
public:
	enum tt__ClassType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassType_ (1534)
	virtual int soap_type(void) const { return 1534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassType_, default initialized and not managed by a soap context
	virtual tt__ClassType_ *soap_alloc(void) const { return SOAP_NEW(tt__ClassType_); }
	         tt__ClassType_() { tt__ClassType_::soap_default(NULL); }
	virtual ~tt__ClassType_() { }
	friend SOAP_FMAC1 tt__ClassType_ * SOAP_FMAC2 soap_instantiate_tt__ClassType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5492 */
#ifndef SOAP_TYPE_tt__ReceiverMode_
#define SOAP_TYPE_tt__ReceiverMode_ (1536)
/* Type tt__ReceiverMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverMode simple type: */
class SOAP_CMAC tt__ReceiverMode_ : public xsd__anyType
{
public:
	enum tt__ReceiverMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverMode_ (1536)
	virtual int soap_type(void) const { return 1536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverMode_, default initialized and not managed by a soap context
	virtual tt__ReceiverMode_ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverMode_); }
	         tt__ReceiverMode_() { tt__ReceiverMode_::soap_default(NULL); }
	virtual ~tt__ReceiverMode_() { }
	friend SOAP_FMAC1 tt__ReceiverMode_ * SOAP_FMAC2 soap_instantiate_tt__ReceiverMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5525 */
#ifndef SOAP_TYPE_tt__ReceiverState_
#define SOAP_TYPE_tt__ReceiverState_ (1538)
/* Type tt__ReceiverState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverState simple type: */
class SOAP_CMAC tt__ReceiverState_ : public xsd__anyType
{
public:
	enum tt__ReceiverState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverState_ (1538)
	virtual int soap_type(void) const { return 1538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverState_, default initialized and not managed by a soap context
	virtual tt__ReceiverState_ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverState_); }
	         tt__ReceiverState_() { tt__ReceiverState_::soap_default(NULL); }
	virtual ~tt__ReceiverState_() { }
	friend SOAP_FMAC1 tt__ReceiverState_ * SOAP_FMAC2 soap_instantiate_tt__ReceiverState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5536 */
#ifndef SOAP_TYPE_tt__Description__
#define SOAP_TYPE_tt__Description__ (1540)
/* Type tt__Description__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Description simple type: */
class SOAP_CMAC tt__Description__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Description__ (1540)
	virtual int soap_type(void) const { return 1540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Description__, default initialized and not managed by a soap context
	virtual tt__Description__ *soap_alloc(void) const { return SOAP_NEW(tt__Description__); }
	         tt__Description__() { tt__Description__::soap_default(NULL); }
	virtual ~tt__Description__() { }
	friend SOAP_FMAC1 tt__Description__ * SOAP_FMAC2 soap_instantiate_tt__Description__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5547 */
#ifndef SOAP_TYPE_tt__XPathExpression__
#define SOAP_TYPE_tt__XPathExpression__ (1542)
/* Type tt__XPathExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:XPathExpression simple type: */
class SOAP_CMAC tt__XPathExpression__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__XPathExpression__ (1542)
	virtual int soap_type(void) const { return 1542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__XPathExpression__, default initialized and not managed by a soap context
	virtual tt__XPathExpression__ *soap_alloc(void) const { return SOAP_NEW(tt__XPathExpression__); }
	         tt__XPathExpression__() { tt__XPathExpression__::soap_default(NULL); }
	virtual ~tt__XPathExpression__() { }
	friend SOAP_FMAC1 tt__XPathExpression__ * SOAP_FMAC2 soap_instantiate_tt__XPathExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5577 */
#ifndef SOAP_TYPE_tt__SearchState_
#define SOAP_TYPE_tt__SearchState_ (1544)
/* Type tt__SearchState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchState simple type: */
class SOAP_CMAC tt__SearchState_ : public xsd__anyType
{
public:
	enum tt__SearchState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchState_ (1544)
	virtual int soap_type(void) const { return 1544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchState_, default initialized and not managed by a soap context
	virtual tt__SearchState_ *soap_alloc(void) const { return SOAP_NEW(tt__SearchState_); }
	         tt__SearchState_() { tt__SearchState_::soap_default(NULL); }
	virtual ~tt__SearchState_() { }
	friend SOAP_FMAC1 tt__SearchState_ * SOAP_FMAC2 soap_instantiate_tt__SearchState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5600 */
#ifndef SOAP_TYPE_tt__RecordingStatus_
#define SOAP_TYPE_tt__RecordingStatus_ (1546)
/* Type tt__RecordingStatus_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingStatus simple type: */
class SOAP_CMAC tt__RecordingStatus_ : public xsd__anyType
{
public:
	enum tt__RecordingStatus __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingStatus_ (1546)
	virtual int soap_type(void) const { return 1546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingStatus_, default initialized and not managed by a soap context
	virtual tt__RecordingStatus_ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingStatus_); }
	         tt__RecordingStatus_() { tt__RecordingStatus_::soap_default(NULL); }
	virtual ~tt__RecordingStatus_() { }
	friend SOAP_FMAC1 tt__RecordingStatus_ * SOAP_FMAC2 soap_instantiate_tt__RecordingStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5621 */
#ifndef SOAP_TYPE_tt__TrackType_
#define SOAP_TYPE_tt__TrackType_ (1548)
/* Type tt__TrackType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackType simple type: */
class SOAP_CMAC tt__TrackType_ : public xsd__anyType
{
public:
	enum tt__TrackType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackType_ (1548)
	virtual int soap_type(void) const { return 1548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackType_, default initialized and not managed by a soap context
	virtual tt__TrackType_ *soap_alloc(void) const { return SOAP_NEW(tt__TrackType_); }
	         tt__TrackType_() { tt__TrackType_::soap_default(NULL); }
	virtual ~tt__TrackType_() { }
	friend SOAP_FMAC1 tt__TrackType_ * SOAP_FMAC2 soap_instantiate_tt__TrackType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5632 */
#ifndef SOAP_TYPE_tt__RecordingJobMode__
#define SOAP_TYPE_tt__RecordingJobMode__ (1550)
/* Type tt__RecordingJobMode__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobMode simple type: */
class SOAP_CMAC tt__RecordingJobMode__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobMode__ (1550)
	virtual int soap_type(void) const { return 1550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobMode__, default initialized and not managed by a soap context
	virtual tt__RecordingJobMode__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobMode__); }
	         tt__RecordingJobMode__() { tt__RecordingJobMode__::soap_default(NULL); }
	virtual ~tt__RecordingJobMode__() { }
	friend SOAP_FMAC1 tt__RecordingJobMode__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobMode__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5643 */
#ifndef SOAP_TYPE_tt__RecordingJobState__
#define SOAP_TYPE_tt__RecordingJobState__ (1552)
/* Type tt__RecordingJobState__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobState simple type: */
class SOAP_CMAC tt__RecordingJobState__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobState__ (1552)
	virtual int soap_type(void) const { return 1552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobState__, default initialized and not managed by a soap context
	virtual tt__RecordingJobState__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobState__); }
	         tt__RecordingJobState__() { tt__RecordingJobState__::soap_default(NULL); }
	virtual ~tt__RecordingJobState__() { }
	friend SOAP_FMAC1 tt__RecordingJobState__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobState__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5663 */
#ifndef SOAP_TYPE_tt__ModeOfOperation_
#define SOAP_TYPE_tt__ModeOfOperation_ (1554)
/* Type tt__ModeOfOperation_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ModeOfOperation simple type: */
class SOAP_CMAC tt__ModeOfOperation_ : public xsd__anyType
{
public:
	enum tt__ModeOfOperation __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ModeOfOperation_ (1554)
	virtual int soap_type(void) const { return 1554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ModeOfOperation_, default initialized and not managed by a soap context
	virtual tt__ModeOfOperation_ *soap_alloc(void) const { return SOAP_NEW(tt__ModeOfOperation_); }
	         tt__ModeOfOperation_() { tt__ModeOfOperation_::soap_default(NULL); }
	virtual ~tt__ModeOfOperation_() { }
	friend SOAP_FMAC1 tt__ModeOfOperation_ * SOAP_FMAC2 soap_instantiate_tt__ModeOfOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5702 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression__
#define SOAP_TYPE_wstop__FullTopicExpression__ (1556)
/* Type wstop__FullTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:FullTopicExpression simple type: */
class SOAP_CMAC wstop__FullTopicExpression__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__FullTopicExpression__ (1556)
	virtual int soap_type(void) const { return 1556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__FullTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__FullTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__FullTopicExpression__); }
	         wstop__FullTopicExpression__() { wstop__FullTopicExpression__::soap_default(NULL); }
	virtual ~wstop__FullTopicExpression__() { }
	friend SOAP_FMAC1 wstop__FullTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__FullTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5718 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (1558)
/* Type wstop__ConcreteTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ConcreteTopicExpression simple type: */
class SOAP_CMAC wstop__ConcreteTopicExpression__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ConcreteTopicExpression__ (1558)
	virtual int soap_type(void) const { return 1558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ConcreteTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__ConcreteTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__ConcreteTopicExpression__); }
	         wstop__ConcreteTopicExpression__() { wstop__ConcreteTopicExpression__::soap_default(NULL); }
	virtual ~wstop__ConcreteTopicExpression__() { }
	friend SOAP_FMAC1 wstop__ConcreteTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5733 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression__
#define SOAP_TYPE_wstop__SimpleTopicExpression__ (1560)
/* Type wstop__SimpleTopicExpression__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:SimpleTopicExpression simple type: */
class SOAP_CMAC wstop__SimpleTopicExpression__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__SimpleTopicExpression__ (1560)
	virtual int soap_type(void) const { return 1560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__SimpleTopicExpression__, default initialized and not managed by a soap context
	virtual wstop__SimpleTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(wstop__SimpleTopicExpression__); }
	         wstop__SimpleTopicExpression__() { wstop__SimpleTopicExpression__::soap_default(NULL); }
	virtual ~wstop__SimpleTopicExpression__() { }
	friend SOAP_FMAC1 wstop__SimpleTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__SimpleTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5879 */
#ifndef SOAP_TYPE_ns1__AddressFormatType_
#define SOAP_TYPE_ns1__AddressFormatType_ (1562)
/* Type ns1__AddressFormatType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:AddressFormatType simple type: */
class SOAP_CMAC ns1__AddressFormatType_ : public xsd__anyType
{
public:
	enum ns1__AddressFormatType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__AddressFormatType_ (1562)
	virtual int soap_type(void) const { return 1562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__AddressFormatType_, default initialized and not managed by a soap context
	virtual ns1__AddressFormatType_ *soap_alloc(void) const { return SOAP_NEW(ns1__AddressFormatType_); }
	         ns1__AddressFormatType_() { ns1__AddressFormatType_::soap_default(NULL); }
	virtual ~ns1__AddressFormatType_() { }
	friend SOAP_FMAC1 ns1__AddressFormatType_ * SOAP_FMAC2 soap_instantiate_ns1__AddressFormatType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5897 */
#ifndef SOAP_TYPE_ns1__EMailAuthenticationMode_
#define SOAP_TYPE_ns1__EMailAuthenticationMode_ (1564)
/* Type ns1__EMailAuthenticationMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailAuthenticationMode simple type: */
class SOAP_CMAC ns1__EMailAuthenticationMode_ : public xsd__anyType
{
public:
	enum ns1__EMailAuthenticationMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailAuthenticationMode_ (1564)
	virtual int soap_type(void) const { return 1564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailAuthenticationMode_, default initialized and not managed by a soap context
	virtual ns1__EMailAuthenticationMode_ *soap_alloc(void) const { return SOAP_NEW(ns1__EMailAuthenticationMode_); }
	         ns1__EMailAuthenticationMode_() { ns1__EMailAuthenticationMode_::soap_default(NULL); }
	virtual ~ns1__EMailAuthenticationMode_() { }
	friend SOAP_FMAC1 ns1__EMailAuthenticationMode_ * SOAP_FMAC2 soap_instantiate_ns1__EMailAuthenticationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5914 */
#ifndef SOAP_TYPE_ns1__HttpProtocolType_
#define SOAP_TYPE_ns1__HttpProtocolType_ (1566)
/* Type ns1__HttpProtocolType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpProtocolType simple type: */
class SOAP_CMAC ns1__HttpProtocolType_ : public xsd__anyType
{
public:
	enum ns1__HttpProtocolType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpProtocolType_ (1566)
	virtual int soap_type(void) const { return 1566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpProtocolType_, default initialized and not managed by a soap context
	virtual ns1__HttpProtocolType_ *soap_alloc(void) const { return SOAP_NEW(ns1__HttpProtocolType_); }
	         ns1__HttpProtocolType_() { ns1__HttpProtocolType_::soap_default(NULL); }
	virtual ~ns1__HttpProtocolType_() { }
	friend SOAP_FMAC1 ns1__HttpProtocolType_ * SOAP_FMAC2 soap_instantiate_ns1__HttpProtocolType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5931 */
#ifndef SOAP_TYPE_ns1__HttpAuthenticationMethodType_
#define SOAP_TYPE_ns1__HttpAuthenticationMethodType_ (1568)
/* Type ns1__HttpAuthenticationMethodType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpAuthenticationMethodType simple type: */
class SOAP_CMAC ns1__HttpAuthenticationMethodType_ : public xsd__anyType
{
public:
	enum ns1__HttpAuthenticationMethodType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpAuthenticationMethodType_ (1568)
	virtual int soap_type(void) const { return 1568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpAuthenticationMethodType_, default initialized and not managed by a soap context
	virtual ns1__HttpAuthenticationMethodType_ *soap_alloc(void) const { return SOAP_NEW(ns1__HttpAuthenticationMethodType_); }
	         ns1__HttpAuthenticationMethodType_() { ns1__HttpAuthenticationMethodType_::soap_default(NULL); }
	virtual ~ns1__HttpAuthenticationMethodType_() { }
	friend SOAP_FMAC1 ns1__HttpAuthenticationMethodType_ * SOAP_FMAC2 soap_instantiate_ns1__HttpAuthenticationMethodType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5949 */
#ifndef SOAP_TYPE_ns1__FileSuffixType_
#define SOAP_TYPE_ns1__FileSuffixType_ (1570)
/* Type ns1__FileSuffixType_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FileSuffixType simple type: */
class SOAP_CMAC ns1__FileSuffixType_ : public xsd__anyType
{
public:
	enum ns1__FileSuffixType __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FileSuffixType_ (1570)
	virtual int soap_type(void) const { return 1570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FileSuffixType_, default initialized and not managed by a soap context
	virtual ns1__FileSuffixType_ *soap_alloc(void) const { return SOAP_NEW(ns1__FileSuffixType_); }
	         ns1__FileSuffixType_() { ns1__FileSuffixType_::soap_default(NULL); }
	virtual ~ns1__FileSuffixType_() { }
	friend SOAP_FMAC1 ns1__FileSuffixType_ * SOAP_FMAC2 soap_instantiate_ns1__FileSuffixType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:5982 */
#ifndef SOAP_TYPE_ns2__Decision_
#define SOAP_TYPE_ns2__Decision_ (1572)
/* Type ns2__Decision_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:Decision simple type: */
class SOAP_CMAC ns2__Decision_ : public xsd__anyType
{
public:
	enum ns2__Decision __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__Decision_ (1572)
	virtual int soap_type(void) const { return 1572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__Decision_, default initialized and not managed by a soap context
	virtual ns2__Decision_ *soap_alloc(void) const { return SOAP_NEW(ns2__Decision_); }
	         ns2__Decision_() { ns2__Decision_::soap_default(NULL); }
	virtual ~ns2__Decision_() { }
	friend SOAP_FMAC1 ns2__Decision_ * SOAP_FMAC2 soap_instantiate_ns2__Decision_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6028 */
#ifndef SOAP_TYPE_ns2__DenyReason_
#define SOAP_TYPE_ns2__DenyReason_ (1574)
/* Type ns2__DenyReason_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:DenyReason simple type: */
class SOAP_CMAC ns2__DenyReason_ : public xsd__anyType
{
public:
	enum ns2__DenyReason __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__DenyReason_ (1574)
	virtual int soap_type(void) const { return 1574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__DenyReason_, default initialized and not managed by a soap context
	virtual ns2__DenyReason_ *soap_alloc(void) const { return SOAP_NEW(ns2__DenyReason_); }
	         ns2__DenyReason_() { ns2__DenyReason_::soap_default(NULL); }
	virtual ~ns2__DenyReason_() { }
	friend SOAP_FMAC1 ns2__DenyReason_ * SOAP_FMAC2 soap_instantiate_ns2__DenyReason_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6051 */
#ifndef SOAP_TYPE_ns3__ReferenceToken__
#define SOAP_TYPE_ns3__ReferenceToken__ (1576)
/* Type ns3__ReferenceToken__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns3:ReferenceToken simple type: */
class SOAP_CMAC ns3__ReferenceToken__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ReferenceToken__ (1576)
	virtual int soap_type(void) const { return 1576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ReferenceToken__, default initialized and not managed by a soap context
	virtual ns3__ReferenceToken__ *soap_alloc(void) const { return SOAP_NEW(ns3__ReferenceToken__); }
	         ns3__ReferenceToken__() { ns3__ReferenceToken__::soap_default(NULL); }
	virtual ~ns3__ReferenceToken__() { }
	friend SOAP_FMAC1 ns3__ReferenceToken__ * SOAP_FMAC2 soap_instantiate_ns3__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6066 */
#ifndef SOAP_TYPE_ns3__Name__
#define SOAP_TYPE_ns3__Name__ (1578)
/* Type ns3__Name__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns3:Name simple type: */
class SOAP_CMAC ns3__Name__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__Name__ (1578)
	virtual int soap_type(void) const { return 1578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__Name__, default initialized and not managed by a soap context
	virtual ns3__Name__ *soap_alloc(void) const { return SOAP_NEW(ns3__Name__); }
	         ns3__Name__() { ns3__Name__::soap_default(NULL); }
	virtual ~ns3__Name__() { }
	friend SOAP_FMAC1 ns3__Name__ * SOAP_FMAC2 soap_instantiate_ns3__Name__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6083 */
#ifndef SOAP_TYPE_ns3__Description__
#define SOAP_TYPE_ns3__Description__ (1580)
/* Type ns3__Description__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns3:Description simple type: */
class SOAP_CMAC ns3__Description__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__Description__ (1580)
	virtual int soap_type(void) const { return 1580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__Description__, default initialized and not managed by a soap context
	virtual ns3__Description__ *soap_alloc(void) const { return SOAP_NEW(ns3__Description__); }
	         ns3__Description__() { ns3__Description__::soap_default(NULL); }
	virtual ~ns3__Description__() { }
	friend SOAP_FMAC1 ns3__Description__ * SOAP_FMAC2 soap_instantiate_ns3__Description__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6124 */
#ifndef SOAP_TYPE_ns4__DoorPhysicalState_
#define SOAP_TYPE_ns4__DoorPhysicalState_ (1582)
/* Type ns4__DoorPhysicalState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorPhysicalState simple type: */
class SOAP_CMAC ns4__DoorPhysicalState_ : public xsd__anyType
{
public:
	enum ns4__DoorPhysicalState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorPhysicalState_ (1582)
	virtual int soap_type(void) const { return 1582; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorPhysicalState_, default initialized and not managed by a soap context
	virtual ns4__DoorPhysicalState_ *soap_alloc(void) const { return SOAP_NEW(ns4__DoorPhysicalState_); }
	         ns4__DoorPhysicalState_() { ns4__DoorPhysicalState_::soap_default(NULL); }
	virtual ~ns4__DoorPhysicalState_() { }
	friend SOAP_FMAC1 ns4__DoorPhysicalState_ * SOAP_FMAC2 soap_instantiate_ns4__DoorPhysicalState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6157 */
#ifndef SOAP_TYPE_ns4__LockPhysicalState_
#define SOAP_TYPE_ns4__LockPhysicalState_ (1584)
/* Type ns4__LockPhysicalState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:LockPhysicalState simple type: */
class SOAP_CMAC ns4__LockPhysicalState_ : public xsd__anyType
{
public:
	enum ns4__LockPhysicalState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__LockPhysicalState_ (1584)
	virtual int soap_type(void) const { return 1584; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__LockPhysicalState_, default initialized and not managed by a soap context
	virtual ns4__LockPhysicalState_ *soap_alloc(void) const { return SOAP_NEW(ns4__LockPhysicalState_); }
	         ns4__LockPhysicalState_() { ns4__LockPhysicalState_::soap_default(NULL); }
	virtual ~ns4__LockPhysicalState_() { }
	friend SOAP_FMAC1 ns4__LockPhysicalState_ * SOAP_FMAC2 soap_instantiate_ns4__LockPhysicalState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6186 */
#ifndef SOAP_TYPE_ns4__DoorAlarmState_
#define SOAP_TYPE_ns4__DoorAlarmState_ (1586)
/* Type ns4__DoorAlarmState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorAlarmState simple type: */
class SOAP_CMAC ns4__DoorAlarmState_ : public xsd__anyType
{
public:
	enum ns4__DoorAlarmState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorAlarmState_ (1586)
	virtual int soap_type(void) const { return 1586; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorAlarmState_, default initialized and not managed by a soap context
	virtual ns4__DoorAlarmState_ *soap_alloc(void) const { return SOAP_NEW(ns4__DoorAlarmState_); }
	         ns4__DoorAlarmState_() { ns4__DoorAlarmState_::soap_default(NULL); }
	virtual ~ns4__DoorAlarmState_() { }
	friend SOAP_FMAC1 ns4__DoorAlarmState_ * SOAP_FMAC2 soap_instantiate_ns4__DoorAlarmState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6215 */
#ifndef SOAP_TYPE_ns4__DoorTamperState_
#define SOAP_TYPE_ns4__DoorTamperState_ (1588)
/* Type ns4__DoorTamperState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorTamperState simple type: */
class SOAP_CMAC ns4__DoorTamperState_ : public xsd__anyType
{
public:
	enum ns4__DoorTamperState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorTamperState_ (1588)
	virtual int soap_type(void) const { return 1588; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorTamperState_, default initialized and not managed by a soap context
	virtual ns4__DoorTamperState_ *soap_alloc(void) const { return SOAP_NEW(ns4__DoorTamperState_); }
	         ns4__DoorTamperState_() { ns4__DoorTamperState_::soap_default(NULL); }
	virtual ~ns4__DoorTamperState_() { }
	friend SOAP_FMAC1 ns4__DoorTamperState_ * SOAP_FMAC2 soap_instantiate_ns4__DoorTamperState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6244 */
#ifndef SOAP_TYPE_ns4__DoorFaultState_
#define SOAP_TYPE_ns4__DoorFaultState_ (1590)
/* Type ns4__DoorFaultState_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorFaultState simple type: */
class SOAP_CMAC ns4__DoorFaultState_ : public xsd__anyType
{
public:
	enum ns4__DoorFaultState __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorFaultState_ (1590)
	virtual int soap_type(void) const { return 1590; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorFaultState_, default initialized and not managed by a soap context
	virtual ns4__DoorFaultState_ *soap_alloc(void) const { return SOAP_NEW(ns4__DoorFaultState_); }
	         ns4__DoorFaultState_() { ns4__DoorFaultState_::soap_default(NULL); }
	virtual ~ns4__DoorFaultState_() { }
	friend SOAP_FMAC1 ns4__DoorFaultState_ * SOAP_FMAC2 soap_instantiate_ns4__DoorFaultState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6293 */
#ifndef SOAP_TYPE_ns4__DoorMode_
#define SOAP_TYPE_ns4__DoorMode_ (1592)
/* Type ns4__DoorMode_ is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorMode simple type: */
class SOAP_CMAC ns4__DoorMode_ : public xsd__anyType
{
public:
	enum ns4__DoorMode __item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorMode_ (1592)
	virtual int soap_type(void) const { return 1592; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorMode_, default initialized and not managed by a soap context
	virtual ns4__DoorMode_ *soap_alloc(void) const { return SOAP_NEW(ns4__DoorMode_); }
	         ns4__DoorMode_() { ns4__DoorMode_::soap_default(NULL); }
	virtual ~ns4__DoorMode_() { }
	friend SOAP_FMAC1 ns4__DoorMode_ * SOAP_FMAC2 soap_instantiate_ns4__DoorMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6304 */
#ifndef SOAP_TYPE_tt__ReceiverReference__
#define SOAP_TYPE_tt__ReceiverReference__ (1594)
/* Type tt__ReceiverReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverReference simple type: */
class SOAP_CMAC tt__ReceiverReference__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverReference__ (1594)
	virtual int soap_type(void) const { return 1594; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverReference__, default initialized and not managed by a soap context
	virtual tt__ReceiverReference__ *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverReference__); }
	         tt__ReceiverReference__() { tt__ReceiverReference__::soap_default(NULL); }
	virtual ~tt__ReceiverReference__() { }
	friend SOAP_FMAC1 tt__ReceiverReference__ * SOAP_FMAC2 soap_instantiate_tt__ReceiverReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6315 */
#ifndef SOAP_TYPE_tt__RecordingReference__
#define SOAP_TYPE_tt__RecordingReference__ (1596)
/* Type tt__RecordingReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingReference simple type: */
class SOAP_CMAC tt__RecordingReference__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingReference__ (1596)
	virtual int soap_type(void) const { return 1596; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingReference__, default initialized and not managed by a soap context
	virtual tt__RecordingReference__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingReference__); }
	         tt__RecordingReference__() { tt__RecordingReference__::soap_default(NULL); }
	virtual ~tt__RecordingReference__() { }
	friend SOAP_FMAC1 tt__RecordingReference__ * SOAP_FMAC2 soap_instantiate_tt__RecordingReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6326 */
#ifndef SOAP_TYPE_tt__TrackReference__
#define SOAP_TYPE_tt__TrackReference__ (1598)
/* Type tt__TrackReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackReference simple type: */
class SOAP_CMAC tt__TrackReference__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackReference__ (1598)
	virtual int soap_type(void) const { return 1598; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackReference__, default initialized and not managed by a soap context
	virtual tt__TrackReference__ *soap_alloc(void) const { return SOAP_NEW(tt__TrackReference__); }
	         tt__TrackReference__() { tt__TrackReference__::soap_default(NULL); }
	virtual ~tt__TrackReference__() { }
	friend SOAP_FMAC1 tt__TrackReference__ * SOAP_FMAC2 soap_instantiate_tt__TrackReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6337 */
#ifndef SOAP_TYPE_tt__JobToken__
#define SOAP_TYPE_tt__JobToken__ (1600)
/* Type tt__JobToken__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JobToken simple type: */
class SOAP_CMAC tt__JobToken__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JobToken__ (1600)
	virtual int soap_type(void) const { return 1600; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JobToken__, default initialized and not managed by a soap context
	virtual tt__JobToken__ *soap_alloc(void) const { return SOAP_NEW(tt__JobToken__); }
	         tt__JobToken__() { tt__JobToken__::soap_default(NULL); }
	virtual ~tt__JobToken__() { }
	friend SOAP_FMAC1 tt__JobToken__ * SOAP_FMAC2 soap_instantiate_tt__JobToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6348 */
#ifndef SOAP_TYPE_tt__RecordingJobReference__
#define SOAP_TYPE_tt__RecordingJobReference__ (1602)
/* Type tt__RecordingJobReference__ is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobReference simple type: */
class SOAP_CMAC tt__RecordingJobReference__ : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobReference__ (1602)
	virtual int soap_type(void) const { return 1602; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobReference__, default initialized and not managed by a soap context
	virtual tt__RecordingJobReference__ *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobReference__); }
	         tt__RecordingJobReference__() { tt__RecordingJobReference__::soap_default(NULL); }
	virtual ~tt__RecordingJobReference__() { }
	friend SOAP_FMAC1 tt__RecordingJobReference__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:444 */
#ifndef SOAP_TYPE_tmd__Capabilities
#define SOAP_TYPE_tmd__Capabilities (160)
/* Type tmd__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:Capabilities complex type: */
class SOAP_CMAC tmd__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int VideoSources;	/* optional attribute of XSD type xsd:int */
	int VideoOutputs;	/* optional attribute of XSD type xsd:int */
	int AudioSources;	/* optional attribute of XSD type xsd:int */
	int AudioOutputs;	/* optional attribute of XSD type xsd:int */
	int RelayOutputs;	/* optional attribute of XSD type xsd:int */
	int SerialPorts;	/* optional attribute of XSD type xsd:int */
	int DigitalInputs;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__Capabilities (160)
	virtual int soap_type(void) const { return 160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__Capabilities, default initialized and not managed by a soap context
	virtual tmd__Capabilities *soap_alloc(void) const { return SOAP_NEW(tmd__Capabilities); }
	         tmd__Capabilities() { tmd__Capabilities::soap_default(NULL); }
	virtual ~tmd__Capabilities() { }
	friend SOAP_FMAC1 tmd__Capabilities * SOAP_FMAC2 soap_instantiate_tmd__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:447 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptions
#define SOAP_TYPE_tmd__RelayOutputOptions (161)
/* Type tmd__RelayOutputOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:RelayOutputOptions complex type: */
class SOAP_CMAC tmd__RelayOutputOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:RelayMode */
	enum tt__RelayMode *Mode;
	char *DelayTimes;	/* optional element of XSD type tmd:DelayTimes */
	bool *Discrete;	/* optional element of XSD type xsd:boolean */
	tmd__RelayOutputOptionsExtension *Extension;	/* optional element of XSD type tmd:RelayOutputOptionsExtension */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptions (161)
	virtual int soap_type(void) const { return 161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptions, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptions); }
	         tmd__RelayOutputOptions() { tmd__RelayOutputOptions::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptions() { }
	friend SOAP_FMAC1 tmd__RelayOutputOptions * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:450 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptionsExtension
#define SOAP_TYPE_tmd__RelayOutputOptionsExtension (162)
/* Type tmd__RelayOutputOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:RelayOutputOptionsExtension complex type: */
class SOAP_CMAC tmd__RelayOutputOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__RelayOutputOptionsExtension (162)
	virtual int soap_type(void) const { return 162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__RelayOutputOptionsExtension, default initialized and not managed by a soap context
	virtual tmd__RelayOutputOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tmd__RelayOutputOptionsExtension); }
	         tmd__RelayOutputOptionsExtension() { tmd__RelayOutputOptionsExtension::soap_default(NULL); }
	virtual ~tmd__RelayOutputOptionsExtension() { }
	friend SOAP_FMAC1 tmd__RelayOutputOptionsExtension * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:6700 */
#ifndef SOAP_TYPE__tmd__union_SerialData
#define SOAP_TYPE__tmd__union_SerialData (1607)
/* xsd:choice complex type: */
union _tmd__union_SerialData
{
#define SOAP_UNION__tmd__union_SerialData_Binary	(1)
	xsd__base64Binary *Binary;
#define SOAP_UNION__tmd__union_SerialData_String	(2)
	char *String;
};
#endif

/* ../../wsdl/onvif.h:453 */
#ifndef SOAP_TYPE_tmd__SerialData
#define SOAP_TYPE_tmd__SerialData (163)
/* Type tmd__SerialData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialData complex type: */
class SOAP_CMAC tmd__SerialData : public xsd__anyType
{
public:
	int __union_SerialData;	/* union discriminant (of union defined below) */
	union _tmd__union_SerialData union_SerialData;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialData (163)
	virtual int soap_type(void) const { return 163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialData, default initialized and not managed by a soap context
	virtual tmd__SerialData *soap_alloc(void) const { return SOAP_NEW(tmd__SerialData); }
	         tmd__SerialData() { tmd__SerialData::soap_default(NULL); }
	virtual ~tmd__SerialData() { }
	friend SOAP_FMAC1 tmd__SerialData * SOAP_FMAC2 soap_instantiate_tmd__SerialData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:459 */
#ifndef SOAP_TYPE_tmd__SerialPortConfiguration
#define SOAP_TYPE_tmd__SerialPortConfiguration (165)
/* Type tmd__SerialPortConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortConfiguration complex type: */
class SOAP_CMAC tmd__SerialPortConfiguration : public xsd__anyType
{
public:
	int BaudRate;	/* required element of XSD type xsd:int */
	enum tmd__ParityBit ParityBit;	/* required element of XSD type tmd:ParityBit */
	int CharacterLength;	/* required element of XSD type xsd:int */
	float StopBit;	/* required element of XSD type xsd:float */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	enum tmd__SerialPortType type;	/* required attribute of XSD type tmd:SerialPortType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfiguration (165)
	virtual int soap_type(void) const { return 165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfiguration, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfiguration); }
	         tmd__SerialPortConfiguration() { tmd__SerialPortConfiguration::soap_default(NULL); }
	virtual ~tmd__SerialPortConfiguration() { }
	friend SOAP_FMAC1 tmd__SerialPortConfiguration * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:462 */
#ifndef SOAP_TYPE_tmd__SerialPortConfigurationOptions
#define SOAP_TYPE_tmd__SerialPortConfigurationOptions (166)
/* Type tmd__SerialPortConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPortConfigurationOptions complex type: */
class SOAP_CMAC tmd__SerialPortConfigurationOptions : public xsd__anyType
{
public:
	tt__IntList *BaudRateList;	/* required element of XSD type tt:IntList */
	tmd__ParityBitList *ParityBitList;	/* required element of XSD type tmd:ParityBitList */
	tt__IntList *CharacterLengthList;	/* required element of XSD type tt:IntList */
	tt__FloatList *StopBitList;	/* required element of XSD type tt:FloatList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPortConfigurationOptions (166)
	virtual int soap_type(void) const { return 166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual tmd__SerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPortConfigurationOptions); }
	         tmd__SerialPortConfigurationOptions() { tmd__SerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~tmd__SerialPortConfigurationOptions() { }
	friend SOAP_FMAC1 tmd__SerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:465 */
#ifndef SOAP_TYPE_tmd__ParityBitList
#define SOAP_TYPE_tmd__ParityBitList (167)
/* Type tmd__ParityBitList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:ParityBitList complex type: */
class SOAP_CMAC tmd__ParityBitList : public xsd__anyType
{
public:
	int __sizeItems;	/* sequence of elements <Items> of XSD type tmd:ParityBit */
	enum tmd__ParityBit *Items;
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__ParityBitList (167)
	virtual int soap_type(void) const { return 167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__ParityBitList, default initialized and not managed by a soap context
	virtual tmd__ParityBitList *soap_alloc(void) const { return SOAP_NEW(tmd__ParityBitList); }
	         tmd__ParityBitList() { tmd__ParityBitList::soap_default(NULL); }
	virtual ~tmd__ParityBitList() { }
	friend SOAP_FMAC1 tmd__ParityBitList * SOAP_FMAC2 soap_instantiate_tmd__ParityBitList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:468 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilities
#define SOAP_TYPE__tmd__GetServiceCapabilities (168)
/* tmd:GetServiceCapabilities complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilities (168)
	virtual int soap_type(void) const { return 168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilities); }
	         _tmd__GetServiceCapabilities() { _tmd__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:471 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (169)
/* tmd:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tmd__GetServiceCapabilitiesResponse
{
public:
	tmd__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (169)
	virtual int soap_type(void) const { return 169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tmd__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetServiceCapabilitiesResponse); }
	         _tmd__GetServiceCapabilitiesResponse() { _tmd__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tmd__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:474 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptions
#define SOAP_TYPE__tmd__GetRelayOutputOptions (170)
/* tmd:GetRelayOutputOptions complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptions
{
public:
	char *RelayOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptions (170)
	virtual int soap_type(void) const { return 170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptions, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptions); }
	         _tmd__GetRelayOutputOptions() { _tmd__GetRelayOutputOptions::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptions() { }
	friend SOAP_FMAC1 _tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:477 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
#define SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (171)
/* tmd:GetRelayOutputOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetRelayOutputOptionsResponse
{
public:
	int __sizeRelayOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <RelayOutputOptions> of XSD type tmd:RelayOutputOptions */
	tmd__RelayOutputOptions **RelayOutputOptions;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (171)
	virtual int soap_type(void) const { return 171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetRelayOutputOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetRelayOutputOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetRelayOutputOptionsResponse); }
	         _tmd__GetRelayOutputOptionsResponse() { _tmd__GetRelayOutputOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetRelayOutputOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:480 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputs
#define SOAP_TYPE__tmd__GetVideoOutputs (172)
/* tmd:GetVideoOutputs complex type: */
class SOAP_CMAC _tmd__GetVideoOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputs (172)
	virtual int soap_type(void) const { return 172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputs, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputs); }
	         _tmd__GetVideoOutputs() { _tmd__GetVideoOutputs::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputs() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:483 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputsResponse
#define SOAP_TYPE__tmd__GetVideoOutputsResponse (173)
/* tmd:GetVideoOutputsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputsResponse
{
public:
	int __sizeVideoOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <VideoOutputs> of XSD type tt:VideoOutput */
	tt__VideoOutput **VideoOutputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputsResponse (173)
	virtual int soap_type(void) const { return 173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputsResponse); }
	         _tmd__GetVideoOutputsResponse() { _tmd__GetVideoOutputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:486 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfiguration
#define SOAP_TYPE__tmd__GetAudioSourceConfiguration (174)
/* tmd:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfiguration
{
public:
	char *AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfiguration (174)
	virtual int soap_type(void) const { return 174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfiguration); }
	         _tmd__GetAudioSourceConfiguration() { _tmd__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:489 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (175)
/* tmd:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (175)
	virtual int soap_type(void) const { return 175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationResponse); }
	         _tmd__GetAudioSourceConfigurationResponse() { _tmd__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:492 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfiguration
#define SOAP_TYPE__tmd__GetAudioOutputConfiguration (176)
/* tmd:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfiguration
{
public:
	char *AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfiguration (176)
	virtual int soap_type(void) const { return 176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfiguration); }
	         _tmd__GetAudioOutputConfiguration() { _tmd__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:495 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (177)
/* tmd:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (177)
	virtual int soap_type(void) const { return 177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationResponse); }
	         _tmd__GetAudioOutputConfigurationResponse() { _tmd__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:498 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfiguration
#define SOAP_TYPE__tmd__GetVideoSourceConfiguration (178)
/* tmd:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfiguration
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfiguration (178)
	virtual int soap_type(void) const { return 178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfiguration); }
	         _tmd__GetVideoSourceConfiguration() { _tmd__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:501 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (179)
/* tmd:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (179)
	virtual int soap_type(void) const { return 179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationResponse); }
	         _tmd__GetVideoSourceConfigurationResponse() { _tmd__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:504 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfiguration
#define SOAP_TYPE__tmd__GetVideoOutputConfiguration (180)
/* tmd:GetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfiguration
{
public:
	char *VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfiguration (180)
	virtual int soap_type(void) const { return 180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfiguration); }
	         _tmd__GetVideoOutputConfiguration() { _tmd__GetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:507 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (181)
/* tmd:GetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationResponse
{
public:
	tt__VideoOutputConfiguration *VideoOutputConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (181)
	virtual int soap_type(void) const { return 181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationResponse); }
	         _tmd__GetVideoOutputConfigurationResponse() { _tmd__GetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:510 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfiguration
#define SOAP_TYPE__tmd__SetAudioSourceConfiguration (182)
/* tmd:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfiguration (182)
	virtual int soap_type(void) const { return 182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfiguration); }
	         _tmd__SetAudioSourceConfiguration() { _tmd__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:513 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (183)
/* tmd:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioSourceConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (183)
	virtual int soap_type(void) const { return 183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioSourceConfigurationResponse); }
	         _tmd__SetAudioSourceConfigurationResponse() { _tmd__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:516 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfiguration
#define SOAP_TYPE__tmd__SetAudioOutputConfiguration (184)
/* tmd:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfiguration (184)
	virtual int soap_type(void) const { return 184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfiguration); }
	         _tmd__SetAudioOutputConfiguration() { _tmd__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:519 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (185)
/* tmd:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetAudioOutputConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (185)
	virtual int soap_type(void) const { return 185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetAudioOutputConfigurationResponse); }
	         _tmd__SetAudioOutputConfigurationResponse() { _tmd__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:522 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfiguration
#define SOAP_TYPE__tmd__SetVideoSourceConfiguration (186)
/* tmd:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfiguration (186)
	virtual int soap_type(void) const { return 186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfiguration); }
	         _tmd__SetVideoSourceConfiguration() { _tmd__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:525 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (187)
/* tmd:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoSourceConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (187)
	virtual int soap_type(void) const { return 187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoSourceConfigurationResponse); }
	         _tmd__SetVideoSourceConfigurationResponse() { _tmd__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:528 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfiguration
#define SOAP_TYPE__tmd__SetVideoOutputConfiguration (188)
/* tmd:SetVideoOutputConfiguration complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfiguration
{
public:
	tt__VideoOutputConfiguration *Configuration;	/* required element of XSD type tt:VideoOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfiguration (188)
	virtual int soap_type(void) const { return 188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfiguration); }
	         _tmd__SetVideoOutputConfiguration() { _tmd__SetVideoOutputConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:531 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (189)
/* tmd:SetVideoOutputConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetVideoOutputConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (189)
	virtual int soap_type(void) const { return 189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetVideoOutputConfigurationResponse); }
	         _tmd__SetVideoOutputConfigurationResponse() { _tmd__SetVideoOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetVideoOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:534 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (190)
/* tmd:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptions
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (190)
	virtual int soap_type(void) const { return 190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptions); }
	         _tmd__GetVideoSourceConfigurationOptions() { _tmd__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:537 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (191)
/* tmd:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *VideoSourceConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (191)
	virtual int soap_type(void) const { return 191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoSourceConfigurationOptionsResponse); }
	         _tmd__GetVideoSourceConfigurationOptionsResponse() { _tmd__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:540 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (192)
/* tmd:GetVideoOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptions
{
public:
	char *VideoOutputToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (192)
	virtual int soap_type(void) const { return 192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptions); }
	         _tmd__GetVideoOutputConfigurationOptions() { _tmd__GetVideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:543 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (193)
/* tmd:GetVideoOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptionsResponse
{
public:
	tt__VideoOutputConfigurationOptions *VideoOutputConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoOutputConfigurationOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (193)
	virtual int soap_type(void) const { return 193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetVideoOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetVideoOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetVideoOutputConfigurationOptionsResponse); }
	         _tmd__GetVideoOutputConfigurationOptionsResponse() { _tmd__GetVideoOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetVideoOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:546 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (194)
/* tmd:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptions
{
public:
	char *AudioSourceToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (194)
	virtual int soap_type(void) const { return 194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptions); }
	         _tmd__GetAudioSourceConfigurationOptions() { _tmd__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:549 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (195)
/* tmd:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *AudioSourceOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (195)
	virtual int soap_type(void) const { return 195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioSourceConfigurationOptionsResponse); }
	         _tmd__GetAudioSourceConfigurationOptionsResponse() { _tmd__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:552 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (196)
/* tmd:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptions
{
public:
	char *AudioOutputToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (196)
	virtual int soap_type(void) const { return 196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptions); }
	         _tmd__GetAudioOutputConfigurationOptions() { _tmd__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:555 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (197)
/* tmd:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *AudioOutputOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (197)
	virtual int soap_type(void) const { return 197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetAudioOutputConfigurationOptionsResponse); }
	         _tmd__GetAudioOutputConfigurationOptionsResponse() { _tmd__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetAudioOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:558 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettings
#define SOAP_TYPE__tmd__SetRelayOutputSettings (198)
/* tmd:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettings
{
public:
	tt__RelayOutput *RelayOutput;	/* required element of XSD type tt:RelayOutput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettings (198)
	virtual int soap_type(void) const { return 198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettings); }
	         _tmd__SetRelayOutputSettings() { _tmd__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettings() { }
	friend SOAP_FMAC1 _tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:561 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (199)
/* tmd:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tmd__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (199)
	virtual int soap_type(void) const { return 199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tmd__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetRelayOutputSettingsResponse); }
	         _tmd__SetRelayOutputSettingsResponse() { _tmd__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tmd__SetRelayOutputSettingsResponse() { }
	friend SOAP_FMAC1 _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:564 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputs
#define SOAP_TYPE__tmd__GetDigitalInputs (200)
/* tmd:GetDigitalInputs complex type: */
class SOAP_CMAC _tmd__GetDigitalInputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputs (200)
	virtual int soap_type(void) const { return 200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputs, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputs *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputs); }
	         _tmd__GetDigitalInputs() { _tmd__GetDigitalInputs::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputs() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:567 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputsResponse
#define SOAP_TYPE__tmd__GetDigitalInputsResponse (201)
/* tmd:GetDigitalInputsResponse complex type: */
class SOAP_CMAC _tmd__GetDigitalInputsResponse
{
public:
	int __sizeDigitalInputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <DigitalInputs> of XSD type tt:DigitalInput */
	tt__DigitalInput **DigitalInputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetDigitalInputsResponse (201)
	virtual int soap_type(void) const { return 201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetDigitalInputsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetDigitalInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetDigitalInputsResponse); }
	         _tmd__GetDigitalInputsResponse() { _tmd__GetDigitalInputsResponse::soap_default(NULL); }
	virtual ~_tmd__GetDigitalInputsResponse() { }
	friend SOAP_FMAC1 _tmd__GetDigitalInputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:570 */
#ifndef SOAP_TYPE__tmd__GetSerialPorts
#define SOAP_TYPE__tmd__GetSerialPorts (202)
/* tmd:GetSerialPorts complex type: */
class SOAP_CMAC _tmd__GetSerialPorts
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPorts (202)
	virtual int soap_type(void) const { return 202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPorts, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPorts *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPorts); }
	         _tmd__GetSerialPorts() { _tmd__GetSerialPorts::soap_default(NULL); }
	virtual ~_tmd__GetSerialPorts() { }
	friend SOAP_FMAC1 _tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:573 */
#ifndef SOAP_TYPE__tmd__GetSerialPortsResponse
#define SOAP_TYPE__tmd__GetSerialPortsResponse (203)
/* tmd:GetSerialPortsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortsResponse
{
public:
	int __sizeSerialPort;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <SerialPort> of XSD type tmd:SerialPort */
	tmd__SerialPort **SerialPort;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortsResponse (203)
	virtual int soap_type(void) const { return 203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortsResponse); }
	         _tmd__GetSerialPortsResponse() { _tmd__GetSerialPortsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortsResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:576 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfiguration
#define SOAP_TYPE__tmd__GetSerialPortConfiguration (204)
/* tmd:GetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfiguration
{
public:
	char *SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfiguration (204)
	virtual int soap_type(void) const { return 204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfiguration); }
	         _tmd__GetSerialPortConfiguration() { _tmd__GetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfiguration() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:579 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (205)
/* tmd:GetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationResponse
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (205)
	virtual int soap_type(void) const { return 205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationResponse); }
	         _tmd__GetSerialPortConfigurationResponse() { _tmd__GetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:582 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfiguration
#define SOAP_TYPE__tmd__SetSerialPortConfiguration (206)
/* tmd:SetSerialPortConfiguration complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfiguration
{
public:
	tmd__SerialPortConfiguration *SerialPortConfiguration;	/* required element of XSD type tmd:SerialPortConfiguration */
	bool ForcePersistance;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfiguration (206)
	virtual int soap_type(void) const { return 206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfiguration, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfiguration); }
	         _tmd__SetSerialPortConfiguration() { _tmd__SetSerialPortConfiguration::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfiguration() { }
	friend SOAP_FMAC1 _tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:585 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (207)
/* tmd:SetSerialPortConfigurationResponse complex type: */
class SOAP_CMAC _tmd__SetSerialPortConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (207)
	virtual int soap_type(void) const { return 207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SetSerialPortConfigurationResponse, default initialized and not managed by a soap context
	virtual _tmd__SetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SetSerialPortConfigurationResponse); }
	         _tmd__SetSerialPortConfigurationResponse() { _tmd__SetSerialPortConfigurationResponse::soap_default(NULL); }
	virtual ~_tmd__SetSerialPortConfigurationResponse() { }
	friend SOAP_FMAC1 _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:588 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (208)
/* tmd:GetSerialPortConfigurationOptions complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptions
{
public:
	char *SerialPortToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (208)
	virtual int soap_type(void) const { return 208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptions, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptions); }
	         _tmd__GetSerialPortConfigurationOptions() { _tmd__GetSerialPortConfigurationOptions::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptions() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:591 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (209)
/* tmd:GetSerialPortConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptionsResponse
{
public:
	tmd__SerialPortConfigurationOptions *SerialPortOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tmd:SerialPortConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (209)
	virtual int soap_type(void) const { return 209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__GetSerialPortConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tmd__GetSerialPortConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__GetSerialPortConfigurationOptionsResponse); }
	         _tmd__GetSerialPortConfigurationOptionsResponse() { _tmd__GetSerialPortConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tmd__GetSerialPortConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:594 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommand
#define SOAP_TYPE__tmd__SendReceiveSerialCommand (210)
/* tmd:SendReceiveSerialCommand complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommand
{
public:
	tmd__SerialData *SerialData;	/* optional element of XSD type tmd:SerialData */
	LONG64 *TimeOut;	/* optional element of XSD type xsd:duration */
	char *DataLength;	/* optional element of XSD type xsd:integer */
	char *Delimiter;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommand (210)
	virtual int soap_type(void) const { return 210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommand, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommand *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommand); }
	         _tmd__SendReceiveSerialCommand() { _tmd__SendReceiveSerialCommand::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommand() { }
	friend SOAP_FMAC1 _tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:597 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
#define SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (211)
/* tmd:SendReceiveSerialCommandResponse complex type: */
class SOAP_CMAC _tmd__SendReceiveSerialCommandResponse
{
public:
	tmd__SerialData *SerialData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tmd:SerialData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (211)
	virtual int soap_type(void) const { return 211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tmd__SendReceiveSerialCommandResponse, default initialized and not managed by a soap context
	virtual _tmd__SendReceiveSerialCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tmd__SendReceiveSerialCommandResponse); }
	         _tmd__SendReceiveSerialCommandResponse() { _tmd__SendReceiveSerialCommandResponse::soap_default(NULL); }
	virtual ~_tmd__SendReceiveSerialCommandResponse() { }
	friend SOAP_FMAC1 _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:600 */
#ifndef SOAP_TYPE_trt__Capabilities
#define SOAP_TYPE_trt__Capabilities (212)
/* Type trt__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:Capabilities complex type: */
class SOAP_CMAC trt__Capabilities : public xsd__anyType
{
public:
	trt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type trt:ProfileCapabilities */
	trt__StreamingCapabilities *StreamingCapabilities;	/* required element of XSD type trt:StreamingCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *SnapshotUri;	/* optional attribute of XSD type xsd:boolean */
	bool *Rotation;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__Capabilities (212)
	virtual int soap_type(void) const { return 212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__Capabilities, default initialized and not managed by a soap context
	virtual trt__Capabilities *soap_alloc(void) const { return SOAP_NEW(trt__Capabilities); }
	         trt__Capabilities() { trt__Capabilities::soap_default(NULL); }
	virtual ~trt__Capabilities() { }
	friend SOAP_FMAC1 trt__Capabilities * SOAP_FMAC2 soap_instantiate_trt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:603 */
#ifndef SOAP_TYPE_trt__ProfileCapabilities
#define SOAP_TYPE_trt__ProfileCapabilities (213)
/* Type trt__ProfileCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:ProfileCapabilities complex type: */
class SOAP_CMAC trt__ProfileCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int *MaximumNumberOfProfiles;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__ProfileCapabilities (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual trt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__ProfileCapabilities); }
	         trt__ProfileCapabilities() { trt__ProfileCapabilities::soap_default(NULL); }
	virtual ~trt__ProfileCapabilities() { }
	friend SOAP_FMAC1 trt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_trt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:606 */
#ifndef SOAP_TYPE_trt__StreamingCapabilities
#define SOAP_TYPE_trt__StreamingCapabilities (214)
/* Type trt__StreamingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trt:StreamingCapabilities complex type: */
class SOAP_CMAC trt__StreamingCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *RTPMulticast;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *NonAggregateControl;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trt__StreamingCapabilities (214)
	virtual int soap_type(void) const { return 214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trt__StreamingCapabilities, default initialized and not managed by a soap context
	virtual trt__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(trt__StreamingCapabilities); }
	         trt__StreamingCapabilities() { trt__StreamingCapabilities::soap_default(NULL); }
	virtual ~trt__StreamingCapabilities() { }
	friend SOAP_FMAC1 trt__StreamingCapabilities * SOAP_FMAC2 soap_instantiate_trt__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:609 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilities
#define SOAP_TYPE__trt__GetServiceCapabilities (215)
/* trt:GetServiceCapabilities complex type: */
class SOAP_CMAC _trt__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilities (215)
	virtual int soap_type(void) const { return 215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilities); }
	         _trt__GetServiceCapabilities() { _trt__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:612 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trt__GetServiceCapabilitiesResponse (216)
/* trt:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trt__GetServiceCapabilitiesResponse
{
public:
	trt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetServiceCapabilitiesResponse (216)
	virtual int soap_type(void) const { return 216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trt__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetServiceCapabilitiesResponse); }
	         _trt__GetServiceCapabilitiesResponse() { _trt__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trt__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _trt__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:615 */
#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (217)
/* trt:GetVideoSources complex type: */
class SOAP_CMAC _trt__GetVideoSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSources (217)
	virtual int soap_type(void) const { return 217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSources, default initialized and not managed by a soap context
	virtual _trt__GetVideoSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSources); }
	         _trt__GetVideoSources() { _trt__GetVideoSources::soap_default(NULL); }
	virtual ~_trt__GetVideoSources() { }
	friend SOAP_FMAC1 _trt__GetVideoSources * SOAP_FMAC2 soap_instantiate__trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:618 */
#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (218)
/* trt:GetVideoSourcesResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourcesResponse
{
public:
	int __sizeVideoSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <VideoSources> of XSD type tt:VideoSource */
	tt__VideoSource **VideoSources;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourcesResponse (218)
	virtual int soap_type(void) const { return 218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourcesResponse); }
	         _trt__GetVideoSourcesResponse() { _trt__GetVideoSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourcesResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:621 */
#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (219)
/* trt:GetAudioSources complex type: */
class SOAP_CMAC _trt__GetAudioSources
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSources (219)
	virtual int soap_type(void) const { return 219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSources, default initialized and not managed by a soap context
	virtual _trt__GetAudioSources *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSources); }
	         _trt__GetAudioSources() { _trt__GetAudioSources::soap_default(NULL); }
	virtual ~_trt__GetAudioSources() { }
	friend SOAP_FMAC1 _trt__GetAudioSources * SOAP_FMAC2 soap_instantiate__trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:624 */
#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (220)
/* trt:GetAudioSourcesResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourcesResponse
{
public:
	int __sizeAudioSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AudioSources> of XSD type tt:AudioSource */
	tt__AudioSource **AudioSources;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourcesResponse (220)
	virtual int soap_type(void) const { return 220; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourcesResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourcesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourcesResponse); }
	         _trt__GetAudioSourcesResponse() { _trt__GetAudioSourcesResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourcesResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:627 */
#ifndef SOAP_TYPE__trt__GetAudioOutputs
#define SOAP_TYPE__trt__GetAudioOutputs (221)
/* trt:GetAudioOutputs complex type: */
class SOAP_CMAC _trt__GetAudioOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputs (221)
	virtual int soap_type(void) const { return 221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputs, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputs *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputs); }
	         _trt__GetAudioOutputs() { _trt__GetAudioOutputs::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputs() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:630 */
#ifndef SOAP_TYPE__trt__GetAudioOutputsResponse
#define SOAP_TYPE__trt__GetAudioOutputsResponse (222)
/* trt:GetAudioOutputsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputsResponse
{
public:
	int __sizeAudioOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AudioOutputs> of XSD type tt:AudioOutput */
	tt__AudioOutput **AudioOutputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputsResponse (222)
	virtual int soap_type(void) const { return 222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputsResponse); }
	         _trt__GetAudioOutputsResponse() { _trt__GetAudioOutputsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:633 */
#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (223)
/* trt:CreateProfile complex type: */
class SOAP_CMAC _trt__CreateProfile
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	char *Token;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfile (223)
	virtual int soap_type(void) const { return 223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfile, default initialized and not managed by a soap context
	virtual _trt__CreateProfile *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfile); }
	         _trt__CreateProfile() { _trt__CreateProfile::soap_default(NULL); }
	virtual ~_trt__CreateProfile() { }
	friend SOAP_FMAC1 _trt__CreateProfile * SOAP_FMAC2 soap_instantiate__trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:636 */
#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (224)
/* trt:CreateProfileResponse complex type: */
class SOAP_CMAC _trt__CreateProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__CreateProfileResponse (224)
	virtual int soap_type(void) const { return 224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__CreateProfileResponse, default initialized and not managed by a soap context
	virtual _trt__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__CreateProfileResponse); }
	         _trt__CreateProfileResponse() { _trt__CreateProfileResponse::soap_default(NULL); }
	virtual ~_trt__CreateProfileResponse() { }
	friend SOAP_FMAC1 _trt__CreateProfileResponse * SOAP_FMAC2 soap_instantiate__trt__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:639 */
#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (225)
/* trt:GetProfile complex type: */
class SOAP_CMAC _trt__GetProfile
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfile (225)
	virtual int soap_type(void) const { return 225; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfile, default initialized and not managed by a soap context
	virtual _trt__GetProfile *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfile); }
	         _trt__GetProfile() { _trt__GetProfile::soap_default(NULL); }
	virtual ~_trt__GetProfile() { }
	friend SOAP_FMAC1 _trt__GetProfile * SOAP_FMAC2 soap_instantiate__trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:642 */
#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (226)
/* trt:GetProfileResponse complex type: */
class SOAP_CMAC _trt__GetProfileResponse
{
public:
	tt__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Profile */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfileResponse (226)
	virtual int soap_type(void) const { return 226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfileResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfileResponse); }
	         _trt__GetProfileResponse() { _trt__GetProfileResponse::soap_default(NULL); }
	virtual ~_trt__GetProfileResponse() { }
	friend SOAP_FMAC1 _trt__GetProfileResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:645 */
#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (227)
/* trt:GetProfiles complex type: */
class SOAP_CMAC _trt__GetProfiles
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfiles (227)
	virtual int soap_type(void) const { return 227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfiles, default initialized and not managed by a soap context
	virtual _trt__GetProfiles *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfiles); }
	         _trt__GetProfiles() { _trt__GetProfiles::soap_default(NULL); }
	virtual ~_trt__GetProfiles() { }
	friend SOAP_FMAC1 _trt__GetProfiles * SOAP_FMAC2 soap_instantiate__trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:648 */
#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (228)
/* trt:GetProfilesResponse complex type: */
class SOAP_CMAC _trt__GetProfilesResponse
{
public:
	int __sizeProfiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Profiles> of XSD type tt:Profile */
	tt__Profile **Profiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetProfilesResponse (228)
	virtual int soap_type(void) const { return 228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetProfilesResponse, default initialized and not managed by a soap context
	virtual _trt__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetProfilesResponse); }
	         _trt__GetProfilesResponse() { _trt__GetProfilesResponse::soap_default(NULL); }
	virtual ~_trt__GetProfilesResponse() { }
	friend SOAP_FMAC1 _trt__GetProfilesResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:651 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (229)
/* trt:AddVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfiguration (229)
	virtual int soap_type(void) const { return 229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfiguration); }
	         _trt__AddVideoEncoderConfiguration() { _trt__AddVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:654 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (230)
/* trt:AddVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (230)
	virtual int soap_type(void) const { return 230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoEncoderConfigurationResponse); }
	         _trt__AddVideoEncoderConfigurationResponse() { _trt__AddVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:657 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (231)
/* trt:RemoveVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfiguration); }
	         _trt__RemoveVideoEncoderConfiguration() { _trt__RemoveVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:660 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (232)
/* trt:RemoveVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (232)
	virtual int soap_type(void) const { return 232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoEncoderConfigurationResponse); }
	         _trt__RemoveVideoEncoderConfigurationResponse() { _trt__RemoveVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:663 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (233)
/* trt:AddVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfiguration (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfiguration); }
	         _trt__AddVideoSourceConfiguration() { _trt__AddVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:666 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (234)
/* trt:AddVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (234)
	virtual int soap_type(void) const { return 234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoSourceConfigurationResponse); }
	         _trt__AddVideoSourceConfigurationResponse() { _trt__AddVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:669 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (235)
/* trt:RemoveVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfiguration (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfiguration); }
	         _trt__RemoveVideoSourceConfiguration() { _trt__RemoveVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:672 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (236)
/* trt:RemoveVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoSourceConfigurationResponse); }
	         _trt__RemoveVideoSourceConfigurationResponse() { _trt__RemoveVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:675 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (237)
/* trt:AddAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfiguration (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfiguration); }
	         _trt__AddAudioEncoderConfiguration() { _trt__AddAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:678 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (238)
/* trt:AddAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (238)
	virtual int soap_type(void) const { return 238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioEncoderConfigurationResponse); }
	         _trt__AddAudioEncoderConfigurationResponse() { _trt__AddAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:681 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (239)
/* trt:RemoveAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (239)
	virtual int soap_type(void) const { return 239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfiguration); }
	         _trt__RemoveAudioEncoderConfiguration() { _trt__RemoveAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:684 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (240)
/* trt:RemoveAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (240)
	virtual int soap_type(void) const { return 240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioEncoderConfigurationResponse); }
	         _trt__RemoveAudioEncoderConfigurationResponse() { _trt__RemoveAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:687 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (241)
/* trt:AddAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfiguration (241)
	virtual int soap_type(void) const { return 241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfiguration); }
	         _trt__AddAudioSourceConfiguration() { _trt__AddAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:690 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (242)
/* trt:AddAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (242)
	virtual int soap_type(void) const { return 242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioSourceConfigurationResponse); }
	         _trt__AddAudioSourceConfigurationResponse() { _trt__AddAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:693 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (243)
/* trt:RemoveAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfiguration (243)
	virtual int soap_type(void) const { return 243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfiguration); }
	         _trt__RemoveAudioSourceConfiguration() { _trt__RemoveAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:696 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (244)
/* trt:RemoveAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (244)
	virtual int soap_type(void) const { return 244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioSourceConfigurationResponse); }
	         _trt__RemoveAudioSourceConfigurationResponse() { _trt__RemoveAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:699 */
#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (245)
/* trt:AddPTZConfiguration complex type: */
class SOAP_CMAC _trt__AddPTZConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfiguration (245)
	virtual int soap_type(void) const { return 245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfiguration); }
	         _trt__AddPTZConfiguration() { _trt__AddPTZConfiguration::soap_default(NULL); }
	virtual ~_trt__AddPTZConfiguration() { }
	friend SOAP_FMAC1 _trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:702 */
#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (246)
/* trt:AddPTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddPTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddPTZConfigurationResponse (246)
	virtual int soap_type(void) const { return 246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddPTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddPTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddPTZConfigurationResponse); }
	         _trt__AddPTZConfigurationResponse() { _trt__AddPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddPTZConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddPTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:705 */
#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (247)
/* trt:RemovePTZConfiguration complex type: */
class SOAP_CMAC _trt__RemovePTZConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfiguration (247)
	virtual int soap_type(void) const { return 247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfiguration); }
	         _trt__RemovePTZConfiguration() { _trt__RemovePTZConfiguration::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfiguration() { }
	friend SOAP_FMAC1 _trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:708 */
#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (248)
/* trt:RemovePTZConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemovePTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemovePTZConfigurationResponse (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemovePTZConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemovePTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemovePTZConfigurationResponse); }
	         _trt__RemovePTZConfigurationResponse() { _trt__RemovePTZConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemovePTZConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemovePTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:711 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (249)
/* trt:AddVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (249)
	virtual int soap_type(void) const { return 249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfiguration); }
	         _trt__AddVideoAnalyticsConfiguration() { _trt__AddVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:714 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (250)
/* trt:AddVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (250)
	virtual int soap_type(void) const { return 250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddVideoAnalyticsConfigurationResponse); }
	         _trt__AddVideoAnalyticsConfigurationResponse() { _trt__AddVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:717 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (251)
/* trt:RemoveVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (251)
	virtual int soap_type(void) const { return 251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfiguration); }
	         _trt__RemoveVideoAnalyticsConfiguration() { _trt__RemoveVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:720 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (252)
/* trt:RemoveVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (252)
	virtual int soap_type(void) const { return 252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveVideoAnalyticsConfigurationResponse); }
	         _trt__RemoveVideoAnalyticsConfigurationResponse() { _trt__RemoveVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:723 */
#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (253)
/* trt:AddMetadataConfiguration complex type: */
class SOAP_CMAC _trt__AddMetadataConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfiguration (253)
	virtual int soap_type(void) const { return 253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfiguration); }
	         _trt__AddMetadataConfiguration() { _trt__AddMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:726 */
#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (254)
/* trt:AddMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddMetadataConfigurationResponse (254)
	virtual int soap_type(void) const { return 254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddMetadataConfigurationResponse); }
	         _trt__AddMetadataConfigurationResponse() { _trt__AddMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:729 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (255)
/* trt:RemoveMetadataConfiguration complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfiguration (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfiguration); }
	         _trt__RemoveMetadataConfiguration() { _trt__RemoveMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:732 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (256)
/* trt:RemoveMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveMetadataConfigurationResponse); }
	         _trt__RemoveMetadataConfigurationResponse() { _trt__RemoveMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:735 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfiguration
#define SOAP_TYPE__trt__AddAudioOutputConfiguration (257)
/* trt:AddAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfiguration (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfiguration); }
	         _trt__AddAudioOutputConfiguration() { _trt__AddAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:738 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (258)
/* trt:AddAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (258)
	virtual int soap_type(void) const { return 258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioOutputConfigurationResponse); }
	         _trt__AddAudioOutputConfigurationResponse() { _trt__AddAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:741 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE__trt__RemoveAudioOutputConfiguration (259)
/* trt:RemoveAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfiguration (259)
	virtual int soap_type(void) const { return 259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfiguration); }
	         _trt__RemoveAudioOutputConfiguration() { _trt__RemoveAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:744 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (260)
/* trt:RemoveAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (260)
	virtual int soap_type(void) const { return 260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioOutputConfigurationResponse); }
	         _trt__RemoveAudioOutputConfigurationResponse() { _trt__RemoveAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:747 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfiguration
#define SOAP_TYPE__trt__AddAudioDecoderConfiguration (261)
/* trt:AddAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfiguration (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfiguration); }
	         _trt__AddAudioDecoderConfiguration() { _trt__AddAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:750 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (262)
/* trt:AddAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__AddAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__AddAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__AddAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__AddAudioDecoderConfigurationResponse); }
	         _trt__AddAudioDecoderConfigurationResponse() { _trt__AddAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__AddAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:753 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (263)
/* trt:RemoveAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfiguration
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (263)
	virtual int soap_type(void) const { return 263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfiguration); }
	         _trt__RemoveAudioDecoderConfiguration() { _trt__RemoveAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:756 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (264)
/* trt:RemoveAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__RemoveAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (264)
	virtual int soap_type(void) const { return 264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__RemoveAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__RemoveAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__RemoveAudioDecoderConfigurationResponse); }
	         _trt__RemoveAudioDecoderConfigurationResponse() { _trt__RemoveAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__RemoveAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:759 */
#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (265)
/* trt:DeleteProfile complex type: */
class SOAP_CMAC _trt__DeleteProfile
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfile (265)
	virtual int soap_type(void) const { return 265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfile, default initialized and not managed by a soap context
	virtual _trt__DeleteProfile *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfile); }
	         _trt__DeleteProfile() { _trt__DeleteProfile::soap_default(NULL); }
	virtual ~_trt__DeleteProfile() { }
	friend SOAP_FMAC1 _trt__DeleteProfile * SOAP_FMAC2 soap_instantiate__trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:762 */
#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (266)
/* trt:DeleteProfileResponse complex type: */
class SOAP_CMAC _trt__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__DeleteProfileResponse (266)
	virtual int soap_type(void) const { return 266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__DeleteProfileResponse, default initialized and not managed by a soap context
	virtual _trt__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW(_trt__DeleteProfileResponse); }
	         _trt__DeleteProfileResponse() { _trt__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_trt__DeleteProfileResponse() { }
	friend SOAP_FMAC1 _trt__DeleteProfileResponse * SOAP_FMAC2 soap_instantiate__trt__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:765 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (267)
/* trt:GetVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurations (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurations); }
	         _trt__GetVideoEncoderConfigurations() { _trt__GetVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:768 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (268)
/* trt:GetVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoEncoderConfiguration */
	tt__VideoEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (268)
	virtual int soap_type(void) const { return 268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationsResponse); }
	         _trt__GetVideoEncoderConfigurationsResponse() { _trt__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:771 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (269)
/* trt:GetVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurations (269)
	virtual int soap_type(void) const { return 269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurations); }
	         _trt__GetVideoSourceConfigurations() { _trt__GetVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:774 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (270)
/* trt:GetVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoSourceConfiguration */
	tt__VideoSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationsResponse); }
	         _trt__GetVideoSourceConfigurationsResponse() { _trt__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:777 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (271)
/* trt:GetAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurations (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurations); }
	         _trt__GetAudioEncoderConfigurations() { _trt__GetAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:780 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (272)
/* trt:GetAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioEncoderConfiguration */
	tt__AudioEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationsResponse); }
	         _trt__GetAudioEncoderConfigurationsResponse() { _trt__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:783 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (273)
/* trt:GetAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurations (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurations); }
	         _trt__GetAudioSourceConfigurations() { _trt__GetAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:786 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (274)
/* trt:GetAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioSourceConfiguration */
	tt__AudioSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationsResponse); }
	         _trt__GetAudioSourceConfigurationsResponse() { _trt__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:789 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (275)
/* trt:GetVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurations); }
	         _trt__GetVideoAnalyticsConfigurations() { _trt__GetVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurations() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:792 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (276)
/* trt:GetVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoAnalyticsConfiguration */
	tt__VideoAnalyticsConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationsResponse); }
	         _trt__GetVideoAnalyticsConfigurationsResponse() { _trt__GetVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:795 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (277)
/* trt:GetMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurations (277)
	virtual int soap_type(void) const { return 277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurations); }
	         _trt__GetMetadataConfigurations() { _trt__GetMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurations() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:798 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (278)
/* trt:GetMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:MetadataConfiguration */
	tt__MetadataConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationsResponse (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationsResponse); }
	         _trt__GetMetadataConfigurationsResponse() { _trt__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:801 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurations
#define SOAP_TYPE__trt__GetAudioOutputConfigurations (279)
/* trt:GetAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurations (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurations); }
	         _trt__GetAudioOutputConfigurations() { _trt__GetAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:804 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (280)
/* trt:GetAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioOutputConfiguration */
	tt__AudioOutputConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (280)
	virtual int soap_type(void) const { return 280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationsResponse); }
	         _trt__GetAudioOutputConfigurationsResponse() { _trt__GetAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:807 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetAudioDecoderConfigurations (281)
/* trt:GetAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurations (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurations); }
	         _trt__GetAudioDecoderConfigurations() { _trt__GetAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:810 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (282)
/* trt:GetAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioDecoderConfiguration */
	tt__AudioDecoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (282)
	virtual int soap_type(void) const { return 282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationsResponse); }
	         _trt__GetAudioDecoderConfigurationsResponse() { _trt__GetAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:813 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (283)
/* trt:GetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfiguration (283)
	virtual int soap_type(void) const { return 283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfiguration); }
	         _trt__GetVideoSourceConfiguration() { _trt__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:816 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (284)
/* trt:GetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationResponse
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (284)
	virtual int soap_type(void) const { return 284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationResponse); }
	         _trt__GetVideoSourceConfigurationResponse() { _trt__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:819 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (285)
/* trt:GetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfiguration (285)
	virtual int soap_type(void) const { return 285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfiguration); }
	         _trt__GetVideoEncoderConfiguration() { _trt__GetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:822 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (286)
/* trt:GetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationResponse
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationResponse); }
	         _trt__GetVideoEncoderConfigurationResponse() { _trt__GetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:825 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (287)
/* trt:GetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfiguration (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfiguration); }
	         _trt__GetAudioSourceConfiguration() { _trt__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:828 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (288)
/* trt:GetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationResponse
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationResponse); }
	         _trt__GetAudioSourceConfigurationResponse() { _trt__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:831 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (289)
/* trt:GetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfiguration (289)
	virtual int soap_type(void) const { return 289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfiguration); }
	         _trt__GetAudioEncoderConfiguration() { _trt__GetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:834 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (290)
/* trt:GetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationResponse
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (290)
	virtual int soap_type(void) const { return 290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationResponse); }
	         _trt__GetAudioEncoderConfigurationResponse() { _trt__GetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:837 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (291)
/* trt:GetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfiguration); }
	         _trt__GetVideoAnalyticsConfiguration() { _trt__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:840 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (292)
/* trt:GetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationResponse
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (292)
	virtual int soap_type(void) const { return 292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoAnalyticsConfigurationResponse); }
	         _trt__GetVideoAnalyticsConfigurationResponse() { _trt__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:843 */
#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (293)
/* trt:GetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__GetMetadataConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfiguration (293)
	virtual int soap_type(void) const { return 293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfiguration); }
	         _trt__GetMetadataConfiguration() { _trt__GetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:846 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (294)
/* trt:GetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationResponse
{
public:
	tt__MetadataConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationResponse (294)
	virtual int soap_type(void) const { return 294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationResponse); }
	         _trt__GetMetadataConfigurationResponse() { _trt__GetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:849 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfiguration
#define SOAP_TYPE__trt__GetAudioOutputConfiguration (295)
/* trt:GetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfiguration (295)
	virtual int soap_type(void) const { return 295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfiguration); }
	         _trt__GetAudioOutputConfiguration() { _trt__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:852 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (296)
/* trt:GetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationResponse
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (296)
	virtual int soap_type(void) const { return 296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationResponse); }
	         _trt__GetAudioOutputConfigurationResponse() { _trt__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:855 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfiguration
#define SOAP_TYPE__trt__GetAudioDecoderConfiguration (297)
/* trt:GetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfiguration (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfiguration); }
	         _trt__GetAudioDecoderConfiguration() { _trt__GetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:858 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (298)
/* trt:GetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationResponse
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (298)
	virtual int soap_type(void) const { return 298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationResponse); }
	         _trt__GetAudioDecoderConfigurationResponse() { _trt__GetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:861 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (299)
/* trt:GetCompatibleVideoEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurations); }
	         _trt__GetCompatibleVideoEncoderConfigurations() { _trt__GetCompatibleVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:864 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (300)
/* trt:GetCompatibleVideoEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoEncoderConfiguration */
	tt__VideoEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoEncoderConfigurationsResponse); }
	         _trt__GetCompatibleVideoEncoderConfigurationsResponse() { _trt__GetCompatibleVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:867 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (301)
/* trt:GetCompatibleVideoSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurations); }
	         _trt__GetCompatibleVideoSourceConfigurations() { _trt__GetCompatibleVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:870 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (302)
/* trt:GetCompatibleVideoSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoSourceConfiguration */
	tt__VideoSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (302)
	virtual int soap_type(void) const { return 302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoSourceConfigurationsResponse); }
	         _trt__GetCompatibleVideoSourceConfigurationsResponse() { _trt__GetCompatibleVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:873 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (303)
/* trt:GetCompatibleAudioEncoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurations); }
	         _trt__GetCompatibleAudioEncoderConfigurations() { _trt__GetCompatibleAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:876 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (304)
/* trt:GetCompatibleAudioEncoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioEncoderConfiguration */
	tt__AudioEncoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (304)
	virtual int soap_type(void) const { return 304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioEncoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioEncoderConfigurationsResponse() { _trt__GetCompatibleAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioEncoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:879 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (305)
/* trt:GetCompatibleAudioSourceConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurations); }
	         _trt__GetCompatibleAudioSourceConfigurations() { _trt__GetCompatibleAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:882 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (306)
/* trt:GetCompatibleAudioSourceConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioSourceConfiguration */
	tt__AudioSourceConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (306)
	virtual int soap_type(void) const { return 306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioSourceConfigurationsResponse); }
	         _trt__GetCompatibleAudioSourceConfigurationsResponse() { _trt__GetCompatibleAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioSourceConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:885 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (307)
/* trt:GetCompatibleVideoAnalyticsConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (307)
	virtual int soap_type(void) const { return 307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurations); }
	         _trt__GetCompatibleVideoAnalyticsConfigurations() { _trt__GetCompatibleVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:888 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (308)
/* trt:GetCompatibleVideoAnalyticsConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:VideoAnalyticsConfiguration */
	tt__VideoAnalyticsConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse); }
	         _trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { _trt__GetCompatibleVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:891 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (309)
/* trt:GetCompatibleMetadataConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurations); }
	         _trt__GetCompatibleMetadataConfigurations() { _trt__GetCompatibleMetadataConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:894 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (310)
/* trt:GetCompatibleMetadataConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:MetadataConfiguration */
	tt__MetadataConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (310)
	virtual int soap_type(void) const { return 310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleMetadataConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleMetadataConfigurationsResponse); }
	         _trt__GetCompatibleMetadataConfigurationsResponse() { _trt__GetCompatibleMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleMetadataConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:897 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (311)
/* trt:GetCompatibleAudioOutputConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (311)
	virtual int soap_type(void) const { return 311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurations); }
	         _trt__GetCompatibleAudioOutputConfigurations() { _trt__GetCompatibleAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:900 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (312)
/* trt:GetCompatibleAudioOutputConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioOutputConfiguration */
	tt__AudioOutputConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (312)
	virtual int soap_type(void) const { return 312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioOutputConfigurationsResponse); }
	         _trt__GetCompatibleAudioOutputConfigurationsResponse() { _trt__GetCompatibleAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioOutputConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:903 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (313)
/* trt:GetCompatibleAudioDecoderConfigurations complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurations
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (313)
	virtual int soap_type(void) const { return 313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurations, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurations); }
	         _trt__GetCompatibleAudioDecoderConfigurations() { _trt__GetCompatibleAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurations() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:906 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (314)
/* trt:GetCompatibleAudioDecoderConfigurationsResponse complex type: */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurationsResponse
{
public:
	int __sizeConfigurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configurations> of XSD type tt:AudioDecoderConfiguration */
	tt__AudioDecoderConfiguration **Configurations;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (314)
	virtual int soap_type(void) const { return 314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
	virtual _trt__GetCompatibleAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetCompatibleAudioDecoderConfigurationsResponse); }
	         _trt__GetCompatibleAudioDecoderConfigurationsResponse() { _trt__GetCompatibleAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_trt__GetCompatibleAudioDecoderConfigurationsResponse() { }
	friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:909 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (315)
/* trt:SetVideoEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfiguration
{
public:
	tt__VideoEncoderConfiguration *Configuration;	/* required element of XSD type tt:VideoEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfiguration (315)
	virtual int soap_type(void) const { return 315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfiguration); }
	         _trt__SetVideoEncoderConfiguration() { _trt__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:912 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (316)
/* trt:SetVideoEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (316)
	virtual int soap_type(void) const { return 316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoEncoderConfigurationResponse); }
	         _trt__SetVideoEncoderConfigurationResponse() { _trt__SetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:915 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (317)
/* trt:SetVideoSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of XSD type tt:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfiguration (317)
	virtual int soap_type(void) const { return 317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfiguration); }
	         _trt__SetVideoSourceConfiguration() { _trt__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:918 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (318)
/* trt:SetVideoSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (318)
	virtual int soap_type(void) const { return 318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoSourceConfigurationResponse); }
	         _trt__SetVideoSourceConfigurationResponse() { _trt__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:921 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (319)
/* trt:SetAudioEncoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfiguration
{
public:
	tt__AudioEncoderConfiguration *Configuration;	/* required element of XSD type tt:AudioEncoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfiguration (319)
	virtual int soap_type(void) const { return 319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfiguration); }
	         _trt__SetAudioEncoderConfiguration() { _trt__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:924 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (320)
/* trt:SetAudioEncoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (320)
	virtual int soap_type(void) const { return 320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioEncoderConfigurationResponse); }
	         _trt__SetAudioEncoderConfigurationResponse() { _trt__SetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioEncoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:927 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (321)
/* trt:SetAudioSourceConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of XSD type tt:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfiguration (321)
	virtual int soap_type(void) const { return 321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfiguration); }
	         _trt__SetAudioSourceConfiguration() { _trt__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:930 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (322)
/* trt:SetAudioSourceConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (322)
	virtual int soap_type(void) const { return 322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioSourceConfigurationResponse); }
	         _trt__SetAudioSourceConfigurationResponse() { _trt__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioSourceConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:933 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (323)
/* trt:SetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfiguration); }
	         _trt__SetVideoAnalyticsConfiguration() { _trt__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:936 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (324)
/* trt:SetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetVideoAnalyticsConfigurationResponse); }
	         _trt__SetVideoAnalyticsConfigurationResponse() { _trt__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:939 */
#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (325)
/* trt:SetMetadataConfiguration complex type: */
class SOAP_CMAC _trt__SetMetadataConfiguration
{
public:
	tt__MetadataConfiguration *Configuration;	/* required element of XSD type tt:MetadataConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfiguration (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfiguration); }
	         _trt__SetMetadataConfiguration() { _trt__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfiguration() { }
	friend SOAP_FMAC1 _trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:942 */
#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (326)
/* trt:SetMetadataConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetMetadataConfigurationResponse (326)
	virtual int soap_type(void) const { return 326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetMetadataConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetMetadataConfigurationResponse); }
	         _trt__SetMetadataConfigurationResponse() { _trt__SetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetMetadataConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:945 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfiguration
#define SOAP_TYPE__trt__SetAudioOutputConfiguration (327)
/* trt:SetAudioOutputConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of XSD type tt:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfiguration (327)
	virtual int soap_type(void) const { return 327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfiguration); }
	         _trt__SetAudioOutputConfiguration() { _trt__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:948 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (328)
/* trt:SetAudioOutputConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioOutputConfigurationResponse); }
	         _trt__SetAudioOutputConfigurationResponse() { _trt__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioOutputConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:951 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfiguration
#define SOAP_TYPE__trt__SetAudioDecoderConfiguration (329)
/* trt:SetAudioDecoderConfiguration complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfiguration
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* required element of XSD type tt:AudioDecoderConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfiguration (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfiguration); }
	         _trt__SetAudioDecoderConfiguration() { _trt__SetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfiguration() { }
	friend SOAP_FMAC1 _trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:954 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (330)
/* trt:SetAudioDecoderConfigurationResponse complex type: */
class SOAP_CMAC _trt__SetAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
	virtual _trt__SetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetAudioDecoderConfigurationResponse); }
	         _trt__SetAudioDecoderConfigurationResponse() { _trt__SetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_trt__SetAudioDecoderConfigurationResponse() { }
	friend SOAP_FMAC1 _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:957 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (331)
/* trt:GetVideoSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (331)
	virtual int soap_type(void) const { return 331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptions); }
	         _trt__GetVideoSourceConfigurationOptions() { _trt__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:960 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (332)
/* trt:GetVideoSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (332)
	virtual int soap_type(void) const { return 332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoSourceConfigurationOptionsResponse); }
	         _trt__GetVideoSourceConfigurationOptionsResponse() { _trt__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:963 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (333)
/* trt:GetVideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (333)
	virtual int soap_type(void) const { return 333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptions); }
	         _trt__GetVideoEncoderConfigurationOptions() { _trt__GetVideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:966 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (334)
/* trt:GetVideoEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptionsResponse
{
public:
	tt__VideoEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (334)
	virtual int soap_type(void) const { return 334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetVideoEncoderConfigurationOptionsResponse); }
	         _trt__GetVideoEncoderConfigurationOptionsResponse() { _trt__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetVideoEncoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:969 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (335)
/* trt:GetAudioSourceConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (335)
	virtual int soap_type(void) const { return 335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptions); }
	         _trt__GetAudioSourceConfigurationOptions() { _trt__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:972 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (336)
/* trt:GetAudioSourceConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (336)
	virtual int soap_type(void) const { return 336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioSourceConfigurationOptionsResponse); }
	         _trt__GetAudioSourceConfigurationOptionsResponse() { _trt__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioSourceConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:975 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (337)
/* trt:GetAudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (337)
	virtual int soap_type(void) const { return 337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptions); }
	         _trt__GetAudioEncoderConfigurationOptions() { _trt__GetAudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:978 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (338)
/* trt:GetAudioEncoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptionsResponse
{
public:
	tt__AudioEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioEncoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (338)
	virtual int soap_type(void) const { return 338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioEncoderConfigurationOptionsResponse); }
	         _trt__GetAudioEncoderConfigurationOptionsResponse() { _trt__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioEncoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:981 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (339)
/* trt:GetMetadataConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptions (339)
	virtual int soap_type(void) const { return 339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptions); }
	         _trt__GetMetadataConfigurationOptions() { _trt__GetMetadataConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:984 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (340)
/* trt:GetMetadataConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetMetadataConfigurationOptionsResponse
{
public:
	tt__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MetadataConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (340)
	virtual int soap_type(void) const { return 340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetMetadataConfigurationOptionsResponse); }
	         _trt__GetMetadataConfigurationOptionsResponse() { _trt__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetMetadataConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:987 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (341)
/* trt:GetAudioOutputConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptions); }
	         _trt__GetAudioOutputConfigurationOptions() { _trt__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:990 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (342)
/* trt:GetAudioOutputConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioOutputConfigurationOptionsResponse); }
	         _trt__GetAudioOutputConfigurationOptionsResponse() { _trt__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioOutputConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:993 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (343)
/* trt:GetAudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptions
{
public:
	char *ConfigurationToken;	/* optional element of XSD type tt:ReferenceToken */
	char *ProfileToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (343)
	virtual int soap_type(void) const { return 343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptions); }
	         _trt__GetAudioDecoderConfigurationOptions() { _trt__GetAudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:996 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (344)
/* trt:GetAudioDecoderConfigurationOptionsResponse complex type: */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptionsResponse
{
public:
	tt__AudioDecoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AudioDecoderConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _trt__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetAudioDecoderConfigurationOptionsResponse); }
	         _trt__GetAudioDecoderConfigurationOptionsResponse() { _trt__GetAudioDecoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_trt__GetAudioDecoderConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:999 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (345)
/* trt:GetGuaranteedNumberOfVideoEncoderInstances complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (345)
	virtual int soap_type(void) const { return 345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstances, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstances); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstances() { _trt__GetGuaranteedNumberOfVideoEncoderInstances::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
	friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1002 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (346)
/* trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse complex type: */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
{
public:
	int TotalNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:int */
	int *JPEG;	/* optional element of XSD type xsd:int */
	int *H264;	/* optional element of XSD type xsd:int */
	int *MPEG4;	/* optional element of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (346)
	virtual int soap_type(void) const { return 346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, default initialized and not managed by a soap context
	virtual _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse); }
	         _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
	friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1005 */
#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (347)
/* trt:GetStreamUri complex type: */
class SOAP_CMAC _trt__GetStreamUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUri (347)
	virtual int soap_type(void) const { return 347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUri, default initialized and not managed by a soap context
	virtual _trt__GetStreamUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUri); }
	         _trt__GetStreamUri() { _trt__GetStreamUri::soap_default(NULL); }
	virtual ~_trt__GetStreamUri() { }
	friend SOAP_FMAC1 _trt__GetStreamUri * SOAP_FMAC2 soap_instantiate__trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1008 */
#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (348)
/* trt:GetStreamUriResponse complex type: */
class SOAP_CMAC _trt__GetStreamUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetStreamUriResponse (348)
	virtual int soap_type(void) const { return 348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetStreamUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetStreamUriResponse); }
	         _trt__GetStreamUriResponse() { _trt__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_trt__GetStreamUriResponse() { }
	friend SOAP_FMAC1 _trt__GetStreamUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1011 */
#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (349)
/* trt:StartMulticastStreaming complex type: */
class SOAP_CMAC _trt__StartMulticastStreaming
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreaming (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreaming); }
	         _trt__StartMulticastStreaming() { _trt__StartMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreaming() { }
	friend SOAP_FMAC1 _trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1014 */
#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (350)
/* trt:StartMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StartMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StartMulticastStreamingResponse (350)
	virtual int soap_type(void) const { return 350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StartMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StartMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StartMulticastStreamingResponse); }
	         _trt__StartMulticastStreamingResponse() { _trt__StartMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StartMulticastStreamingResponse() { }
	friend SOAP_FMAC1 _trt__StartMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1017 */
#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (351)
/* trt:StopMulticastStreaming complex type: */
class SOAP_CMAC _trt__StopMulticastStreaming
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreaming (351)
	virtual int soap_type(void) const { return 351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreaming, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreaming); }
	         _trt__StopMulticastStreaming() { _trt__StopMulticastStreaming::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreaming() { }
	friend SOAP_FMAC1 _trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1020 */
#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (352)
/* trt:StopMulticastStreamingResponse complex type: */
class SOAP_CMAC _trt__StopMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__StopMulticastStreamingResponse (352)
	virtual int soap_type(void) const { return 352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__StopMulticastStreamingResponse, default initialized and not managed by a soap context
	virtual _trt__StopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW(_trt__StopMulticastStreamingResponse); }
	         _trt__StopMulticastStreamingResponse() { _trt__StopMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_trt__StopMulticastStreamingResponse() { }
	friend SOAP_FMAC1 _trt__StopMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1023 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (353)
/* trt:SetSynchronizationPoint complex type: */
class SOAP_CMAC _trt__SetSynchronizationPoint
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPoint (353)
	virtual int soap_type(void) const { return 353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPoint, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPoint); }
	         _trt__SetSynchronizationPoint() { _trt__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPoint() { }
	friend SOAP_FMAC1 _trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1026 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (354)
/* trt:SetSynchronizationPointResponse complex type: */
class SOAP_CMAC _trt__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__SetSynchronizationPointResponse (354)
	virtual int soap_type(void) const { return 354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__SetSynchronizationPointResponse, default initialized and not managed by a soap context
	virtual _trt__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_trt__SetSynchronizationPointResponse); }
	         _trt__SetSynchronizationPointResponse() { _trt__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_trt__SetSynchronizationPointResponse() { }
	friend SOAP_FMAC1 _trt__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1029 */
#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (355)
/* trt:GetSnapshotUri complex type: */
class SOAP_CMAC _trt__GetSnapshotUri
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUri (355)
	virtual int soap_type(void) const { return 355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUri, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUri); }
	         _trt__GetSnapshotUri() { _trt__GetSnapshotUri::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUri() { }
	friend SOAP_FMAC1 _trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1032 */
#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (356)
/* trt:GetSnapshotUriResponse complex type: */
class SOAP_CMAC _trt__GetSnapshotUriResponse
{
public:
	tt__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MediaUri */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trt__GetSnapshotUriResponse (356)
	virtual int soap_type(void) const { return 356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trt__GetSnapshotUriResponse, default initialized and not managed by a soap context
	virtual _trt__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW(_trt__GetSnapshotUriResponse); }
	         _trt__GetSnapshotUriResponse() { _trt__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_trt__GetSnapshotUriResponse() { }
	friend SOAP_FMAC1 _trt__GetSnapshotUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1035 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (357)
/* Type tt__DeviceEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceEntity simple type: */
class SOAP_CMAC tt__DeviceEntity : public xsd__anyType
{
public:
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceEntity (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
	virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW(tt__DeviceEntity); }
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
	friend SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1038 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (358)
/* Type tt__IntRectangle is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRectangle simple type: */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType
{
public:
	int x;	/* required attribute of XSD type xsd:int */
	int y;	/* required attribute of XSD type xsd:int */
	int width;	/* required attribute of XSD type xsd:int */
	int height;	/* required attribute of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangle (358)
	virtual int soap_type(void) const { return 358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
	virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangle); }
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
	friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1041 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (359)
/* Type tt__IntRectangleRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRectangleRange complex type: */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType
{
public:
	tt__IntRange *XRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *YRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRectangleRange (359)
	virtual int soap_type(void) const { return 359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
	virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRectangleRange); }
	         tt__IntRectangleRange() { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
	friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1044 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (360)
/* Type tt__IntRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntRange complex type: */
class SOAP_CMAC tt__IntRange : public xsd__anyType
{
public:
	int Min;	/* required element of XSD type xsd:int */
	int Max;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntRange (360)
	virtual int soap_type(void) const { return 360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
	virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW(tt__IntRange); }
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
	friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1047 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (361)
/* Type tt__FloatRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FloatRange complex type: */
class SOAP_CMAC tt__FloatRange : public xsd__anyType
{
public:
	float Min;	/* required element of XSD type xsd:float */
	float Max;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatRange (361)
	virtual int soap_type(void) const { return 361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
	virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW(tt__FloatRange); }
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
	friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1050 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (362)
/* Type tt__DurationRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DurationRange complex type: */
class SOAP_CMAC tt__DurationRange : public xsd__anyType
{
public:
	LONG64 Min;	/* external (custom serializer) */
	LONG64 Max;	/* external (custom serializer) */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DurationRange (362)
	virtual int soap_type(void) const { return 362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
	virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW(tt__DurationRange); }
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
	friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1053 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (363)
/* Type tt__IntList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IntList complex type: */
class SOAP_CMAC tt__IntList : public xsd__anyType
{
public:
	int __sizeItems;	/* sequence of elements <Items> of XSD type xsd:int */
	int *Items;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IntList (363)
	virtual int soap_type(void) const { return 363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IntList, default initialized and not managed by a soap context
	virtual tt__IntList *soap_alloc(void) const { return SOAP_NEW(tt__IntList); }
	         tt__IntList() { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
	friend SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1056 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (364)
/* Type tt__FloatList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FloatList complex type: */
class SOAP_CMAC tt__FloatList : public xsd__anyType
{
public:
	int __sizeItems;	/* sequence of elements <Items> of XSD type xsd:float */
	float *Items;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FloatList (364)
	virtual int soap_type(void) const { return 364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FloatList, default initialized and not managed by a soap context
	virtual tt__FloatList *soap_alloc(void) const { return SOAP_NEW(tt__FloatList); }
	         tt__FloatList() { tt__FloatList::soap_default(NULL); }
	virtual ~tt__FloatList() { }
	friend SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1059 */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (365)
/* Type tt__AnyHolder is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnyHolder complex type: */
class SOAP_CMAC tt__AnyHolder : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnyHolder (365)
	virtual int soap_type(void) const { return 365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnyHolder, default initialized and not managed by a soap context
	virtual tt__AnyHolder *soap_alloc(void) const { return SOAP_NEW(tt__AnyHolder); }
	         tt__AnyHolder() { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
	friend SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1065 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (367)
/* Type tt__VideoSourceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceExtension complex type: */
class SOAP_CMAC tt__VideoSourceExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__ImagingSettings20 *Imaging;	/* optional element of XSD type tt:ImagingSettings20 */
	tt__VideoSourceExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension (367)
	virtual int soap_type(void) const { return 367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension); }
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1068 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (368)
/* Type tt__VideoSourceExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceExtension2 (368)
	virtual int soap_type(void) const { return 368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceExtension2); }
	         tt__VideoSourceExtension2() { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1074 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (370)
/* Type tt__Profile is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Profile complex type: */
class SOAP_CMAC tt__Profile : public xsd__anyType
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of XSD type tt:VideoSourceConfiguration */
	tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of XSD type tt:AudioSourceConfiguration */
	tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of XSD type tt:VideoEncoderConfiguration */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of XSD type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZConfiguration;	/* optional element of XSD type tt:PTZConfiguration */
	tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of XSD type tt:MetadataConfiguration */
	tt__ProfileExtension *Extension;	/* optional element of XSD type tt:ProfileExtension */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
	bool *fixed;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Profile (370)
	virtual int soap_type(void) const { return 370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Profile, default initialized and not managed by a soap context
	virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW(tt__Profile); }
	         tt__Profile() { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
	friend SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1077 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (371)
/* Type tt__ProfileExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileExtension complex type: */
class SOAP_CMAC tt__ProfileExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of XSD type tt:AudioOutputConfiguration */
	tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of XSD type tt:AudioDecoderConfiguration */
	tt__ProfileExtension2 *Extension;	/* optional element of XSD type tt:ProfileExtension2 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension (371)
	virtual int soap_type(void) const { return 371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
	virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension); }
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
	friend SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1080 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (372)
/* Type tt__ProfileExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileExtension2 complex type: */
class SOAP_CMAC tt__ProfileExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileExtension2 (372)
	virtual int soap_type(void) const { return 372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
	virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ProfileExtension2); }
	         tt__ProfileExtension2() { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
	friend SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1083 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (373)
/* Type tt__ConfigurationEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigurationEntity complex type: */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType
{
public:
	char *Name;	/* required element of XSD type tt:Name */
	int UseCount;	/* required element of XSD type xsd:int */
	char *token;	/* required attribute of XSD type tt:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigurationEntity (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
	virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW(tt__ConfigurationEntity); }
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
	friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1089 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (375)
/* Type tt__VideoSourceConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension : public xsd__anyType
{
public:
	tt__Rotate *Rotate;	/* optional element of XSD type tt:Rotate */
	tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension (375)
	virtual int soap_type(void) const { return 375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension); }
	         tt__VideoSourceConfigurationExtension() { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1092 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (376)
/* Type tt__VideoSourceConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (376)
	virtual int soap_type(void) const { return 376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationExtension2); }
	         tt__VideoSourceConfigurationExtension2() { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1095 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (377)
/* Type tt__Rotate is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rotate complex type: */
class SOAP_CMAC tt__Rotate : public xsd__anyType
{
public:
	enum tt__RotateMode Mode;	/* required element of XSD type tt:RotateMode */
	int *Degree;	/* optional element of XSD type xsd:int */
	tt__RotateExtension *Extension;	/* optional element of XSD type tt:RotateExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rotate (377)
	virtual int soap_type(void) const { return 377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
	virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW(tt__Rotate); }
	         tt__Rotate() { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
	friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1098 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (378)
/* Type tt__RotateExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateExtension complex type: */
class SOAP_CMAC tt__RotateExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateExtension (378)
	virtual int soap_type(void) const { return 378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
	virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateExtension); }
	         tt__RotateExtension() { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
	friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1101 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (379)
/* Type tt__VideoSourceConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of XSD type tt:IntRectangleRange */
	int __sizeVideoSourceTokensAvailable;	/* sequence of elements <VideoSourceTokensAvailable> of XSD type tt:ReferenceToken */
	char **VideoSourceTokensAvailable;
	tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptions (379)
	virtual int soap_type(void) const { return 379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptions); }
	         tt__VideoSourceConfigurationOptions() { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1104 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (380)
/* Type tt__VideoSourceConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__RotateOptions *Rotate;	/* optional element of XSD type tt:RotateOptions */
	tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationOptionsExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension); }
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1107 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (381)
/* Type tt__VideoSourceConfigurationOptionsExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfigurationOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (381)
	virtual int soap_type(void) const { return 381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension2); }
	         tt__VideoSourceConfigurationOptionsExtension2() { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1110 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (382)
/* Type tt__RotateOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateOptions complex type: */
class SOAP_CMAC tt__RotateOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:RotateMode */
	enum tt__RotateMode *Mode;
	tt__IntList *DegreeList;	/* optional element of XSD type tt:IntList */
	tt__RotateOptionsExtension *Extension;	/* optional element of XSD type tt:RotateOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptions (382)
	virtual int soap_type(void) const { return 382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
	virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptions); }
	         tt__RotateOptions() { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
	friend SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1113 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (383)
/* Type tt__RotateOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RotateOptionsExtension complex type: */
class SOAP_CMAC tt__RotateOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RotateOptionsExtension (383)
	virtual int soap_type(void) const { return 383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
	virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__RotateOptionsExtension); }
	         tt__RotateOptionsExtension() { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
	friend SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1119 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (385)
/* Type tt__VideoResolution is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoResolution complex type: */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType
{
public:
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoResolution (385)
	virtual int soap_type(void) const { return 385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
	virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW(tt__VideoResolution); }
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
	friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1122 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (386)
/* Type tt__VideoRateControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoRateControl complex type: */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType
{
public:
	int FrameRateLimit;	/* required element of XSD type xsd:int */
	int EncodingInterval;	/* required element of XSD type xsd:int */
	int BitrateLimit;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoRateControl (386)
	virtual int soap_type(void) const { return 386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
	virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW(tt__VideoRateControl); }
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
	friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1125 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (387)
/* Type tt__Mpeg4Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Configuration complex type: */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of XSD type tt:Mpeg4Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Configuration (387)
	virtual int soap_type(void) const { return 387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
	virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Configuration); }
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
	friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1128 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (388)
/* Type tt__H264Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Configuration complex type: */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of XSD type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of XSD type tt:H264Profile */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Configuration (388)
	virtual int soap_type(void) const { return 388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
	virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW(tt__H264Configuration); }
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
	friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1131 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (389)
/* Type tt__VideoEncoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRange *QualityRange;	/* required element of XSD type tt:IntRange */
	tt__JpegOptions *JPEG;	/* optional element of XSD type tt:JpegOptions */
	tt__Mpeg4Options *MPEG4;	/* optional element of XSD type tt:Mpeg4Options */
	tt__H264Options *H264;	/* optional element of XSD type tt:H264Options */
	tt__VideoEncoderOptionsExtension *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfigurationOptions (389)
	virtual int soap_type(void) const { return 389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfigurationOptions); }
	         tt__VideoEncoderConfigurationOptions() { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1134 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (390)
/* Type tt__VideoEncoderOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderOptionsExtension complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__JpegOptions2 *JPEG;	/* optional element of XSD type tt:JpegOptions2 */
	tt__Mpeg4Options2 *MPEG4;	/* optional element of XSD type tt:Mpeg4Options2 */
	tt__H264Options2 *H264;	/* optional element of XSD type tt:H264Options2 */
	tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of XSD type tt:VideoEncoderOptionsExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension (390)
	virtual int soap_type(void) const { return 390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension); }
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1137 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (391)
/* Type tt__VideoEncoderOptionsExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderOptionsExtension2 complex type: */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (391)
	virtual int soap_type(void) const { return 391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
	virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderOptionsExtension2); }
	         tt__VideoEncoderOptionsExtension2() { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
	friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1140 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (392)
/* Type tt__JpegOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions complex type: */
class SOAP_CMAC tt__JpegOptions : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions (392)
	virtual int soap_type(void) const { return 392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
	virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions); }
	         tt__JpegOptions() { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
	friend SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1146 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (394)
/* Type tt__Mpeg4Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options complex type: */
class SOAP_CMAC tt__Mpeg4Options : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	int __sizeMpeg4ProfilesSupported;	/* sequence of elements <Mpeg4ProfilesSupported> of XSD type tt:Mpeg4Profile */
	enum tt__Mpeg4Profile *Mpeg4ProfilesSupported;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options (394)
	virtual int soap_type(void) const { return 394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options); }
	         tt__Mpeg4Options() { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
	friend SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1152 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (396)
/* Type tt__H264Options is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options complex type: */
class SOAP_CMAC tt__H264Options : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *GovLengthRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of XSD type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of XSD type tt:IntRange */
	int __sizeH264ProfilesSupported;	/* sequence of elements <H264ProfilesSupported> of XSD type tt:H264Profile */
	enum tt__H264Profile *H264ProfilesSupported;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
	virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW(tt__H264Options); }
	         tt__H264Options() { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
	friend SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1161 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (399)
/* Type tt__AudioSourceConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioSourceConfigurationOptions : public xsd__anyType
{
public:
	int __sizeInputTokensAvailable;	/* sequence of elements <InputTokensAvailable> of XSD type tt:ReferenceToken */
	char **InputTokensAvailable;
	tt__AudioSourceOptionsExtension *Extension;	/* optional element of XSD type tt:AudioSourceOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfigurationOptions (399)
	virtual int soap_type(void) const { return 399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfigurationOptions); }
	         tt__AudioSourceConfigurationOptions() { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1164 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (400)
/* Type tt__AudioSourceOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceOptionsExtension complex type: */
class SOAP_CMAC tt__AudioSourceOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceOptionsExtension (400)
	virtual int soap_type(void) const { return 400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceOptionsExtension); }
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1170 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (402)
/* Type tt__AudioEncoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions : public xsd__anyType
{
public:
	int __sizeOptions;	/* sequence of elements <Options> of XSD type tt:AudioEncoderConfigurationOption */
	tt__AudioEncoderConfigurationOption **Options;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOptions (402)
	virtual int soap_type(void) const { return 402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOptions); }
	         tt__AudioEncoderConfigurationOptions() { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1173 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (403)
/* Type tt__AudioEncoderConfigurationOption is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfigurationOption complex type: */
class SOAP_CMAC tt__AudioEncoderConfigurationOption : public xsd__anyType
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of XSD type tt:IntList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfigurationOption (403)
	virtual int soap_type(void) const { return 403; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfigurationOption); }
	         tt__AudioEncoderConfigurationOption() { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1182 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (406)
/* Type tt__MetadataConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationExtension complex type: */
class SOAP_CMAC tt__MetadataConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationExtension (406)
	virtual int soap_type(void) const { return 406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationExtension); }
	         tt__MetadataConfigurationExtension() { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1185 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (407)
/* Type tt__PTZFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZFilter complex type: */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType
{
public:
	bool Status;	/* required element of XSD type xsd:boolean */
	bool Position;	/* required element of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZFilter (407)
	virtual int soap_type(void) const { return 407; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
	virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZFilter); }
	         tt__PTZFilter() { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
	friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:12939 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1697)
/* tt:EventSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1697)
	virtual int soap_type(void) const { return 1697; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy); }
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1188 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (408)
/* Type tt__EventSubscription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventSubscription complex type: */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tt:EventSubscription-SubscriptionPolicy */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventSubscription (408)
	virtual int soap_type(void) const { return 408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
	virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW(tt__EventSubscription); }
	         tt__EventSubscription() { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
	friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1191 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (409)
/* Type tt__MetadataConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfigurationOptions complex type: */
class SOAP_CMAC tt__MetadataConfigurationOptions : public xsd__anyType
{
public:
	tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of XSD type tt:PTZStatusFilterOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfigurationOptions (409)
	virtual int soap_type(void) const { return 409; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfigurationOptions); }
	         tt__MetadataConfigurationOptions() { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
	friend SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1194 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (410)
/* Type tt__PTZStatusFilterOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatusFilterOptions complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptions : public xsd__anyType
{
public:
	bool PanTiltStatusSupported;	/* required element of XSD type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *PanTiltPositionSupported;	/* optional element of XSD type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of XSD type xsd:boolean */
	tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of XSD type tt:PTZStatusFilterOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptions (410)
	virtual int soap_type(void) const { return 410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptions); }
	         tt__PTZStatusFilterOptions() { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1197 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (411)
/* Type tt__PTZStatusFilterOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatusFilterOptionsExtension complex type: */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (411)
	virtual int soap_type(void) const { return 411; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatusFilterOptionsExtension); }
	         tt__PTZStatusFilterOptionsExtension() { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1203 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (413)
/* Type tt__VideoOutputExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputExtension complex type: */
class SOAP_CMAC tt__VideoOutputExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputExtension (413)
	virtual int soap_type(void) const { return 413; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
	virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputExtension); }
	         tt__VideoOutputExtension() { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
	friend SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1209 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (415)
/* Type tt__VideoOutputConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoOutputConfigurationOptions : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfigurationOptions (415)
	virtual int soap_type(void) const { return 415; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfigurationOptions); }
	         tt__VideoOutputConfigurationOptions() { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1212 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (416)
/* Type tt__VideoDecoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions : public xsd__anyType
{
public:
	tt__JpegDecOptions *JpegDecOptions;	/* optional element of XSD type tt:JpegDecOptions */
	tt__H264DecOptions *H264DecOptions;	/* optional element of XSD type tt:H264DecOptions */
	tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of XSD type tt:Mpeg4DecOptions */
	tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:VideoDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptions (416)
	virtual int soap_type(void) const { return 416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptions); }
	         tt__VideoDecoderConfigurationOptions() { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1215 */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (417)
/* Type tt__H264DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264DecOptions complex type: */
class SOAP_CMAC tt__H264DecOptions : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	int __sizeSupportedH264Profiles;	/* sequence of elements <SupportedH264Profiles> of XSD type tt:H264Profile */
	enum tt__H264Profile *SupportedH264Profiles;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264DecOptions (417)
	virtual int soap_type(void) const { return 417; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264DecOptions, default initialized and not managed by a soap context
	virtual tt__H264DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__H264DecOptions); }
	         tt__H264DecOptions() { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
	friend SOAP_FMAC1 tt__H264DecOptions * SOAP_FMAC2 soap_instantiate_tt__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1218 */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (418)
/* Type tt__JpegDecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegDecOptions complex type: */
class SOAP_CMAC tt__JpegDecOptions : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegDecOptions (418)
	virtual int soap_type(void) const { return 418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegDecOptions, default initialized and not managed by a soap context
	virtual tt__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__JpegDecOptions); }
	         tt__JpegDecOptions() { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
	friend SOAP_FMAC1 tt__JpegDecOptions * SOAP_FMAC2 soap_instantiate_tt__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1221 */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (419)
/* Type tt__Mpeg4DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4DecOptions complex type: */
class SOAP_CMAC tt__Mpeg4DecOptions : public xsd__anyType
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> of XSD type tt:VideoResolution */
	tt__VideoResolution **ResolutionsAvailable;
	int __sizeSupportedMpeg4Profiles;	/* sequence of elements <SupportedMpeg4Profiles> of XSD type tt:Mpeg4Profile */
	enum tt__Mpeg4Profile *SupportedMpeg4Profiles;
	tt__IntRange *SupportedInputBitrate;	/* required element of XSD type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4DecOptions (419)
	virtual int soap_type(void) const { return 419; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4DecOptions, default initialized and not managed by a soap context
	virtual tt__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4DecOptions); }
	         tt__Mpeg4DecOptions() { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
	friend SOAP_FMAC1 tt__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_tt__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1224 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (420)
/* Type tt__VideoDecoderConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (420)
	virtual int soap_type(void) const { return 420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoDecoderConfigurationOptionsExtension); }
	         tt__VideoDecoderConfigurationOptionsExtension() { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1233 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (423)
/* Type tt__AudioOutputConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioOutputConfigurationOptions : public xsd__anyType
{
public:
	int __sizeOutputTokensAvailable;	/* sequence of elements <OutputTokensAvailable> of XSD type tt:ReferenceToken */
	char **OutputTokensAvailable;
	int __sizeSendPrimacyOptions;	/* sequence of elements <SendPrimacyOptions> of XSD type xsd:anyURI */
	char **SendPrimacyOptions;
	tt__IntRange *OutputLevelRange;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfigurationOptions (423)
	virtual int soap_type(void) const { return 423; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfigurationOptions); }
	         tt__AudioOutputConfigurationOptions() { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1239 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (425)
/* Type tt__AudioDecoderConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfigurationOptions complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions : public xsd__anyType
{
public:
	tt__AACDecOptions *AACDecOptions;	/* optional element of XSD type tt:AACDecOptions */
	tt__G711DecOptions *G711DecOptions;	/* optional element of XSD type tt:G711DecOptions */
	tt__G726DecOptions *G726DecOptions;	/* optional element of XSD type tt:G726DecOptions */
	tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of XSD type tt:AudioDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptions (425)
	virtual int soap_type(void) const { return 425; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptions); }
	         tt__AudioDecoderConfigurationOptions() { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1242 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (426)
/* Type tt__G711DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:G711DecOptions complex type: */
class SOAP_CMAC tt__G711DecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G711DecOptions (426)
	virtual int soap_type(void) const { return 426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
	virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G711DecOptions); }
	         tt__G711DecOptions() { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
	friend SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1245 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (427)
/* Type tt__AACDecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AACDecOptions complex type: */
class SOAP_CMAC tt__AACDecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AACDecOptions (427)
	virtual int soap_type(void) const { return 427; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
	virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW(tt__AACDecOptions); }
	         tt__AACDecOptions() { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
	friend SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1248 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (428)
/* Type tt__G726DecOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:G726DecOptions complex type: */
class SOAP_CMAC tt__G726DecOptions : public xsd__anyType
{
public:
	tt__IntList *Bitrate;	/* required element of XSD type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of XSD type tt:IntList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__G726DecOptions (428)
	virtual int soap_type(void) const { return 428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
	virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW(tt__G726DecOptions); }
	         tt__G726DecOptions() { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
	friend SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1251 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (429)
/* Type tt__AudioDecoderConfigurationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfigurationOptionsExtension complex type: */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (429)
	virtual int soap_type(void) const { return 429; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfigurationOptionsExtension); }
	         tt__AudioDecoderConfigurationOptionsExtension() { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1254 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (430)
/* Type tt__MulticastConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MulticastConfiguration complex type: */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType
{
public:
	tt__IPAddress *Address;	/* required element of XSD type tt:IPAddress */
	int Port;	/* required element of XSD type xsd:int */
	int TTL;	/* required element of XSD type xsd:int */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MulticastConfiguration (430)
	virtual int soap_type(void) const { return 430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
	virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MulticastConfiguration); }
	         tt__MulticastConfiguration() { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
	friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1257 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (431)
/* Type tt__StreamSetup is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:StreamSetup complex type: */
class SOAP_CMAC tt__StreamSetup : public xsd__anyType
{
public:
	enum tt__StreamType Stream;	/* required element of XSD type tt:StreamType */
	tt__Transport *Transport;	/* required element of XSD type tt:Transport */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__StreamSetup (431)
	virtual int soap_type(void) const { return 431; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
	virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW(tt__StreamSetup); }
	         tt__StreamSetup() { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
	friend SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1260 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (432)
/* Type tt__Transport is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transport complex type: */
class SOAP_CMAC tt__Transport : public xsd__anyType
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of XSD type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of XSD type tt:Transport */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transport (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transport, default initialized and not managed by a soap context
	virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW(tt__Transport); }
	         tt__Transport() { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
	friend SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1263 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (433)
/* Type tt__MediaUri is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaUri complex type: */
class SOAP_CMAC tt__MediaUri : public xsd__anyType
{
public:
	char *Uri;	/* required element of XSD type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of XSD type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of XSD type xsd:boolean */
	LONG64 Timeout;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaUri (433)
	virtual int soap_type(void) const { return 433; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
	virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW(tt__MediaUri); }
	         tt__MediaUri() { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
	friend SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1266 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (434)
/* Type tt__Scope is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Scope complex type: */
class SOAP_CMAC tt__Scope : public xsd__anyType
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of XSD type tt:ScopeDefinition */
	char *ScopeItem;	/* required element of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Scope (434)
	virtual int soap_type(void) const { return 434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Scope, default initialized and not managed by a soap context
	virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW(tt__Scope); }
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
	friend SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1272 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (436)
/* Type tt__NetworkInterfaceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
	int __sizeDot3;	/* sequence of elements <Dot3> of XSD type tt:Dot3Configuration */
	tt__Dot3Configuration **Dot3;
	int __sizeDot11;	/* sequence of elements <Dot11> of XSD type tt:Dot11Configuration */
	tt__Dot11Configuration **Dot11;
	tt__NetworkInterfaceExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension (436)
	virtual int soap_type(void) const { return 436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension); }
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1275 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (437)
/* Type tt__Dot3Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot3Configuration complex type: */
class SOAP_CMAC tt__Dot3Configuration : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot3Configuration (437)
	virtual int soap_type(void) const { return 437; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
	virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot3Configuration); }
	         tt__Dot3Configuration() { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
	friend SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1278 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (438)
/* Type tt__NetworkInterfaceExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceExtension2 (438)
	virtual int soap_type(void) const { return 438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceExtension2); }
	         tt__NetworkInterfaceExtension2() { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1281 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (439)
/* Type tt__NetworkInterfaceLink is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceLink complex type: */
class SOAP_CMAC tt__NetworkInterfaceLink : public xsd__anyType
{
public:
	tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of XSD type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of XSD type tt:IANA-IfTypes */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceLink (439)
	virtual int soap_type(void) const { return 439; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceLink); }
	         tt__NetworkInterfaceLink() { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1284 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (440)
/* Type tt__NetworkInterfaceConnectionSetting is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceConnectionSetting complex type: */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting : public xsd__anyType
{
public:
	bool AutoNegotiation;	/* required element of XSD type xsd:boolean */
	int Speed;	/* required element of XSD type xsd:int */
	enum tt__Duplex Duplex;	/* required element of XSD type tt:Duplex */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (440)
	virtual int soap_type(void) const { return 440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceConnectionSetting); }
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1287 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (441)
/* Type tt__NetworkInterfaceInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceInfo complex type: */
class SOAP_CMAC tt__NetworkInterfaceInfo : public xsd__anyType
{
public:
	char *Name;	/* optional element of XSD type xsd:string */
	char *HwAddress;	/* required element of XSD type tt:HwAddress */
	int *MTU;	/* optional element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceInfo (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceInfo); }
	         tt__NetworkInterfaceInfo() { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1290 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (442)
/* Type tt__IPv6NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6NetworkInterface complex type: */
class SOAP_CMAC tt__IPv6NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv6Configuration *Config;	/* optional element of XSD type tt:IPv6Configuration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterface (442)
	virtual int soap_type(void) const { return 442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterface); }
	         tt__IPv6NetworkInterface() { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1293 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (443)
/* Type tt__IPv4NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4NetworkInterface complex type: */
class SOAP_CMAC tt__IPv4NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__IPv4Configuration *Config;	/* required element of XSD type tt:IPv4Configuration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterface (443)
	virtual int soap_type(void) const { return 443; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterface); }
	         tt__IPv4NetworkInterface() { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1296 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (444)
/* Type tt__IPv4Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4Configuration complex type: */
class SOAP_CMAC tt__IPv4Configuration : public xsd__anyType
{
public:
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **Manual;
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of XSD type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4Configuration (444)
	virtual int soap_type(void) const { return 444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
	virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4Configuration); }
	         tt__IPv4Configuration() { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
	friend SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1299 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (445)
/* Type tt__IPv6Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6Configuration complex type: */
class SOAP_CMAC tt__IPv6Configuration : public xsd__anyType
{
public:
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of XSD type tt:IPv6DHCPConfiguration */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **Manual;
	int __sizeLinkLocal;	/* sequence of elements <LinkLocal> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **LinkLocal;
	int __sizeFromDHCP;	/* sequence of elements <FromDHCP> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **FromDHCP;
	int __sizeFromRA;	/* sequence of elements <FromRA> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **FromRA;
	tt__IPv6ConfigurationExtension *Extension;	/* optional element of XSD type tt:IPv6ConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6Configuration (445)
	virtual int soap_type(void) const { return 445; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
	virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6Configuration); }
	         tt__IPv6Configuration() { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
	friend SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1302 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (446)
/* Type tt__IPv6ConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6ConfigurationExtension complex type: */
class SOAP_CMAC tt__IPv6ConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6ConfigurationExtension (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPv6ConfigurationExtension); }
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
	friend SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1305 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (447)
/* Type tt__NetworkProtocol is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocol complex type: */
class SOAP_CMAC tt__NetworkProtocol : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of XSD type tt:NetworkProtocolType */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	int __sizePort;	/* sequence of elements <Port> of XSD type xsd:int */
	int *Port;
	tt__NetworkProtocolExtension *Extension;	/* optional element of XSD type tt:NetworkProtocolExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocol (447)
	virtual int soap_type(void) const { return 447; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
	virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocol); }
	         tt__NetworkProtocol() { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
	friend SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1308 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (448)
/* Type tt__NetworkProtocolExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkProtocolExtension complex type: */
class SOAP_CMAC tt__NetworkProtocolExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkProtocolExtension (448)
	virtual int soap_type(void) const { return 448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
	virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkProtocolExtension); }
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
	friend SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1311 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (449)
/* Type tt__NetworkHost is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHost complex type: */
class SOAP_CMAC tt__NetworkHost : public xsd__anyType
{
public:
	enum tt__NetworkHostType Type;	/* required element of XSD type tt:NetworkHostType */
	char *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	char *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
	char *DNSname;	/* optional element of XSD type tt:DNSName */
	tt__NetworkHostExtension *Extension;	/* optional element of XSD type tt:NetworkHostExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHost (449)
	virtual int soap_type(void) const { return 449; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
	virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHost); }
	         tt__NetworkHost() { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
	friend SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1314 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (450)
/* Type tt__NetworkHostExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkHostExtension complex type: */
class SOAP_CMAC tt__NetworkHostExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkHostExtension (450)
	virtual int soap_type(void) const { return 450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
	virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkHostExtension); }
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
	friend SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1317 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (451)
/* Type tt__IPAddress is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddress complex type: */
class SOAP_CMAC tt__IPAddress : public xsd__anyType
{
public:
	enum tt__IPType Type;	/* required element of XSD type tt:IPType */
	char *IPv4Address;	/* optional element of XSD type tt:IPv4Address */
	char *IPv6Address;	/* optional element of XSD type tt:IPv6Address */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddress (451)
	virtual int soap_type(void) const { return 451; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
	virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW(tt__IPAddress); }
	         tt__IPAddress() { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
	friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1320 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (452)
/* Type tt__PrefixedIPv4Address is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PrefixedIPv4Address complex type: */
class SOAP_CMAC tt__PrefixedIPv4Address : public xsd__anyType
{
public:
	char *Address;	/* required element of XSD type tt:IPv4Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv4Address (452)
	virtual int soap_type(void) const { return 452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv4Address); }
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1323 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (453)
/* Type tt__PrefixedIPv6Address is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PrefixedIPv6Address complex type: */
class SOAP_CMAC tt__PrefixedIPv6Address : public xsd__anyType
{
public:
	char *Address;	/* required element of XSD type tt:IPv6Address */
	int PrefixLength;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PrefixedIPv6Address (453)
	virtual int soap_type(void) const { return 453; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
	virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW(tt__PrefixedIPv6Address); }
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
	friend SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1326 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (454)
/* Type tt__HostnameInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HostnameInformation complex type: */
class SOAP_CMAC tt__HostnameInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	char *Name;	/* optional element of XSD type xsd:token */
	tt__HostnameInformationExtension *Extension;	/* optional element of XSD type tt:HostnameInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformation (454)
	virtual int soap_type(void) const { return 454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
	virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformation); }
	         tt__HostnameInformation() { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
	friend SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1329 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (455)
/* Type tt__HostnameInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:HostnameInformationExtension complex type: */
class SOAP_CMAC tt__HostnameInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__HostnameInformationExtension (455)
	virtual int soap_type(void) const { return 455; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
	virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__HostnameInformationExtension); }
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
	friend SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1332 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (456)
/* Type tt__DNSInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSInformation complex type: */
class SOAP_CMAC tt__DNSInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeSearchDomain;	/* sequence of elements <SearchDomain> of XSD type xsd:token */
	char **SearchDomain;
	int __sizeDNSFromDHCP;	/* sequence of elements <DNSFromDHCP> of XSD type tt:IPAddress */
	tt__IPAddress **DNSFromDHCP;
	int __sizeDNSManual;	/* sequence of elements <DNSManual> of XSD type tt:IPAddress */
	tt__IPAddress **DNSManual;
	tt__DNSInformationExtension *Extension;	/* optional element of XSD type tt:DNSInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformation (456)
	virtual int soap_type(void) const { return 456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
	virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformation); }
	         tt__DNSInformation() { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
	friend SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1335 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (457)
/* Type tt__DNSInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DNSInformationExtension complex type: */
class SOAP_CMAC tt__DNSInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DNSInformationExtension (457)
	virtual int soap_type(void) const { return 457; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DNSInformationExtension); }
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1338 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (458)
/* Type tt__NTPInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NTPInformation complex type: */
class SOAP_CMAC tt__NTPInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeNTPFromDHCP;	/* sequence of elements <NTPFromDHCP> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPFromDHCP;
	int __sizeNTPManual;	/* sequence of elements <NTPManual> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPManual;
	tt__NTPInformationExtension *Extension;	/* optional element of XSD type tt:NTPInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformation (458)
	virtual int soap_type(void) const { return 458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
	virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformation); }
	         tt__NTPInformation() { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
	friend SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1341 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (459)
/* Type tt__NTPInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NTPInformationExtension complex type: */
class SOAP_CMAC tt__NTPInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NTPInformationExtension (459)
	virtual int soap_type(void) const { return 459; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
	virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NTPInformationExtension); }
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
	friend SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1344 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (460)
/* Type tt__DynamicDNSInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSInformation complex type: */
class SOAP_CMAC tt__DynamicDNSInformation : public xsd__anyType
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	char *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	tt__DynamicDNSInformationExtension *Extension;	/* optional element of XSD type tt:DynamicDNSInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformation (460)
	virtual int soap_type(void) const { return 460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformation); }
	         tt__DynamicDNSInformation() { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1347 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (461)
/* Type tt__DynamicDNSInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DynamicDNSInformationExtension complex type: */
class SOAP_CMAC tt__DynamicDNSInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DynamicDNSInformationExtension (461)
	virtual int soap_type(void) const { return 461; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
	virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__DynamicDNSInformationExtension); }
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
	friend SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1350 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (462)
/* Type tt__NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of XSD type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of XSD type xsd:int */
	tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterfaceSetConfiguration */
	tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterfaceSetConfiguration */
	tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (462)
	virtual int soap_type(void) const { return 462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfiguration); }
	         tt__NetworkInterfaceSetConfiguration() { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1353 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (463)
/* Type tt__NetworkInterfaceSetConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int __sizeDot3;	/* sequence of elements <Dot3> of XSD type tt:Dot3Configuration */
	tt__Dot3Configuration **Dot3;
	int __sizeDot11;	/* sequence of elements <Dot11> of XSD type tt:Dot11Configuration */
	tt__Dot11Configuration **Dot11;
	tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkInterfaceSetConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (463)
	virtual int soap_type(void) const { return 463; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension); }
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1356 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (464)
/* Type tt__IPv6NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv6NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of XSD type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **Manual;
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of XSD type tt:IPv6DHCPConfiguration */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (464)
	virtual int soap_type(void) const { return 464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration); }
	         tt__IPv6NetworkInterfaceSetConfiguration() { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1359 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (465)
/* Type tt__IPv4NetworkInterfaceSetConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPv4NetworkInterfaceSetConfiguration complex type: */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of XSD type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **Manual;
	bool *DHCP;	/* optional element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (465)
	virtual int soap_type(void) const { return 465; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
	virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration); }
	         tt__IPv4NetworkInterfaceSetConfiguration() { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
	friend SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1362 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (466)
/* Type tt__NetworkGateway is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkGateway complex type: */
class SOAP_CMAC tt__NetworkGateway : public xsd__anyType
{
public:
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:IPv4Address */
	char **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:IPv6Address */
	char **IPv6Address;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkGateway (466)
	virtual int soap_type(void) const { return 466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
	virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW(tt__NetworkGateway); }
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
	friend SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1365 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (467)
/* Type tt__NetworkZeroConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfiguration complex type: */
class SOAP_CMAC tt__NetworkZeroConfiguration : public xsd__anyType
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	int __sizeAddresses;	/* sequence of elements <Addresses> of XSD type tt:IPv4Address */
	char **Addresses;
	tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfiguration (467)
	virtual int soap_type(void) const { return 467; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfiguration); }
	         tt__NetworkZeroConfiguration() { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1368 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (468)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int __sizeAdditional;	/* sequence of elements <Additional> of XSD type tt:NetworkZeroConfiguration */
	tt__NetworkZeroConfiguration **Additional;
	tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of XSD type tt:NetworkZeroConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension (468)
	virtual int soap_type(void) const { return 468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension); }
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1371 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (469)
/* Type tt__NetworkZeroConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkZeroConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (469)
	virtual int soap_type(void) const { return 469; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkZeroConfigurationExtension2); }
	         tt__NetworkZeroConfigurationExtension2() { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1374 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (470)
/* Type tt__IPAddressFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilter complex type: */
class SOAP_CMAC tt__IPAddressFilter : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of XSD type tt:IPAddressFilterType */
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:PrefixedIPv6Address */
	tt__PrefixedIPv6Address **IPv6Address;
	tt__IPAddressFilterExtension *Extension;	/* optional element of XSD type tt:IPAddressFilterExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilter (470)
	virtual int soap_type(void) const { return 470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
	virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilter); }
	         tt__IPAddressFilter() { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
	friend SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1377 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (471)
/* Type tt__IPAddressFilterExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IPAddressFilterExtension complex type: */
class SOAP_CMAC tt__IPAddressFilterExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IPAddressFilterExtension (471)
	virtual int soap_type(void) const { return 471; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
	virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW(tt__IPAddressFilterExtension); }
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
	friend SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1380 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (472)
/* Type tt__Dot11Configuration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Configuration complex type: */
class SOAP_CMAC tt__Dot11Configuration : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of XSD type tt:Dot11StationMode */
	char *Alias;	/* required element of XSD type tt:Name */
	char *Priority;	/* required element of XSD type tt:NetworkInterfaceConfigPriority */
	tt__Dot11SecurityConfiguration *Security;	/* required element of XSD type tt:Dot11SecurityConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Configuration (472)
	virtual int soap_type(void) const { return 472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
	virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Configuration); }
	         tt__Dot11Configuration() { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
	friend SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1383 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (473)
/* Type tt__Dot11SecurityConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityConfiguration complex type: */
class SOAP_CMAC tt__Dot11SecurityConfiguration : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of XSD type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of XSD type tt:Dot11Cipher */
	tt__Dot11PSKSet *PSK;	/* optional element of XSD type tt:Dot11PSKSet */
	char *Dot1X;	/* optional element of XSD type tt:ReferenceToken */
	tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot11SecurityConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfiguration (473)
	virtual int soap_type(void) const { return 473; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfiguration); }
	         tt__Dot11SecurityConfiguration() { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1386 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (474)
/* Type tt__Dot11SecurityConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11SecurityConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (474)
	virtual int soap_type(void) const { return 474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11SecurityConfigurationExtension); }
	         tt__Dot11SecurityConfigurationExtension() { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1389 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (475)
/* Type tt__Dot11PSKSet is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKSet complex type: */
class SOAP_CMAC tt__Dot11PSKSet : public xsd__anyType
{
public:
	xsd__hexBinary *Key;	/* optional element of XSD type tt:Dot11PSK */
	char *Passphrase;	/* optional element of XSD type tt:Dot11PSKPassphrase */
	tt__Dot11PSKSetExtension *Extension;	/* optional element of XSD type tt:Dot11PSKSetExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSet (475)
	virtual int soap_type(void) const { return 475; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSet); }
	         tt__Dot11PSKSet() { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
	friend SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1392 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (476)
/* Type tt__Dot11PSKSetExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11PSKSetExtension complex type: */
class SOAP_CMAC tt__Dot11PSKSetExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11PSKSetExtension (476)
	virtual int soap_type(void) const { return 476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
	virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11PSKSetExtension); }
	         tt__Dot11PSKSetExtension() { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
	friend SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1395 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (477)
/* Type tt__NetworkInterfaceSetConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterfaceSetConfigurationExtension2 complex type: */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (477)
	virtual int soap_type(void) const { return 477; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension2); }
	         tt__NetworkInterfaceSetConfigurationExtension2() { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1398 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (478)
/* Type tt__Dot11Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Capabilities complex type: */
class SOAP_CMAC tt__Dot11Capabilities : public xsd__anyType
{
public:
	bool TKIP;	/* required element of XSD type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of XSD type xsd:boolean */
	bool MultipleConfiguration;	/* required element of XSD type xsd:boolean */
	bool AdHocStationMode;	/* required element of XSD type xsd:boolean */
	bool WEP;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Capabilities (478)
	virtual int soap_type(void) const { return 478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
	virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Capabilities); }
	         tt__Dot11Capabilities() { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
	friend SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1401 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (479)
/* Type tt__Dot11Status is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11Status complex type: */
class SOAP_CMAC tt__Dot11Status : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of XSD type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of XSD type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	char *ActiveConfigAlias;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11Status (479)
	virtual int soap_type(void) const { return 479; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
	virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW(tt__Dot11Status); }
	         tt__Dot11Status() { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
	friend SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1404 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (480)
/* Type tt__Dot11AvailableNetworks is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AvailableNetworks complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworks : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of XSD type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of XSD type xsd:string */
	int __sizeAuthAndMangementSuite;	/* sequence of elements <AuthAndMangementSuite> of XSD type tt:Dot11AuthAndMangementSuite */
	enum tt__Dot11AuthAndMangementSuite *AuthAndMangementSuite;
	int __sizePairCipher;	/* sequence of elements <PairCipher> of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *PairCipher;
	int __sizeGroupCipher;	/* sequence of elements <GroupCipher> of XSD type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of XSD type tt:Dot11SignalStrength */
	tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of XSD type tt:Dot11AvailableNetworksExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworks (480)
	virtual int soap_type(void) const { return 480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworks); }
	         tt__Dot11AvailableNetworks() { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1407 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (481)
/* Type tt__Dot11AvailableNetworksExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot11AvailableNetworksExtension complex type: */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot11AvailableNetworksExtension (481)
	virtual int soap_type(void) const { return 481; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
	virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot11AvailableNetworksExtension); }
	         tt__Dot11AvailableNetworksExtension() { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
	friend SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1410 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (482)
/* Type tt__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Capabilities complex type: */
class SOAP_CMAC tt__Capabilities : public xsd__anyType
{
public:
	tt__AnalyticsCapabilities *Analytics;	/* optional element of XSD type tt:AnalyticsCapabilities */
	tt__DeviceCapabilities *Device;	/* optional element of XSD type tt:DeviceCapabilities */
	tt__EventCapabilities *Events;	/* optional element of XSD type tt:EventCapabilities */
	tt__ImagingCapabilities *Imaging;	/* optional element of XSD type tt:ImagingCapabilities */
	tt__MediaCapabilities *Media;	/* optional element of XSD type tt:MediaCapabilities */
	tt__PTZCapabilities *PTZ;	/* optional element of XSD type tt:PTZCapabilities */
	tt__CapabilitiesExtension *Extension;	/* optional element of XSD type tt:CapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Capabilities (482)
	virtual int soap_type(void) const { return 482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
	virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW(tt__Capabilities); }
	         tt__Capabilities() { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
	friend SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1413 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (483)
/* Type tt__CapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilitiesExtension complex type: */
class SOAP_CMAC tt__CapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__DeviceIOCapabilities *DeviceIO;	/* optional element of XSD type tt:DeviceIOCapabilities */
	tt__DisplayCapabilities *Display;	/* optional element of XSD type tt:DisplayCapabilities */
	tt__RecordingCapabilities *Recording;	/* optional element of XSD type tt:RecordingCapabilities */
	tt__SearchCapabilities *Search;	/* optional element of XSD type tt:SearchCapabilities */
	tt__ReplayCapabilities *Replay;	/* optional element of XSD type tt:ReplayCapabilities */
	tt__ReceiverCapabilities *Receiver;	/* optional element of XSD type tt:ReceiverCapabilities */
	tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of XSD type tt:AnalyticsDeviceCapabilities */
	tt__CapabilitiesExtension2 *Extensions;	/* optional element of XSD type tt:CapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension (483)
	virtual int soap_type(void) const { return 483; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension); }
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1416 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (484)
/* Type tt__CapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__CapabilitiesExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CapabilitiesExtension2 (484)
	virtual int soap_type(void) const { return 484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__CapabilitiesExtension2); }
	         tt__CapabilitiesExtension2() { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1419 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (485)
/* Type tt__AnalyticsCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool RuleSupport;	/* required element of XSD type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsCapabilities (485)
	virtual int soap_type(void) const { return 485; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsCapabilities); }
	         tt__AnalyticsCapabilities() { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1422 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (486)
/* Type tt__DeviceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceCapabilities complex type: */
class SOAP_CMAC tt__DeviceCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	tt__NetworkCapabilities *Network;	/* optional element of XSD type tt:NetworkCapabilities */
	tt__SystemCapabilities *System;	/* optional element of XSD type tt:SystemCapabilities */
	tt__IOCapabilities *IO;	/* optional element of XSD type tt:IOCapabilities */
	tt__SecurityCapabilities *Security;	/* optional element of XSD type tt:SecurityCapabilities */
	tt__DeviceCapabilitiesExtension *Extension;	/* optional element of XSD type tt:DeviceCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilities (486)
	virtual int soap_type(void) const { return 486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilities); }
	         tt__DeviceCapabilities() { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1425 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (487)
/* Type tt__DeviceCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceCapabilitiesExtension complex type: */
class SOAP_CMAC tt__DeviceCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceCapabilitiesExtension (487)
	virtual int soap_type(void) const { return 487; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__DeviceCapabilitiesExtension); }
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1428 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (488)
/* Type tt__EventCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventCapabilities complex type: */
class SOAP_CMAC tt__EventCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of XSD type xsd:boolean */
	bool WSPullPointSupport;	/* required element of XSD type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventCapabilities (488)
	virtual int soap_type(void) const { return 488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
	virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__EventCapabilities); }
	         tt__EventCapabilities() { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
	friend SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1431 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (489)
/* Type tt__IOCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilities complex type: */
class SOAP_CMAC tt__IOCapabilities : public xsd__anyType
{
public:
	int *InputConnectors;	/* optional element of XSD type xsd:int */
	int *RelayOutputs;	/* optional element of XSD type xsd:int */
	tt__IOCapabilitiesExtension *Extension;	/* optional element of XSD type tt:IOCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilities (489)
	virtual int soap_type(void) const { return 489; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
	virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilities); }
	         tt__IOCapabilities() { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
	friend SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1434 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (490)
/* Type tt__IOCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilitiesExtension complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *Auxiliary;	/* optional element of XSD type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> of XSD type tt:AuxiliaryData */
	char **AuxiliaryCommands;
	tt__IOCapabilitiesExtension2 *Extension;	/* required element of XSD type tt:IOCapabilitiesExtension2 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension (490)
	virtual int soap_type(void) const { return 490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension); }
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1437 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (491)
/* Type tt__IOCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:IOCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__IOCapabilitiesExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__IOCapabilitiesExtension2 (491)
	virtual int soap_type(void) const { return 491; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__IOCapabilitiesExtension2); }
	         tt__IOCapabilitiesExtension2() { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1440 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (492)
/* Type tt__MediaCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaCapabilities complex type: */
class SOAP_CMAC tt__MediaCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of XSD type tt:RealTimeStreamingCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__MediaCapabilitiesExtension *Extension;	/* optional element of XSD type tt:MediaCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilities (492)
	virtual int soap_type(void) const { return 492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
	virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilities); }
	         tt__MediaCapabilities() { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
	friend SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1443 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (493)
/* Type tt__MediaCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaCapabilitiesExtension complex type: */
class SOAP_CMAC tt__MediaCapabilitiesExtension : public xsd__anyType
{
public:
	tt__ProfileCapabilities *ProfileCapabilities;	/* required element of XSD type tt:ProfileCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaCapabilitiesExtension (493)
	virtual int soap_type(void) const { return 493; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__MediaCapabilitiesExtension); }
	         tt__MediaCapabilitiesExtension() { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1446 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (494)
/* Type tt__RealTimeStreamingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RealTimeStreamingCapabilities complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilities : public xsd__anyType
{
public:
	bool *RTPMulticast;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of XSD type xsd:boolean */
	tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of XSD type tt:RealTimeStreamingCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilities (494)
	virtual int soap_type(void) const { return 494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilities); }
	         tt__RealTimeStreamingCapabilities() { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1449 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (495)
/* Type tt__RealTimeStreamingCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RealTimeStreamingCapabilitiesExtension complex type: */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (495)
	virtual int soap_type(void) const { return 495; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension); }
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1452 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (496)
/* Type tt__ProfileCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ProfileCapabilities complex type: */
class SOAP_CMAC tt__ProfileCapabilities : public xsd__anyType
{
public:
	int MaximumNumberOfProfiles;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ProfileCapabilities (496)
	virtual int soap_type(void) const { return 496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
	virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ProfileCapabilities); }
	         tt__ProfileCapabilities() { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
	friend SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1455 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (497)
/* Type tt__NetworkCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilities complex type: */
class SOAP_CMAC tt__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional element of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional element of XSD type xsd:boolean */
	bool *DynDNS;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilities (497)
	virtual int soap_type(void) const { return 497; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilities); }
	         tt__NetworkCapabilities() { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
	friend SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1458 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (498)
/* Type tt__NetworkCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilitiesExtension complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *Dot11Configuration;	/* optional element of XSD type xsd:boolean */
	tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:NetworkCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension (498)
	virtual int soap_type(void) const { return 498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension); }
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1461 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (499)
/* Type tt__NetworkCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (499)
	virtual int soap_type(void) const { return 499; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__NetworkCapabilitiesExtension2); }
	         tt__NetworkCapabilitiesExtension2() { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1464 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (500)
/* Type tt__SecurityCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilities complex type: */
class SOAP_CMAC tt__SecurityCapabilities : public xsd__anyType
{
public:
	bool TLS1_x002e1;	/* required element of XSD type xsd:boolean */
	bool TLS1_x002e2;	/* required element of XSD type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of XSD type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of XSD type xsd:boolean */
	bool X_x002e509Token;	/* required element of XSD type xsd:boolean */
	bool SAMLToken;	/* required element of XSD type xsd:boolean */
	bool KerberosToken;	/* required element of XSD type xsd:boolean */
	bool RELToken;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__SecurityCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilities (500)
	virtual int soap_type(void) const { return 500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilities); }
	         tt__SecurityCapabilities() { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
	friend SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1467 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (501)
/* Type tt__SecurityCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension : public xsd__anyType
{
public:
	bool TLS1_x002e0;	/* required element of XSD type xsd:boolean */
	tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SecurityCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension (501)
	virtual int soap_type(void) const { return 501; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension); }
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1470 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (502)
/* Type tt__SecurityCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SecurityCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2 : public xsd__anyType
{
public:
	bool Dot1X;	/* required element of XSD type xsd:boolean */
	int __sizeSupportedEAPMethod;	/* sequence of elements <SupportedEAPMethod> of XSD type xsd:int */
	int *SupportedEAPMethod;
	bool RemoteUserHandling;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (502)
	virtual int soap_type(void) const { return 502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SecurityCapabilitiesExtension2); }
	         tt__SecurityCapabilitiesExtension2() { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1473 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (503)
/* Type tt__SystemCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilities complex type: */
class SOAP_CMAC tt__SystemCapabilities : public xsd__anyType
{
public:
	bool DiscoveryResolve;	/* required element of XSD type xsd:boolean */
	bool DiscoveryBye;	/* required element of XSD type xsd:boolean */
	bool RemoteDiscovery;	/* required element of XSD type xsd:boolean */
	bool SystemBackup;	/* required element of XSD type xsd:boolean */
	bool SystemLogging;	/* required element of XSD type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of XSD type xsd:boolean */
	int __sizeSupportedVersions;	/* sequence of elements <SupportedVersions> of XSD type tt:OnvifVersion */
	tt__OnvifVersion **SupportedVersions;
	tt__SystemCapabilitiesExtension *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilities (503)
	virtual int soap_type(void) const { return 503; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
	virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilities); }
	         tt__SystemCapabilities() { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
	friend SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1476 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (504)
/* Type tt__SystemCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilitiesExtension complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *HttpFirmwareUpgrade;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of XSD type xsd:boolean */
	tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of XSD type tt:SystemCapabilitiesExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension (504)
	virtual int soap_type(void) const { return 504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension); }
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1479 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (505)
/* Type tt__SystemCapabilitiesExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemCapabilitiesExtension2 complex type: */
class SOAP_CMAC tt__SystemCapabilitiesExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemCapabilitiesExtension2 (505)
	virtual int soap_type(void) const { return 505; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
	virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__SystemCapabilitiesExtension2); }
	         tt__SystemCapabilitiesExtension2() { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
	friend SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1482 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (506)
/* Type tt__OnvifVersion is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OnvifVersion complex type: */
class SOAP_CMAC tt__OnvifVersion : public xsd__anyType
{
public:
	int Major;	/* required element of XSD type xsd:int */
	int Minor;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OnvifVersion (506)
	virtual int soap_type(void) const { return 506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
	virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW(tt__OnvifVersion); }
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
	friend SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1485 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (507)
/* Type tt__ImagingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingCapabilities complex type: */
class SOAP_CMAC tt__ImagingCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingCapabilities (507)
	virtual int soap_type(void) const { return 507; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
	virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ImagingCapabilities); }
	         tt__ImagingCapabilities() { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
	friend SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1488 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (508)
/* Type tt__PTZCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZCapabilities complex type: */
class SOAP_CMAC tt__PTZCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZCapabilities (508)
	virtual int soap_type(void) const { return 508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
	virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__PTZCapabilities); }
	         tt__PTZCapabilities() { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
	friend SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1491 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (509)
/* Type tt__DeviceIOCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DeviceIOCapabilities complex type: */
class SOAP_CMAC tt__DeviceIOCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	int VideoSources;	/* required element of XSD type xsd:int */
	int VideoOutputs;	/* required element of XSD type xsd:int */
	int AudioSources;	/* required element of XSD type xsd:int */
	int AudioOutputs;	/* required element of XSD type xsd:int */
	int RelayOutputs;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DeviceIOCapabilities (509)
	virtual int soap_type(void) const { return 509; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
	virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DeviceIOCapabilities); }
	         tt__DeviceIOCapabilities() { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
	friend SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1494 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (510)
/* Type tt__DisplayCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DisplayCapabilities complex type: */
class SOAP_CMAC tt__DisplayCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool FixedLayout;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DisplayCapabilities (510)
	virtual int soap_type(void) const { return 510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
	virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__DisplayCapabilities); }
	         tt__DisplayCapabilities() { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
	friend SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1497 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (511)
/* Type tt__RecordingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingCapabilities complex type: */
class SOAP_CMAC tt__RecordingCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool ReceiverSource;	/* required element of XSD type xsd:boolean */
	bool MediaProfileSource;	/* required element of XSD type xsd:boolean */
	bool DynamicRecordings;	/* required element of XSD type xsd:boolean */
	bool DynamicTracks;	/* required element of XSD type xsd:boolean */
	int MaxStringLength;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingCapabilities (511)
	virtual int soap_type(void) const { return 511; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
	virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__RecordingCapabilities); }
	         tt__RecordingCapabilities() { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
	friend SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1500 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (512)
/* Type tt__SearchCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchCapabilities complex type: */
class SOAP_CMAC tt__SearchCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool MetadataSearch;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchCapabilities (512)
	virtual int soap_type(void) const { return 512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
	virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__SearchCapabilities); }
	         tt__SearchCapabilities() { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
	friend SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1503 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (513)
/* Type tt__ReplayCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReplayCapabilities complex type: */
class SOAP_CMAC tt__ReplayCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayCapabilities (513)
	virtual int soap_type(void) const { return 513; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
	virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReplayCapabilities); }
	         tt__ReplayCapabilities() { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
	friend SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1506 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (514)
/* Type tt__ReceiverCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverCapabilities complex type: */
class SOAP_CMAC tt__ReceiverCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of XSD type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of XSD type xsd:boolean */
	int SupportedReceivers;	/* required element of XSD type xsd:int */
	int MaximumRTSPURILength;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverCapabilities (514)
	virtual int soap_type(void) const { return 514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
	virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverCapabilities); }
	         tt__ReceiverCapabilities() { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
	friend SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1509 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (515)
/* Type tt__AnalyticsDeviceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceCapabilities complex type: */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities : public xsd__anyType
{
public:
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	bool *RuleSupport;	/* optional element of XSD type xsd:boolean */
	tt__AnalyticsDeviceExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceCapabilities (515)
	virtual int soap_type(void) const { return 515; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceCapabilities); }
	         tt__AnalyticsDeviceCapabilities() { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1512 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (516)
/* Type tt__AnalyticsDeviceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceExtension (516)
	virtual int soap_type(void) const { return 516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceExtension); }
	         tt__AnalyticsDeviceExtension() { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1515 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (517)
/* Type tt__SystemLog is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLog complex type: */
class SOAP_CMAC tt__SystemLog : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	char *String;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLog (517)
	virtual int soap_type(void) const { return 517; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
	virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW(tt__SystemLog); }
	         tt__SystemLog() { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
	friend SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1518 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (518)
/* Type tt__SupportInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportInformation complex type: */
class SOAP_CMAC tt__SupportInformation : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of XSD type tt:AttachmentData */
	char *String;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportInformation (518)
	virtual int soap_type(void) const { return 518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
	virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW(tt__SupportInformation); }
	         tt__SupportInformation() { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
	friend SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1521 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (519)
/* Type tt__BinaryData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BinaryData complex type: */
class SOAP_CMAC tt__BinaryData : public xsd__anyType
{
public:
	xsd__base64Binary Data;	/* required element of XSD type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BinaryData (519)
	virtual int soap_type(void) const { return 519; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
	virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW(tt__BinaryData); }
	         tt__BinaryData() { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
	friend SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1524 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (520)
/* Type tt__AttachmentData is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AttachmentData complex type: */
class SOAP_CMAC tt__AttachmentData : public xsd__anyType
{
public:
	struct _xop__Include xop__Include;	/* required element of XSD type xop:Include */
	char *xmime__contentType;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AttachmentData (520)
	virtual int soap_type(void) const { return 520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
	virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW(tt__AttachmentData); }
	         tt__AttachmentData() { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
	friend SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1527 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (521)
/* Type tt__BackupFile is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BackupFile complex type: */
class SOAP_CMAC tt__BackupFile : public xsd__anyType
{
public:
	char *Name;	/* required element of XSD type xsd:string */
	tt__AttachmentData *Data;	/* required element of XSD type tt:AttachmentData */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BackupFile (521)
	virtual int soap_type(void) const { return 521; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
	virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW(tt__BackupFile); }
	         tt__BackupFile() { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
	friend SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1530 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (522)
/* Type tt__SystemLogUriList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogUriList complex type: */
class SOAP_CMAC tt__SystemLogUriList : public xsd__anyType
{
public:
	int __sizeSystemLog;	/* sequence of elements <SystemLog> of XSD type tt:SystemLogUri */
	tt__SystemLogUri **SystemLog;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUriList (522)
	virtual int soap_type(void) const { return 522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
	virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUriList); }
	         tt__SystemLogUriList() { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
	friend SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1533 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (523)
/* Type tt__SystemLogUri is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemLogUri complex type: */
class SOAP_CMAC tt__SystemLogUri : public xsd__anyType
{
public:
	enum tt__SystemLogType Type;	/* required element of XSD type tt:SystemLogType */
	char *Uri;	/* required element of XSD type xsd:anyURI */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemLogUri (523)
	virtual int soap_type(void) const { return 523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
	virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW(tt__SystemLogUri); }
	         tt__SystemLogUri() { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
	friend SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1536 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (524)
/* Type tt__SystemDateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemDateTime complex type: */
class SOAP_CMAC tt__SystemDateTime : public xsd__anyType
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of XSD type tt:DateTime */
	tt__SystemDateTimeExtension *Extension;	/* optional element of XSD type tt:SystemDateTimeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTime (524)
	virtual int soap_type(void) const { return 524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
	virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTime); }
	         tt__SystemDateTime() { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
	friend SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1539 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (525)
/* Type tt__SystemDateTimeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SystemDateTimeExtension complex type: */
class SOAP_CMAC tt__SystemDateTimeExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SystemDateTimeExtension (525)
	virtual int soap_type(void) const { return 525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
	virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SystemDateTimeExtension); }
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
	friend SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1542 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (526)
/* Type tt__DateTime is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DateTime complex type: */
class SOAP_CMAC tt__DateTime : public xsd__anyType
{
public:
	tt__Time *Time;	/* required element of XSD type tt:Time */
	tt__Date *Date;	/* required element of XSD type tt:Date */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTime (526)
	virtual int soap_type(void) const { return 526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
	virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW(tt__DateTime); }
	         tt__DateTime() { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
	friend SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1545 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (527)
/* Type tt__Date is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Date complex type: */
class SOAP_CMAC tt__Date : public xsd__anyType
{
public:
	int Year;	/* required element of XSD type xsd:int */
	int Month;	/* required element of XSD type xsd:int */
	int Day;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Date (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Date, default initialized and not managed by a soap context
	virtual tt__Date *soap_alloc(void) const { return SOAP_NEW(tt__Date); }
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
	friend SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1548 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (528)
/* Type tt__Time is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Time complex type: */
class SOAP_CMAC tt__Time : public xsd__anyType
{
public:
	int Hour;	/* required element of XSD type xsd:int */
	int Minute;	/* required element of XSD type xsd:int */
	int Second;	/* required element of XSD type xsd:int */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Time (528)
	virtual int soap_type(void) const { return 528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Time, default initialized and not managed by a soap context
	virtual tt__Time *soap_alloc(void) const { return SOAP_NEW(tt__Time); }
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
	friend SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1551 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (529)
/* Type tt__TimeZone is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TimeZone complex type: */
class SOAP_CMAC tt__TimeZone : public xsd__anyType
{
public:
	char *TZ;	/* required element of XSD type xsd:token */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TimeZone (529)
	virtual int soap_type(void) const { return 529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
	virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW(tt__TimeZone); }
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
	friend SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1554 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (530)
/* Type tt__RemoteUser is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RemoteUser complex type: */
class SOAP_CMAC tt__RemoteUser : public xsd__anyType
{
public:
	char *Username;	/* required element of XSD type xsd:string */
	char *Password;	/* optional element of XSD type xsd:string */
	bool UseDerivedPassword;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RemoteUser (530)
	virtual int soap_type(void) const { return 530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
	virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW(tt__RemoteUser); }
	         tt__RemoteUser() { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
	friend SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1557 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (531)
/* Type tt__User is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:User complex type: */
class SOAP_CMAC tt__User : public xsd__anyType
{
public:
	char *Username;	/* required element of XSD type xsd:string */
	char *Password;	/* optional element of XSD type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of XSD type tt:UserLevel */
	tt__UserExtension *Extension;	/* optional element of XSD type tt:UserExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__User (531)
	virtual int soap_type(void) const { return 531; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__User, default initialized and not managed by a soap context
	virtual tt__User *soap_alloc(void) const { return SOAP_NEW(tt__User); }
	         tt__User() { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
	friend SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1560 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (532)
/* Type tt__UserExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:UserExtension complex type: */
class SOAP_CMAC tt__UserExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__UserExtension (532)
	virtual int soap_type(void) const { return 532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
	virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW(tt__UserExtension); }
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
	friend SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1563 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (533)
/* Type tt__CertificateGenerationParameters is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateGenerationParameters complex type: */
class SOAP_CMAC tt__CertificateGenerationParameters : public xsd__anyType
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	char *ValidNotBefore;	/* optional element of XSD type xsd:token */
	char *ValidNotAfter;	/* optional element of XSD type xsd:token */
	tt__CertificateGenerationParametersExtension *Extension;	/* optional element of XSD type tt:CertificateGenerationParametersExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParameters (533)
	virtual int soap_type(void) const { return 533; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParameters, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParameters); }
	         tt__CertificateGenerationParameters() { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1566 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (534)
/* Type tt__CertificateGenerationParametersExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateGenerationParametersExtension complex type: */
class SOAP_CMAC tt__CertificateGenerationParametersExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateGenerationParametersExtension (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
	virtual tt__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateGenerationParametersExtension); }
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
	friend SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1569 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (535)
/* Type tt__Certificate is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Certificate complex type: */
class SOAP_CMAC tt__Certificate : public xsd__anyType
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Certificate (535)
	virtual int soap_type(void) const { return 535; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
	virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW(tt__Certificate); }
	         tt__Certificate() { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
	friend SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1572 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (536)
/* Type tt__CertificateStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateStatus complex type: */
class SOAP_CMAC tt__CertificateStatus : public xsd__anyType
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	bool Status;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateStatus (536)
	virtual int soap_type(void) const { return 536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
	virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW(tt__CertificateStatus); }
	         tt__CertificateStatus() { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
	friend SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1575 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (537)
/* Type tt__CertificateWithPrivateKey is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateWithPrivateKey complex type: */
class SOAP_CMAC tt__CertificateWithPrivateKey : public xsd__anyType
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	tt__BinaryData *Certificate;	/* required element of XSD type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of XSD type tt:BinaryData */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateWithPrivateKey (537)
	virtual int soap_type(void) const { return 537; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(tt__CertificateWithPrivateKey); }
	         tt__CertificateWithPrivateKey() { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
	friend SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1578 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (538)
/* Type tt__CertificateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateInformation complex type: */
class SOAP_CMAC tt__CertificateInformation : public xsd__anyType
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	char *IssuerDN;	/* optional element of XSD type xsd:string */
	char *SubjectDN;	/* optional element of XSD type xsd:string */
	tt__CertificateUsage *KeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of XSD type tt:CertificateUsage */
	int *KeyLength;	/* optional element of XSD type xsd:int */
	char *Version;	/* optional element of XSD type xsd:string */
	char *SerialNum;	/* optional element of XSD type xsd:string */
	char *SignatureAlgorithm;	/* optional element of XSD type xsd:string */
	tt__DateTimeRange *Validity;	/* optional element of XSD type tt:DateTimeRange */
	tt__CertificateInformationExtension *Extension;	/* optional element of XSD type tt:CertificateInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformation (538)
	virtual int soap_type(void) const { return 538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
	virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformation); }
	         tt__CertificateInformation() { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
	friend SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1584 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (540)
/* Type tt__CertificateInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateInformationExtension complex type: */
class SOAP_CMAC tt__CertificateInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateInformationExtension (540)
	virtual int soap_type(void) const { return 540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
	virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__CertificateInformationExtension); }
	         tt__CertificateInformationExtension() { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
	friend SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1587 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (541)
/* Type tt__Dot1XConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot1XConfiguration complex type: */
class SOAP_CMAC tt__Dot1XConfiguration : public xsd__anyType
{
public:
	char *Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	char *Identity;	/* required element of XSD type xsd:string */
	char *AnonymousID;	/* optional element of XSD type xsd:string */
	int EAPMethod;	/* required element of XSD type xsd:int */
	int __sizeCACertificateID;	/* sequence of elements <CACertificateID> of XSD type xsd:token */
	char **CACertificateID;
	tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of XSD type tt:EAPMethodConfiguration */
	tt__Dot1XConfigurationExtension *Extension;	/* optional element of XSD type tt:Dot1XConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfiguration (541)
	virtual int soap_type(void) const { return 541; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
	virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfiguration); }
	         tt__Dot1XConfiguration() { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
	friend SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1590 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (542)
/* Type tt__Dot1XConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Dot1XConfigurationExtension complex type: */
class SOAP_CMAC tt__Dot1XConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Dot1XConfigurationExtension (542)
	virtual int soap_type(void) const { return 542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__Dot1XConfigurationExtension); }
	         tt__Dot1XConfigurationExtension() { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
	friend SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1593 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (543)
/* Type tt__EAPMethodConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EAPMethodConfiguration complex type: */
class SOAP_CMAC tt__EAPMethodConfiguration : public xsd__anyType
{
public:
	tt__TLSConfiguration *TLSConfiguration;	/* optional element of XSD type tt:TLSConfiguration */
	char *Password;	/* optional element of XSD type xsd:string */
	tt__EapMethodExtension *Extension;	/* optional element of XSD type tt:EapMethodExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EAPMethodConfiguration (543)
	virtual int soap_type(void) const { return 543; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
	virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EAPMethodConfiguration); }
	         tt__EAPMethodConfiguration() { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
	friend SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1596 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (544)
/* Type tt__EapMethodExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EapMethodExtension complex type: */
class SOAP_CMAC tt__EapMethodExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EapMethodExtension (544)
	virtual int soap_type(void) const { return 544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
	virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW(tt__EapMethodExtension); }
	         tt__EapMethodExtension() { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
	friend SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1599 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (545)
/* Type tt__TLSConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TLSConfiguration complex type: */
class SOAP_CMAC tt__TLSConfiguration : public xsd__anyType
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TLSConfiguration (545)
	virtual int soap_type(void) const { return 545; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
	virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TLSConfiguration); }
	         tt__TLSConfiguration() { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
	friend SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1602 */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (546)
/* Type tt__GenericEapPwdConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GenericEapPwdConfigurationExtension complex type: */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (546)
	virtual int soap_type(void) const { return 546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__GenericEapPwdConfigurationExtension); }
	         tt__GenericEapPwdConfigurationExtension() { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
	friend SOAP_FMAC1 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1605 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (547)
/* Type tt__RelayOutputSettings is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutputSettings complex type: */
class SOAP_CMAC tt__RelayOutputSettings : public xsd__anyType
{
public:
	enum tt__RelayMode Mode;	/* required element of XSD type tt:RelayMode */
	LONG64 DelayTime;	/* external (custom serializer) */
	enum tt__RelayIdleState IdleState;	/* required element of XSD type tt:RelayIdleState */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutputSettings (547)
	virtual int soap_type(void) const { return 547; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
	virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutputSettings); }
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
	friend SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1617 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (551)
/* Type tt__PTZNodeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNodeExtension complex type: */
class SOAP_CMAC tt__PTZNodeExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__PTZPresetTourSupported *SupportedPresetTour;	/* required element of XSD type tt:PTZPresetTourSupported */
	tt__PTZNodeExtension2 *Extension;	/* optional element of XSD type tt:PTZNodeExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension (551)
	virtual int soap_type(void) const { return 551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension); }
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1620 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (552)
/* Type tt__PTZNodeExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNodeExtension2 complex type: */
class SOAP_CMAC tt__PTZNodeExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNodeExtension2 (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
	virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZNodeExtension2); }
	         tt__PTZNodeExtension2() { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
	friend SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1623 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (553)
/* Type tt__PTZPresetTourSupported is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSupported complex type: */
class SOAP_CMAC tt__PTZPresetTourSupported : public xsd__anyType
{
public:
	int MaximumNumberOfPresetTours;	/* required element of XSD type xsd:int */
	int __sizePTZPresetTourOperation;	/* sequence of elements <PTZPresetTourOperation> of XSD type tt:PTZPresetTourOperation */
	enum tt__PTZPresetTourOperation *PTZPresetTourOperation;
	tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSupportedExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupported (553)
	virtual int soap_type(void) const { return 553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupported); }
	         tt__PTZPresetTourSupported() { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1626 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (554)
/* Type tt__PTZPresetTourSupportedExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSupportedExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSupportedExtension (554)
	virtual int soap_type(void) const { return 554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSupportedExtension); }
	         tt__PTZPresetTourSupportedExtension() { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1632 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (556)
/* Type tt__PTZConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationExtension complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__PTControlDirection *PTControlDirection;	/* optional element of XSD type tt:PTControlDirection */
	tt__PTZConfigurationExtension2 *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension (556)
	virtual int soap_type(void) const { return 556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension); }
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1635 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (557)
/* Type tt__PTZConfigurationExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationExtension2 complex type: */
class SOAP_CMAC tt__PTZConfigurationExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationExtension2 (557)
	virtual int soap_type(void) const { return 557; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationExtension2); }
	         tt__PTZConfigurationExtension2() { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1638 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (558)
/* Type tt__PTControlDirection is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirection complex type: */
class SOAP_CMAC tt__PTControlDirection : public xsd__anyType
{
public:
	tt__EFlip *EFlip;	/* optional element of XSD type tt:EFlip */
	tt__Reverse *Reverse;	/* optional element of XSD type tt:Reverse */
	tt__PTControlDirectionExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirection (558)
	virtual int soap_type(void) const { return 558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
	virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirection); }
	         tt__PTControlDirection() { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
	friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1641 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (559)
/* Type tt__PTControlDirectionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionExtension (559)
	virtual int soap_type(void) const { return 559; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionExtension); }
	         tt__PTControlDirectionExtension() { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1644 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (560)
/* Type tt__EFlip is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlip complex type: */
class SOAP_CMAC tt__EFlip : public xsd__anyType
{
public:
	enum tt__EFlipMode Mode;	/* required element of XSD type tt:EFlipMode */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlip (560)
	virtual int soap_type(void) const { return 560; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
	virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW(tt__EFlip); }
	         tt__EFlip() { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
	friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1647 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (561)
/* Type tt__Reverse is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Reverse complex type: */
class SOAP_CMAC tt__Reverse : public xsd__anyType
{
public:
	enum tt__ReverseMode Mode;	/* required element of XSD type tt:ReverseMode */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Reverse (561)
	virtual int soap_type(void) const { return 561; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
	virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW(tt__Reverse); }
	         tt__Reverse() { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
	friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1650 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (562)
/* Type tt__PTZConfigurationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationOptions complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions : public xsd__anyType
{
public:
	tt__PTZSpaces *Spaces;	/* required element of XSD type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of XSD type tt:DurationRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of XSD type tt:PTControlDirectionOptions */
	tt__PTZConfigurationOptions2 *Extension;	/* optional element of XSD type tt:PTZConfigurationOptions2 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions (562)
	virtual int soap_type(void) const { return 562; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions); }
	         tt__PTZConfigurationOptions() { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1653 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (563)
/* Type tt__PTZConfigurationOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfigurationOptions2 complex type: */
class SOAP_CMAC tt__PTZConfigurationOptions2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfigurationOptions2 (563)
	virtual int soap_type(void) const { return 563; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
	virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfigurationOptions2); }
	         tt__PTZConfigurationOptions2() { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
	friend SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1656 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (564)
/* Type tt__PTControlDirectionOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionOptions complex type: */
class SOAP_CMAC tt__PTControlDirectionOptions : public xsd__anyType
{
public:
	tt__EFlipOptions *EFlip;	/* optional element of XSD type tt:EFlipOptions */
	tt__ReverseOptions *Reverse;	/* optional element of XSD type tt:ReverseOptions */
	tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of XSD type tt:PTControlDirectionOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptions (564)
	virtual int soap_type(void) const { return 564; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptions); }
	         tt__PTControlDirectionOptions() { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1659 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (565)
/* Type tt__PTControlDirectionOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTControlDirectionOptionsExtension complex type: */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTControlDirectionOptionsExtension (565)
	virtual int soap_type(void) const { return 565; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTControlDirectionOptionsExtension); }
	         tt__PTControlDirectionOptionsExtension() { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1662 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (566)
/* Type tt__EFlipOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipOptions complex type: */
class SOAP_CMAC tt__EFlipOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:EFlipMode */
	enum tt__EFlipMode *Mode;
	tt__EFlipOptionsExtension *Extension;	/* optional element of XSD type tt:EFlipOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptions (566)
	virtual int soap_type(void) const { return 566; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
	virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptions); }
	         tt__EFlipOptions() { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
	friend SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1665 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (567)
/* Type tt__EFlipOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EFlipOptionsExtension complex type: */
class SOAP_CMAC tt__EFlipOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EFlipOptionsExtension (567)
	virtual int soap_type(void) const { return 567; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
	virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__EFlipOptionsExtension); }
	         tt__EFlipOptionsExtension() { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
	friend SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1668 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (568)
/* Type tt__ReverseOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseOptions complex type: */
class SOAP_CMAC tt__ReverseOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ReverseMode */
	enum tt__ReverseMode *Mode;
	tt__ReverseOptionsExtension *Extension;	/* optional element of XSD type tt:ReverseOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptions (568)
	virtual int soap_type(void) const { return 568; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
	virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptions); }
	         tt__ReverseOptions() { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
	friend SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1671 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (569)
/* Type tt__ReverseOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReverseOptionsExtension complex type: */
class SOAP_CMAC tt__ReverseOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReverseOptionsExtension (569)
	virtual int soap_type(void) const { return 569; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ReverseOptionsExtension); }
	         tt__ReverseOptionsExtension() { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
	friend SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1674 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (570)
/* Type tt__PanTiltLimits is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PanTiltLimits complex type: */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType
{
public:
	tt__Space2DDescription *Range;	/* required element of XSD type tt:Space2DDescription */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PanTiltLimits (570)
	virtual int soap_type(void) const { return 570; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
	virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW(tt__PanTiltLimits); }
	         tt__PanTiltLimits() { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
	friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1677 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (571)
/* Type tt__ZoomLimits is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ZoomLimits complex type: */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType
{
public:
	tt__Space1DDescription *Range;	/* required element of XSD type tt:Space1DDescription */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ZoomLimits (571)
	virtual int soap_type(void) const { return 571; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
	virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW(tt__ZoomLimits); }
	         tt__ZoomLimits() { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
	friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1680 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (572)
/* Type tt__PTZSpaces is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpaces complex type: */
class SOAP_CMAC tt__PTZSpaces : public xsd__anyType
{
public:
	int __sizeAbsolutePanTiltPositionSpace;	/* sequence of elements <AbsolutePanTiltPositionSpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **AbsolutePanTiltPositionSpace;
	int __sizeAbsoluteZoomPositionSpace;	/* sequence of elements <AbsoluteZoomPositionSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **AbsoluteZoomPositionSpace;
	int __sizeRelativePanTiltTranslationSpace;	/* sequence of elements <RelativePanTiltTranslationSpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **RelativePanTiltTranslationSpace;
	int __sizeRelativeZoomTranslationSpace;	/* sequence of elements <RelativeZoomTranslationSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **RelativeZoomTranslationSpace;
	int __sizeContinuousPanTiltVelocitySpace;	/* sequence of elements <ContinuousPanTiltVelocitySpace> of XSD type tt:Space2DDescription */
	tt__Space2DDescription **ContinuousPanTiltVelocitySpace;
	int __sizeContinuousZoomVelocitySpace;	/* sequence of elements <ContinuousZoomVelocitySpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **ContinuousZoomVelocitySpace;
	int __sizePanTiltSpeedSpace;	/* sequence of elements <PanTiltSpeedSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **PanTiltSpeedSpace;
	int __sizeZoomSpeedSpace;	/* sequence of elements <ZoomSpeedSpace> of XSD type tt:Space1DDescription */
	tt__Space1DDescription **ZoomSpeedSpace;
	tt__PTZSpacesExtension *Extension;	/* optional element of XSD type tt:PTZSpacesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpaces (572)
	virtual int soap_type(void) const { return 572; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
	virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpaces); }
	         tt__PTZSpaces() { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
	friend SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1683 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (573)
/* Type tt__PTZSpacesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpacesExtension complex type: */
class SOAP_CMAC tt__PTZSpacesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpacesExtension (573)
	virtual int soap_type(void) const { return 573; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
	virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpacesExtension); }
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
	friend SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1686 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (574)
/* Type tt__Space2DDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Space2DDescription complex type: */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType
{
public:
	char *URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space2DDescription (574)
	virtual int soap_type(void) const { return 574; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
	virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space2DDescription); }
	         tt__Space2DDescription() { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
	friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1689 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (575)
/* Type tt__Space1DDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Space1DDescription complex type: */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType
{
public:
	char *URI;	/* required element of XSD type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Space1DDescription (575)
	virtual int soap_type(void) const { return 575; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
	virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW(tt__Space1DDescription); }
	         tt__Space1DDescription() { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
	friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1692 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (576)
/* Type tt__Vector2D is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector2D simple type: */
class SOAP_CMAC tt__Vector2D : public xsd__anyType
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	float y;	/* required attribute of XSD type xsd:float */
	char *space;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector2D (576)
	virtual int soap_type(void) const { return 576; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
	virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW(tt__Vector2D); }
	         tt__Vector2D() { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
	friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1695 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (577)
/* Type tt__Vector1D is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector1D simple type: */
class SOAP_CMAC tt__Vector1D : public xsd__anyType
{
public:
	float x;	/* required attribute of XSD type xsd:float */
	char *space;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector1D (577)
	virtual int soap_type(void) const { return 577; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
	virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW(tt__Vector1D); }
	         tt__Vector1D() { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
	friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1698 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (578)
/* Type tt__PTZVector is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZVector complex type: */
class SOAP_CMAC tt__PTZVector : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZVector (578)
	virtual int soap_type(void) const { return 578; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
	virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW(tt__PTZVector); }
	         tt__PTZVector() { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
	friend SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1701 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (579)
/* Type tt__PTZSpeed is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZSpeed complex type: */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of XSD type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of XSD type tt:Vector1D */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZSpeed (579)
	virtual int soap_type(void) const { return 579; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
	virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW(tt__PTZSpeed); }
	         tt__PTZSpeed() { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
	friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1704 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (580)
/* Type tt__PTZStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStatus complex type: */
class SOAP_CMAC tt__PTZStatus : public xsd__anyType
{
public:
	tt__PTZVector *Position;	/* optional element of XSD type tt:PTZVector */
	tt__PTZMoveStatus *MoveStatus;	/* optional element of XSD type tt:PTZMoveStatus */
	char *Error;	/* optional element of XSD type xsd:string */
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStatus (580)
	virtual int soap_type(void) const { return 580; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
	virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZStatus); }
	         tt__PTZStatus() { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
	friend SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1707 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (581)
/* Type tt__PTZPreset is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPreset complex type: */
class SOAP_CMAC tt__PTZPreset : public xsd__anyType
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of XSD type tt:PTZVector */
	char *token;	/* optional attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPreset (581)
	virtual int soap_type(void) const { return 581; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
	virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW(tt__PTZPreset); }
	         tt__PTZPreset() { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
	friend SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1710 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (582)
/* Type tt__PTZMoveStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZMoveStatus complex type: */
class SOAP_CMAC tt__PTZMoveStatus : public xsd__anyType
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of XSD type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of XSD type tt:MoveStatus */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZMoveStatus (582)
	virtual int soap_type(void) const { return 582; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
	virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZMoveStatus); }
	         tt__PTZMoveStatus() { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
	friend SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1713 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (583)
/* Type tt__PresetTour is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PresetTour complex type: */
class SOAP_CMAC tt__PresetTour : public xsd__anyType
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZPresetTourStatus *Status;	/* required element of XSD type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingCondition */
	int __sizeTourSpot;	/* sequence of elements <TourSpot> of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourSpot **TourSpot;
	tt__PTZPresetTourExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourExtension */
	char *token;	/* optional attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PresetTour (583)
	virtual int soap_type(void) const { return 583; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
	virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW(tt__PresetTour); }
	         tt__PresetTour() { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
	friend SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1716 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (584)
/* Type tt__PTZPresetTourExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourExtension (584)
	virtual int soap_type(void) const { return 584; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourExtension); }
	         tt__PTZPresetTourExtension() { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1719 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (585)
/* Type tt__PTZPresetTourSpot is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpot complex type: */
class SOAP_CMAC tt__PTZPresetTourSpot : public xsd__anyType
{
public:
	tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *StayTime;	/* optional element of XSD type xsd:duration */
	tt__PTZPresetTourSpotExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourSpotExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpot (585)
	virtual int soap_type(void) const { return 585; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpot); }
	         tt__PTZPresetTourSpot() { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1722 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (586)
/* Type tt__PTZPresetTourSpotExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpotExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotExtension (586)
	virtual int soap_type(void) const { return 586; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotExtension); }
	         tt__PTZPresetTourSpotExtension() { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:18701 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1850)
/* xsd:choice complex type: */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	char *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* ../../wsdl/onvif.h:1725 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (587)
/* Type tt__PTZPresetTourPresetDetail is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetail complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetail : public xsd__anyType
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetail (587)
	virtual int soap_type(void) const { return 587; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetail); }
	         tt__PTZPresetTourPresetDetail() { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1728 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (588)
/* Type tt__PTZPresetTourTypeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourTypeExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourTypeExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourTypeExtension (588)
	virtual int soap_type(void) const { return 588; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourTypeExtension); }
	         tt__PTZPresetTourTypeExtension() { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1731 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (589)
/* Type tt__PTZPresetTourStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStatus complex type: */
class SOAP_CMAC tt__PTZPresetTourStatus : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState State;	/* required element of XSD type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of XSD type tt:PTZPresetTourSpot */
	tt__PTZPresetTourStatusExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStatusExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatus (589)
	virtual int soap_type(void) const { return 589; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatus); }
	         tt__PTZPresetTourStatus() { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1734 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (590)
/* Type tt__PTZPresetTourStatusExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStatusExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStatusExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStatusExtension (590)
	virtual int soap_type(void) const { return 590; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStatusExtension); }
	         tt__PTZPresetTourStatusExtension() { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1737 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (591)
/* Type tt__PTZPresetTourStartingCondition is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingCondition complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingCondition : public xsd__anyType
{
public:
	int *RecurringTime;	/* optional element of XSD type xsd:int */
	LONG64 *RecurringDuration;	/* optional element of XSD type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of XSD type tt:PTZPresetTourDirection */
	tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingCondition (591)
	virtual int soap_type(void) const { return 591; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingCondition); }
	         tt__PTZPresetTourStartingCondition() { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1740 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (592)
/* Type tt__PTZPresetTourStartingConditionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (592)
	virtual int soap_type(void) const { return 592; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionExtension); }
	         tt__PTZPresetTourStartingConditionExtension() { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1743 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (593)
/* Type tt__PTZPresetTourOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourOptions : public xsd__anyType
{
public:
	bool AutoStart;	/* required element of XSD type xsd:boolean */
	tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of XSD type tt:PTZPresetTourStartingConditionOptions */
	tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of XSD type tt:PTZPresetTourSpotOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourOptions (593)
	virtual int soap_type(void) const { return 593; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourOptions); }
	         tt__PTZPresetTourOptions() { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1746 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (594)
/* Type tt__PTZPresetTourSpotOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourSpotOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourSpotOptions : public xsd__anyType
{
public:
	tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of XSD type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of XSD type tt:DurationRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourSpotOptions (594)
	virtual int soap_type(void) const { return 594; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourSpotOptions); }
	         tt__PTZPresetTourSpotOptions() { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1749 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (595)
/* Type tt__PTZPresetTourPresetDetailOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetailOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions : public xsd__anyType
{
public:
	int __sizePresetToken;	/* sequence of elements <PresetToken> of XSD type tt:ReferenceToken */
	char **PresetToken;
	bool *Home;	/* optional element of XSD type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of XSD type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of XSD type tt:Space1DDescription */
	tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourPresetDetailOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (595)
	virtual int soap_type(void) const { return 595; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptions); }
	         tt__PTZPresetTourPresetDetailOptions() { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1752 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (596)
/* Type tt__PTZPresetTourPresetDetailOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourPresetDetailOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (596)
	virtual int soap_type(void) const { return 596; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourPresetDetailOptionsExtension); }
	         tt__PTZPresetTourPresetDetailOptionsExtension() { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1755 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (597)
/* Type tt__PTZPresetTourStartingConditionOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionOptions complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions : public xsd__anyType
{
public:
	tt__IntRange *RecurringTime;	/* optional element of XSD type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of XSD type tt:DurationRange */
	int __sizeDirection;	/* sequence of elements <Direction> of XSD type tt:PTZPresetTourDirection */
	enum tt__PTZPresetTourDirection *Direction;
	tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of XSD type tt:PTZPresetTourStartingConditionOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (597)
	virtual int soap_type(void) const { return 597; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptions); }
	         tt__PTZPresetTourStartingConditionOptions() { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1758 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (598)
/* Type tt__PTZPresetTourStartingConditionOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPresetTourStartingConditionOptionsExtension complex type: */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (598)
	virtual int soap_type(void) const { return 598; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
	virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZPresetTourStartingConditionOptionsExtension); }
	         tt__PTZPresetTourStartingConditionOptionsExtension() { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
	friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1761 */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (599)
/* Type tt__ImagingStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus complex type: */
class SOAP_CMAC tt__ImagingStatus : public xsd__anyType
{
public:
	tt__FocusStatus *FocusStatus;	/* required element of XSD type tt:FocusStatus */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus (599)
	virtual int soap_type(void) const { return 599; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus, default initialized and not managed by a soap context
	virtual tt__ImagingStatus *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus); }
	         tt__ImagingStatus() { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
	friend SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1764 */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (600)
/* Type tt__FocusStatus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus complex type: */
class SOAP_CMAC tt__FocusStatus : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	char *Error;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus (600)
	virtual int soap_type(void) const { return 600; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus, default initialized and not managed by a soap context
	virtual tt__FocusStatus *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus); }
	         tt__FocusStatus() { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
	friend SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1767 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (601)
/* Type tt__FocusConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration complex type: */
class SOAP_CMAC tt__FocusConfiguration : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of XSD type xsd:float */
	float NearLimit;	/* required element of XSD type xsd:float */
	float FarLimit;	/* required element of XSD type xsd:float */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration (601)
	virtual int soap_type(void) const { return 601; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration); }
	         tt__FocusConfiguration() { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
	friend SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1770 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (602)
/* Type tt__ImagingSettings is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettings complex type: */
class SOAP_CMAC tt__ImagingSettings : public xsd__anyType
{
public:
	tt__BacklightCompensation *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure *Exposure;	/* optional element of XSD type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of XSD type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange */
	tt__WhiteBalance *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance */
	tt__ImagingSettingsExtension *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings (602)
	virtual int soap_type(void) const { return 602; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
	virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings); }
	         tt__ImagingSettings() { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
	friend SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1773 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (603)
/* Type tt__ImagingSettingsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension (603)
	virtual int soap_type(void) const { return 603; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension); }
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1776 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (604)
/* Type tt__Exposure is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Exposure complex type: */
class SOAP_CMAC tt__Exposure : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* required element of XSD type tt:Rectangle */
	float MinExposureTime;	/* required element of XSD type xsd:float */
	float MaxExposureTime;	/* required element of XSD type xsd:float */
	float MinGain;	/* required element of XSD type xsd:float */
	float MaxGain;	/* required element of XSD type xsd:float */
	float MinIris;	/* required element of XSD type xsd:float */
	float MaxIris;	/* required element of XSD type xsd:float */
	float ExposureTime;	/* required element of XSD type xsd:float */
	float Gain;	/* required element of XSD type xsd:float */
	float Iris;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure (604)
	virtual int soap_type(void) const { return 604; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
	virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW(tt__Exposure); }
	         tt__Exposure() { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
	friend SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1779 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (605)
/* Type tt__WideDynamicRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRange complex type: */
class SOAP_CMAC tt__WideDynamicRange : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float Level;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange (605)
	virtual int soap_type(void) const { return 605; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange); }
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
	friend SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1782 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (606)
/* Type tt__BacklightCompensation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensation complex type: */
class SOAP_CMAC tt__BacklightCompensation : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float Level;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation (606)
	virtual int soap_type(void) const { return 606; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation); }
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
	friend SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1785 */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (607)
/* Type tt__ImagingOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions complex type: */
class SOAP_CMAC tt__ImagingOptions : public xsd__anyType
{
public:
	tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of XSD type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of XSD type tt:FloatRange */
	tt__ExposureOptions *Exposure;	/* required element of XSD type tt:ExposureOptions */
	tt__FocusOptions *Focus;	/* required element of XSD type tt:FocusOptions */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> of XSD type tt:IrCutFilterMode */
	enum tt__IrCutFilterMode *IrCutFilterModes;
	tt__FloatRange *Sharpness;	/* required element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of XSD type tt:WideDynamicRangeOptions */
	tt__WhiteBalanceOptions *WhiteBalance;	/* required element of XSD type tt:WhiteBalanceOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions (607)
	virtual int soap_type(void) const { return 607; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions, default initialized and not managed by a soap context
	virtual tt__ImagingOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions); }
	         tt__ImagingOptions() { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
	friend SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1788 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (608)
/* Type tt__WideDynamicRangeOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRangeOptions complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions (608)
	virtual int soap_type(void) const { return 608; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions); }
	         tt__WideDynamicRangeOptions() { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1791 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (609)
/* Type tt__BacklightCompensationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationOptions complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions (609)
	virtual int soap_type(void) const { return 609; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions); }
	         tt__BacklightCompensationOptions() { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1794 */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (610)
/* Type tt__FocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions complex type: */
class SOAP_CMAC tt__FocusOptions : public xsd__anyType
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> of XSD type tt:AutoFocusMode */
	enum tt__AutoFocusMode *AutoFocusModes;
	tt__FloatRange *DefaultSpeed;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions (610)
	virtual int soap_type(void) const { return 610; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions, default initialized and not managed by a soap context
	virtual tt__FocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions); }
	         tt__FocusOptions() { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
	friend SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1797 */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (611)
/* Type tt__ExposureOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureOptions complex type: */
class SOAP_CMAC tt__ExposureOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ExposureMode */
	enum tt__ExposureMode *Mode;
	int __sizePriority;	/* sequence of elements <Priority> of XSD type tt:ExposurePriority */
	enum tt__ExposurePriority *Priority;
	tt__FloatRange *MinExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions (611)
	virtual int soap_type(void) const { return 611; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions, default initialized and not managed by a soap context
	virtual tt__ExposureOptions *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions); }
	         tt__ExposureOptions() { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
	friend SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1800 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (612)
/* Type tt__WhiteBalanceOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WhiteBalanceMode */
	enum tt__WhiteBalanceMode *Mode;
	tt__FloatRange *YrGain;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions (612)
	virtual int soap_type(void) const { return 612; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions); }
	         tt__WhiteBalanceOptions() { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1803 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (613)
/* Type tt__FocusMove is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusMove complex type: */
class SOAP_CMAC tt__FocusMove : public xsd__anyType
{
public:
	tt__AbsoluteFocus *Absolute;	/* optional element of XSD type tt:AbsoluteFocus */
	tt__RelativeFocus *Relative;	/* optional element of XSD type tt:RelativeFocus */
	tt__ContinuousFocus *Continuous;	/* optional element of XSD type tt:ContinuousFocus */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusMove (613)
	virtual int soap_type(void) const { return 613; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
	virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW(tt__FocusMove); }
	         tt__FocusMove() { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
	friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1806 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (614)
/* Type tt__AbsoluteFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AbsoluteFocus complex type: */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocus (614)
	virtual int soap_type(void) const { return 614; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocus); }
	         tt__AbsoluteFocus() { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
	friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1809 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (615)
/* Type tt__RelativeFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocus complex type: */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType
{
public:
	float Distance;	/* required element of XSD type xsd:float */
	float *Speed;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocus (615)
	virtual int soap_type(void) const { return 615; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
	virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocus); }
	         tt__RelativeFocus() { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
	friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1812 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (616)
/* Type tt__ContinuousFocus is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ContinuousFocus complex type: */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType
{
public:
	float Speed;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocus (616)
	virtual int soap_type(void) const { return 616; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
	virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocus); }
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
	friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1815 */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (617)
/* Type tt__MoveOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveOptions complex type: */
class SOAP_CMAC tt__MoveOptions : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions *Relative;	/* optional element of XSD type tt:RelativeFocusOptions */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions (617)
	virtual int soap_type(void) const { return 617; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions, default initialized and not managed by a soap context
	virtual tt__MoveOptions *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions); }
	         tt__MoveOptions() { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
	friend SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1818 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (618)
/* Type tt__AbsoluteFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AbsoluteFocusOptions complex type: */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Position;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AbsoluteFocusOptions (618)
	virtual int soap_type(void) const { return 618; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
	virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__AbsoluteFocusOptions); }
	         tt__AbsoluteFocusOptions() { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
	friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1821 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (619)
/* Type tt__RelativeFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocusOptions complex type: */
class SOAP_CMAC tt__RelativeFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions (619)
	virtual int soap_type(void) const { return 619; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions); }
	         tt__RelativeFocusOptions() { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1824 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (620)
/* Type tt__ContinuousFocusOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ContinuousFocusOptions complex type: */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Speed;	/* required element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ContinuousFocusOptions (620)
	virtual int soap_type(void) const { return 620; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
	virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW(tt__ContinuousFocusOptions); }
	         tt__ContinuousFocusOptions() { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
	friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1827 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (621)
/* Type tt__WhiteBalance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance complex type: */
class SOAP_CMAC tt__WhiteBalance : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float CrGain;	/* required element of XSD type xsd:float */
	float CbGain;	/* required element of XSD type xsd:float */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance (621)
	virtual int soap_type(void) const { return 621; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
	virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance); }
	         tt__WhiteBalance() { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
	friend SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1830 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (622)
/* Type tt__ImagingStatus20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus20 complex type: */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType
{
public:
	tt__FocusStatus20 *FocusStatus20;	/* optional element of XSD type tt:FocusStatus20 */
	tt__ImagingStatus20Extension *Extension;	/* optional element of XSD type tt:ImagingStatus20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20 (622)
	virtual int soap_type(void) const { return 622; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20); }
	         tt__ImagingStatus20() { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
	friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1833 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (623)
/* Type tt__ImagingStatus20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingStatus20Extension complex type: */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingStatus20Extension (623)
	virtual int soap_type(void) const { return 623; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingStatus20Extension); }
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
	friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1836 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (624)
/* Type tt__FocusStatus20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus20 complex type: */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType
{
public:
	float Position;	/* required element of XSD type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of XSD type tt:MoveStatus */
	char *Error;	/* optional element of XSD type xsd:string */
	tt__FocusStatus20Extension *Extension;	/* optional element of XSD type tt:FocusStatus20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20 (624)
	virtual int soap_type(void) const { return 624; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
	virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20); }
	         tt__FocusStatus20() { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
	friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1839 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (625)
/* Type tt__FocusStatus20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusStatus20Extension complex type: */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusStatus20Extension (625)
	virtual int soap_type(void) const { return 625; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
	virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusStatus20Extension); }
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
	friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1842 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (626)
/* Type tt__ImagingSettings20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettings20 complex type: */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType
{
public:
	tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of XSD type xsd:float */
	float *ColorSaturation;	/* optional element of XSD type xsd:float */
	float *Contrast;	/* optional element of XSD type xsd:float */
	tt__Exposure20 *Exposure;	/* optional element of XSD type tt:Exposure20 */
	tt__FocusConfiguration20 *Focus;	/* optional element of XSD type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of XSD type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of XSD type xsd:float */
	tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRange20 */
	tt__WhiteBalance20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalance20 */
	tt__ImagingSettingsExtension20 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension20 */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettings20 (626)
	virtual int soap_type(void) const { return 626; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
	virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettings20); }
	         tt__ImagingSettings20() { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
	friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1845 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (627)
/* Type tt__ImagingSettingsExtension20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension20 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__ImageStabilization *ImageStabilization;	/* optional element of XSD type tt:ImageStabilization */
	tt__ImagingSettingsExtension202 *Extension;	/* optional element of XSD type tt:ImagingSettingsExtension202 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension20 (627)
	virtual int soap_type(void) const { return 627; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension20); }
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1848 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (628)
/* Type tt__ImagingSettingsExtension202 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingSettingsExtension202 complex type: */
class SOAP_CMAC tt__ImagingSettingsExtension202 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingSettingsExtension202 (628)
	virtual int soap_type(void) const { return 628; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
	virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingSettingsExtension202); }
	         tt__ImagingSettingsExtension202() { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
	friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1851 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (629)
/* Type tt__ImageStabilization is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilization complex type: */
class SOAP_CMAC tt__ImageStabilization : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of XSD type tt:ImageStabilizationMode */
	float *Level;	/* optional element of XSD type xsd:float */
	tt__ImageStabilizationExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilization (629)
	virtual int soap_type(void) const { return 629; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
	virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilization); }
	         tt__ImageStabilization() { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
	friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1854 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (630)
/* Type tt__ImageStabilizationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationExtension (630)
	virtual int soap_type(void) const { return 630; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationExtension); }
	         tt__ImageStabilizationExtension() { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1857 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (631)
/* Type tt__WideDynamicRange20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRange20 complex type: */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of XSD type tt:WideDynamicMode */
	float *Level;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRange20 (631)
	virtual int soap_type(void) const { return 631; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRange20); }
	         tt__WideDynamicRange20() { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
	friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1860 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (632)
/* Type tt__BacklightCompensation20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensation20 complex type: */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of XSD type tt:BacklightCompensationMode */
	float *Level;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensation20 (632)
	virtual int soap_type(void) const { return 632; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensation20); }
	         tt__BacklightCompensation20() { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
	friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1863 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (633)
/* Type tt__Exposure20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Exposure20 complex type: */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of XSD type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of XSD type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of XSD type tt:Rectangle */
	float *MinExposureTime;	/* optional element of XSD type xsd:float */
	float *MaxExposureTime;	/* optional element of XSD type xsd:float */
	float *MinGain;	/* optional element of XSD type xsd:float */
	float *MaxGain;	/* optional element of XSD type xsd:float */
	float *MinIris;	/* optional element of XSD type xsd:float */
	float *MaxIris;	/* optional element of XSD type xsd:float */
	float *ExposureTime;	/* optional element of XSD type xsd:float */
	float *Gain;	/* optional element of XSD type xsd:float */
	float *Iris;	/* optional element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Exposure20 (633)
	virtual int soap_type(void) const { return 633; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
	virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW(tt__Exposure20); }
	         tt__Exposure20() { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
	friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1866 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (634)
/* Type tt__ImagingOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20 complex type: */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType
{
public:
	tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of XSD type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of XSD type tt:FloatRange */
	tt__ExposureOptions20 *Exposure;	/* optional element of XSD type tt:ExposureOptions20 */
	tt__FocusOptions20 *Focus;	/* optional element of XSD type tt:FocusOptions20 */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> of XSD type tt:IrCutFilterMode */
	enum tt__IrCutFilterMode *IrCutFilterModes;
	tt__FloatRange *Sharpness;	/* optional element of XSD type tt:FloatRange */
	tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of XSD type tt:WideDynamicRangeOptions20 */
	tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of XSD type tt:WhiteBalanceOptions20 */
	tt__ImagingOptions20Extension *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20 (634)
	virtual int soap_type(void) const { return 634; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20); }
	         tt__ImagingOptions20() { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
	friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1869 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (635)
/* Type tt__ImagingOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of XSD type tt:ImageStabilizationOptions */
	tt__ImagingOptions20Extension2 *Extension;	/* optional element of XSD type tt:ImagingOptions20Extension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension (635)
	virtual int soap_type(void) const { return 635; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension); }
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1872 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (636)
/* Type tt__ImagingOptions20Extension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImagingOptions20Extension2 complex type: */
class SOAP_CMAC tt__ImagingOptions20Extension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImagingOptions20Extension2 (636)
	virtual int soap_type(void) const { return 636; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
	virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW(tt__ImagingOptions20Extension2); }
	         tt__ImagingOptions20Extension2() { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
	friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1875 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (637)
/* Type tt__ImageStabilizationOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationOptions complex type: */
class SOAP_CMAC tt__ImageStabilizationOptions : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ImageStabilizationMode */
	enum tt__ImageStabilizationMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
	tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of XSD type tt:ImageStabilizationOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptions (637)
	virtual int soap_type(void) const { return 637; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptions); }
	         tt__ImageStabilizationOptions() { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1878 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (638)
/* Type tt__ImageStabilizationOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ImageStabilizationOptionsExtension complex type: */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ImageStabilizationOptionsExtension (638)
	virtual int soap_type(void) const { return 638; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
	virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__ImageStabilizationOptionsExtension); }
	         tt__ImageStabilizationOptionsExtension() { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
	friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1881 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (639)
/* Type tt__WideDynamicRangeOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WideDynamicRangeOptions20 complex type: */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WideDynamicMode */
	enum tt__WideDynamicMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WideDynamicRangeOptions20 (639)
	virtual int soap_type(void) const { return 639; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
	virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WideDynamicRangeOptions20); }
	         tt__WideDynamicRangeOptions20() { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
	friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1884 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (640)
/* Type tt__BacklightCompensationOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BacklightCompensationOptions20 complex type: */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:BacklightCompensationMode */
	enum tt__BacklightCompensationMode *Mode;
	tt__FloatRange *Level;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BacklightCompensationOptions20 (640)
	virtual int soap_type(void) const { return 640; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
	virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__BacklightCompensationOptions20); }
	         tt__BacklightCompensationOptions20() { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
	friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1887 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (641)
/* Type tt__ExposureOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ExposureOptions20 complex type: */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:ExposureMode */
	enum tt__ExposureMode *Mode;
	int __sizePriority;	/* sequence of elements <Priority> of XSD type tt:ExposurePriority */
	enum tt__ExposurePriority *Priority;
	tt__FloatRange *MinExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ExposureOptions20 (641)
	virtual int soap_type(void) const { return 641; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
	virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__ExposureOptions20); }
	         tt__ExposureOptions20() { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
	friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1890 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (642)
/* Type tt__MoveOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MoveOptions20 complex type: */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of XSD type tt:AbsoluteFocusOptions */
	tt__RelativeFocusOptions20 *Relative;	/* optional element of XSD type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of XSD type tt:ContinuousFocusOptions */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MoveOptions20 (642)
	virtual int soap_type(void) const { return 642; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
	virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__MoveOptions20); }
	         tt__MoveOptions20() { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
	friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1893 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (643)
/* Type tt__RelativeFocusOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelativeFocusOptions20 complex type: */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of XSD type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of XSD type tt:FloatRange */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelativeFocusOptions20 (643)
	virtual int soap_type(void) const { return 643; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
	virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__RelativeFocusOptions20); }
	         tt__RelativeFocusOptions20() { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
	friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1896 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (644)
/* Type tt__WhiteBalance20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance20 complex type: */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of XSD type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of XSD type xsd:float */
	float *CbGain;	/* optional element of XSD type xsd:float */
	tt__WhiteBalance20Extension *Extension;	/* optional element of XSD type tt:WhiteBalance20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20 (644)
	virtual int soap_type(void) const { return 644; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20); }
	         tt__WhiteBalance20() { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
	friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1899 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (645)
/* Type tt__WhiteBalance20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalance20Extension complex type: */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalance20Extension (645)
	virtual int soap_type(void) const { return 645; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalance20Extension); }
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1902 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (646)
/* Type tt__FocusConfiguration20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration20 complex type: */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of XSD type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of XSD type xsd:float */
	float *NearLimit;	/* optional element of XSD type xsd:float */
	float *FarLimit;	/* optional element of XSD type xsd:float */
	tt__FocusConfiguration20Extension *Extension;	/* optional element of XSD type tt:FocusConfiguration20Extension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20 (646)
	virtual int soap_type(void) const { return 646; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20); }
	         tt__FocusConfiguration20() { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1905 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (647)
/* Type tt__FocusConfiguration20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusConfiguration20Extension complex type: */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusConfiguration20Extension (647)
	virtual int soap_type(void) const { return 647; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
	virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusConfiguration20Extension); }
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
	friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1908 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (648)
/* Type tt__WhiteBalanceOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions20 complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType
{
public:
	int __sizeMode;	/* sequence of elements <Mode> of XSD type tt:WhiteBalanceMode */
	enum tt__WhiteBalanceMode *Mode;
	tt__FloatRange *YrGain;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of XSD type tt:FloatRange */
	tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of XSD type tt:WhiteBalanceOptions20Extension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20 (648)
	virtual int soap_type(void) const { return 648; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20); }
	         tt__WhiteBalanceOptions20() { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1911 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (649)
/* Type tt__WhiteBalanceOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:WhiteBalanceOptions20Extension complex type: */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__WhiteBalanceOptions20Extension (649)
	virtual int soap_type(void) const { return 649; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
	virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__WhiteBalanceOptions20Extension); }
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
	friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1914 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (650)
/* Type tt__FocusOptions20 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions20 complex type: */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> of XSD type tt:AutoFocusMode */
	enum tt__AutoFocusMode *AutoFocusModes;
	tt__FloatRange *DefaultSpeed;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of XSD type tt:FloatRange */
	tt__FocusOptions20Extension *Extension;	/* optional element of XSD type tt:FocusOptions20Extension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20 (650)
	virtual int soap_type(void) const { return 650; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
	virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20); }
	         tt__FocusOptions20() { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
	friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1917 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (651)
/* Type tt__FocusOptions20Extension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FocusOptions20Extension complex type: */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FocusOptions20Extension (651)
	virtual int soap_type(void) const { return 651; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
	virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW(tt__FocusOptions20Extension); }
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
	friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1920 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (652)
/* Type tt__MessageExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageExtension complex type: */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageExtension (652)
	virtual int soap_type(void) const { return 652; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
	virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageExtension); }
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
	friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21009 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1912)
/* tt:ItemList-SimpleItem complex type: */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Value;	/* required attribute of XSD type xsd:anySimpleType */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_SimpleItem (1912)
	virtual int soap_type(void) const { return 1912; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_SimpleItem); }
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
	friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21037 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1914)
/* tt:ItemList-ElementItem complex type: */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	char *__any;
	char *Name;	/* required attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemList_ElementItem (1914)
	virtual int soap_type(void) const { return 1914; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
	virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW(_tt__ItemList_ElementItem); }
	         _tt__ItemList_ElementItem() { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
	friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1923 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (653)
/* Type tt__ItemList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemList complex type: */
class SOAP_CMAC tt__ItemList : public xsd__anyType
{
public:
	int __sizeSimpleItem;	/* sequence of elements <SimpleItem> of XSD type tt:ItemList-SimpleItem */
	_tt__ItemList_SimpleItem *SimpleItem;
	int __sizeElementItem;	/* sequence of elements <ElementItem> of XSD type tt:ItemList-ElementItem */
	_tt__ItemList_ElementItem *ElementItem;
	tt__ItemListExtension *Extension;	/* optional element of XSD type tt:ItemListExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemList (653)
	virtual int soap_type(void) const { return 653; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
	virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW(tt__ItemList); }
	         tt__ItemList() { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
	friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1926 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (654)
/* Type tt__ItemListExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListExtension complex type: */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListExtension (654)
	virtual int soap_type(void) const { return 654; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
	virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListExtension); }
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
	friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1929 */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (655)
/* Type tt__MessageDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageDescription complex type: */
class SOAP_CMAC tt__MessageDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescription (655)
	virtual int soap_type(void) const { return 655; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescription, default initialized and not managed by a soap context
	virtual tt__MessageDescription *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescription); }
	         tt__MessageDescription() { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
	friend SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1932 */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (656)
/* Type tt__MessageDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MessageDescriptionExtension complex type: */
class SOAP_CMAC tt__MessageDescriptionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MessageDescriptionExtension (656)
	virtual int soap_type(void) const { return 656; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MessageDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__MessageDescriptionExtension); }
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
	friend SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21191 */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1919)
/* tt:ItemListDescription-SimpleItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1919)
	virtual int soap_type(void) const { return 1919; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription); }
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21216 */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1921)
/* tt:ItemListDescription-ElementItemDescription complex type: */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1921)
	virtual int soap_type(void) const { return 1921; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
	virtual _tt__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW(_tt__ItemListDescription_ElementItemDescription); }
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
	friend SOAP_FMAC1 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1935 */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (657)
/* Type tt__ItemListDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListDescription complex type: */
class SOAP_CMAC tt__ItemListDescription : public xsd__anyType
{
public:
	int __sizeSimpleItemDescription;	/* sequence of elements <SimpleItemDescription> of XSD type tt:ItemListDescription-SimpleItemDescription */
	_tt__ItemListDescription_SimpleItemDescription *SimpleItemDescription;
	int __sizeElementItemDescription;	/* sequence of elements <ElementItemDescription> of XSD type tt:ItemListDescription-ElementItemDescription */
	_tt__ItemListDescription_ElementItemDescription *ElementItemDescription;
	tt__ItemListDescriptionExtension *Extension;	/* optional element of XSD type tt:ItemListDescriptionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescription (657)
	virtual int soap_type(void) const { return 657; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescription, default initialized and not managed by a soap context
	virtual tt__ItemListDescription *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescription); }
	         tt__ItemListDescription() { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
	friend SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1938 */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (658)
/* Type tt__ItemListDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ItemListDescriptionExtension complex type: */
class SOAP_CMAC tt__ItemListDescriptionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ItemListDescriptionExtension (658)
	virtual int soap_type(void) const { return 658; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ItemListDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ItemListDescriptionExtension); }
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1941 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (659)
/* Type tt__Vector is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Vector simple type: */
class SOAP_CMAC tt__Vector : public xsd__anyType
{
public:
	float *x;	/* optional attribute of XSD type xsd:float */
	float *y;	/* optional attribute of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Vector (659)
	virtual int soap_type(void) const { return 659; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Vector, default initialized and not managed by a soap context
	virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW(tt__Vector); }
	         tt__Vector() { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
	friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1944 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (660)
/* Type tt__Rectangle is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rectangle simple type: */
class SOAP_CMAC tt__Rectangle : public xsd__anyType
{
public:
	float *bottom;	/* optional attribute of XSD type xsd:float */
	float *top;	/* optional attribute of XSD type xsd:float */
	float *right;	/* optional attribute of XSD type xsd:float */
	float *left;	/* optional attribute of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rectangle (660)
	virtual int soap_type(void) const { return 660; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
	virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW(tt__Rectangle); }
	         tt__Rectangle() { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
	friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1947 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (661)
/* Type tt__Polygon is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Polygon complex type: */
class SOAP_CMAC tt__Polygon : public xsd__anyType
{
public:
	int __sizePoint;	/* sequence of elements <Point> of XSD type tt:Vector */
	tt__Vector **Point;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polygon (661)
	virtual int soap_type(void) const { return 661; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
	virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW(tt__Polygon); }
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
	friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1950 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (662)
/* Type tt__Polyline is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Polyline complex type: */
class SOAP_CMAC tt__Polyline : public xsd__anyType
{
public:
	int __sizePoint;	/* sequence of elements <Point> of XSD type tt:Vector */
	tt__Vector **Point;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Polyline (662)
	virtual int soap_type(void) const { return 662; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
	virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW(tt__Polyline); }
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
	friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1953 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (663)
/* Type tt__Color is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Color simple type: */
class SOAP_CMAC tt__Color : public xsd__anyType
{
public:
	float X;	/* required attribute of XSD type xsd:float */
	float Y;	/* required attribute of XSD type xsd:float */
	float Z;	/* required attribute of XSD type xsd:float */
	char *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Color (663)
	virtual int soap_type(void) const { return 663; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Color, default initialized and not managed by a soap context
	virtual tt__Color *soap_alloc(void) const { return SOAP_NEW(tt__Color); }
	         tt__Color() { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
	friend SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1956 */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (664)
/* Type tt__ColorCovariance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorCovariance simple type: */
class SOAP_CMAC tt__ColorCovariance : public xsd__anyType
{
public:
	float XX;	/* required attribute of XSD type xsd:float */
	float YY;	/* required attribute of XSD type xsd:float */
	float ZZ;	/* required attribute of XSD type xsd:float */
	float *XY;	/* optional attribute of XSD type xsd:float */
	float *XZ;	/* optional attribute of XSD type xsd:float */
	float *YZ;	/* optional attribute of XSD type xsd:float */
	char *Colorspace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorCovariance (664)
	virtual int soap_type(void) const { return 664; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorCovariance, default initialized and not managed by a soap context
	virtual tt__ColorCovariance *soap_alloc(void) const { return SOAP_NEW(tt__ColorCovariance); }
	         tt__ColorCovariance() { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
	friend SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1959 */
#ifndef SOAP_TYPE_tt__Appearance
#define SOAP_TYPE_tt__Appearance (665)
/* Type tt__Appearance is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Appearance complex type: */
class SOAP_CMAC tt__Appearance : public xsd__anyType
{
public:
	tt__Transformation *Transformation;	/* optional element of XSD type tt:Transformation */
	tt__ShapeDescriptor *Shape;	/* optional element of XSD type tt:ShapeDescriptor */
	tt__ColorDescriptor *Color;	/* optional element of XSD type tt:ColorDescriptor */
	tt__ClassDescriptor *Class;	/* optional element of XSD type tt:ClassDescriptor */
	tt__AppearanceExtension *Extension;	/* optional element of XSD type tt:AppearanceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Appearance (665)
	virtual int soap_type(void) const { return 665; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Appearance, default initialized and not managed by a soap context
	virtual tt__Appearance *soap_alloc(void) const { return SOAP_NEW(tt__Appearance); }
	         tt__Appearance() { tt__Appearance::soap_default(NULL); }
	virtual ~tt__Appearance() { }
	friend SOAP_FMAC1 tt__Appearance * SOAP_FMAC2 soap_instantiate_tt__Appearance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1962 */
#ifndef SOAP_TYPE_tt__AppearanceExtension
#define SOAP_TYPE_tt__AppearanceExtension (666)
/* Type tt__AppearanceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AppearanceExtension complex type: */
class SOAP_CMAC tt__AppearanceExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AppearanceExtension (666)
	virtual int soap_type(void) const { return 666; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AppearanceExtension, default initialized and not managed by a soap context
	virtual tt__AppearanceExtension *soap_alloc(void) const { return SOAP_NEW(tt__AppearanceExtension); }
	         tt__AppearanceExtension() { tt__AppearanceExtension::soap_default(NULL); }
	virtual ~tt__AppearanceExtension() { }
	friend SOAP_FMAC1 tt__AppearanceExtension * SOAP_FMAC2 soap_instantiate_tt__AppearanceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1965 */
#ifndef SOAP_TYPE_tt__ShapeDescriptor
#define SOAP_TYPE_tt__ShapeDescriptor (667)
/* Type tt__ShapeDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ShapeDescriptor complex type: */
class SOAP_CMAC tt__ShapeDescriptor : public xsd__anyType
{
public:
	tt__Rectangle *BoundingBox;	/* required element of XSD type tt:Rectangle */
	tt__Vector *CenterOfGravity;	/* required element of XSD type tt:Vector */
	int __sizePolygon;	/* sequence of elements <Polygon> of XSD type tt:Polygon */
	tt__Polygon **Polygon;
	tt__ShapeDescriptorExtension *Extension;	/* optional element of XSD type tt:ShapeDescriptorExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ShapeDescriptor (667)
	virtual int soap_type(void) const { return 667; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ShapeDescriptor, default initialized and not managed by a soap context
	virtual tt__ShapeDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ShapeDescriptor); }
	         tt__ShapeDescriptor() { tt__ShapeDescriptor::soap_default(NULL); }
	virtual ~tt__ShapeDescriptor() { }
	friend SOAP_FMAC1 tt__ShapeDescriptor * SOAP_FMAC2 soap_instantiate_tt__ShapeDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1968 */
#ifndef SOAP_TYPE_tt__ShapeDescriptorExtension
#define SOAP_TYPE_tt__ShapeDescriptorExtension (668)
/* Type tt__ShapeDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ShapeDescriptorExtension complex type: */
class SOAP_CMAC tt__ShapeDescriptorExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ShapeDescriptorExtension (668)
	virtual int soap_type(void) const { return 668; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ShapeDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ShapeDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ShapeDescriptorExtension); }
	         tt__ShapeDescriptorExtension() { tt__ShapeDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ShapeDescriptorExtension() { }
	friend SOAP_FMAC1 tt__ShapeDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ShapeDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21542 */
#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1934)
/* tt:ColorDescriptor-ColorCluster complex type: */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster
{
public:
	tt__Color *Color;	/* required element of XSD type tt:Color */
	float *Weight;	/* optional element of XSD type xsd:float */
	tt__ColorCovariance *Covariance;	/* optional element of XSD type tt:ColorCovariance */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1934)
	virtual int soap_type(void) const { return 1934; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ColorDescriptor_ColorCluster, default initialized and not managed by a soap context
	virtual _tt__ColorDescriptor_ColorCluster *soap_alloc(void) const { return SOAP_NEW(_tt__ColorDescriptor_ColorCluster); }
	         _tt__ColorDescriptor_ColorCluster() { _tt__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_tt__ColorDescriptor_ColorCluster() { }
	friend SOAP_FMAC1 _tt__ColorDescriptor_ColorCluster * SOAP_FMAC2 soap_instantiate__tt__ColorDescriptor_ColorCluster(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1971 */
#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (669)
/* Type tt__ColorDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorDescriptor complex type: */
class SOAP_CMAC tt__ColorDescriptor : public xsd__anyType
{
public:
	int __sizeColorCluster;	/* sequence of elements <ColorCluster> of XSD type tt:ColorDescriptor-ColorCluster */
	_tt__ColorDescriptor_ColorCluster *ColorCluster;
	tt__ColorDescriptorExtension *Extension;	/* optional element of XSD type tt:ColorDescriptorExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorDescriptor (669)
	virtual int soap_type(void) const { return 669; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorDescriptor, default initialized and not managed by a soap context
	virtual tt__ColorDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ColorDescriptor); }
	         tt__ColorDescriptor() { tt__ColorDescriptor::soap_default(NULL); }
	virtual ~tt__ColorDescriptor() { }
	friend SOAP_FMAC1 tt__ColorDescriptor * SOAP_FMAC2 soap_instantiate_tt__ColorDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1974 */
#ifndef SOAP_TYPE_tt__ColorDescriptorExtension
#define SOAP_TYPE_tt__ColorDescriptorExtension (670)
/* Type tt__ColorDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ColorDescriptorExtension complex type: */
class SOAP_CMAC tt__ColorDescriptorExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ColorDescriptorExtension (670)
	virtual int soap_type(void) const { return 670; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ColorDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ColorDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ColorDescriptorExtension); }
	         tt__ColorDescriptorExtension() { tt__ColorDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ColorDescriptorExtension() { }
	friend SOAP_FMAC1 tt__ColorDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ColorDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:21612 */
#ifndef SOAP_TYPE__tt__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (1939)
/* tt:ClassDescriptor-ClassCandidate complex type: */
class SOAP_CMAC _tt__ClassDescriptor_ClassCandidate
{
public:
	enum tt__ClassType Type;	/* required element of XSD type tt:ClassType */
	float Likelihood;	/* required element of XSD type xsd:float */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (1939)
	virtual int soap_type(void) const { return 1939; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ClassDescriptor_ClassCandidate, default initialized and not managed by a soap context
	virtual _tt__ClassDescriptor_ClassCandidate *soap_alloc(void) const { return SOAP_NEW(_tt__ClassDescriptor_ClassCandidate); }
	         _tt__ClassDescriptor_ClassCandidate() { _tt__ClassDescriptor_ClassCandidate::soap_default(NULL); }
	virtual ~_tt__ClassDescriptor_ClassCandidate() { }
	friend SOAP_FMAC1 _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC2 soap_instantiate__tt__ClassDescriptor_ClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1977 */
#ifndef SOAP_TYPE_tt__ClassDescriptor
#define SOAP_TYPE_tt__ClassDescriptor (671)
/* Type tt__ClassDescriptor is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptor complex type: */
class SOAP_CMAC tt__ClassDescriptor : public xsd__anyType
{
public:
	int __sizeClassCandidate;	/* sequence of elements <ClassCandidate> of XSD type tt:ClassDescriptor-ClassCandidate */
	_tt__ClassDescriptor_ClassCandidate *ClassCandidate;
	tt__ClassDescriptorExtension *Extension;	/* optional element of XSD type tt:ClassDescriptorExtension */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptor (671)
	virtual int soap_type(void) const { return 671; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptor, default initialized and not managed by a soap context
	virtual tt__ClassDescriptor *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptor); }
	         tt__ClassDescriptor() { tt__ClassDescriptor::soap_default(NULL); }
	virtual ~tt__ClassDescriptor() { }
	friend SOAP_FMAC1 tt__ClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__ClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1980 */
#ifndef SOAP_TYPE_tt__ClassDescriptorExtension
#define SOAP_TYPE_tt__ClassDescriptorExtension (672)
/* Type tt__ClassDescriptorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptorExtension complex type: */
class SOAP_CMAC tt__ClassDescriptorExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	int __sizeOtherTypes;	/* sequence of elements <OtherTypes> of XSD type tt:OtherType */
	tt__OtherType **OtherTypes;
	tt__ClassDescriptorExtension2 *Extension;	/* optional element of XSD type tt:ClassDescriptorExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptorExtension (672)
	virtual int soap_type(void) const { return 672; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptorExtension, default initialized and not managed by a soap context
	virtual tt__ClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptorExtension); }
	         tt__ClassDescriptorExtension() { tt__ClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension() { }
	friend SOAP_FMAC1 tt__ClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1983 */
#ifndef SOAP_TYPE_tt__ClassDescriptorExtension2
#define SOAP_TYPE_tt__ClassDescriptorExtension2 (673)
/* Type tt__ClassDescriptorExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ClassDescriptorExtension2 complex type: */
class SOAP_CMAC tt__ClassDescriptorExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ClassDescriptorExtension2 (673)
	virtual int soap_type(void) const { return 673; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ClassDescriptorExtension2, default initialized and not managed by a soap context
	virtual tt__ClassDescriptorExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__ClassDescriptorExtension2); }
	         tt__ClassDescriptorExtension2() { tt__ClassDescriptorExtension2::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension2() { }
	friend SOAP_FMAC1 tt__ClassDescriptorExtension2 * SOAP_FMAC2 soap_instantiate_tt__ClassDescriptorExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1986 */
#ifndef SOAP_TYPE_tt__OtherType
#define SOAP_TYPE_tt__OtherType (674)
/* Type tt__OtherType is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:OtherType complex type: */
class SOAP_CMAC tt__OtherType : public xsd__anyType
{
public:
	char *Type;	/* required element of XSD type xsd:string */
	float Likelihood;	/* required element of XSD type xsd:float */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__OtherType (674)
	virtual int soap_type(void) const { return 674; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__OtherType, default initialized and not managed by a soap context
	virtual tt__OtherType *soap_alloc(void) const { return SOAP_NEW(tt__OtherType); }
	         tt__OtherType() { tt__OtherType::soap_default(NULL); }
	virtual ~tt__OtherType() { }
	friend SOAP_FMAC1 tt__OtherType * SOAP_FMAC2 soap_instantiate_tt__OtherType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1992 */
#ifndef SOAP_TYPE_tt__ObjectExtension
#define SOAP_TYPE_tt__ObjectExtension (676)
/* Type tt__ObjectExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectExtension complex type: */
class SOAP_CMAC tt__ObjectExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectExtension (676)
	virtual int soap_type(void) const { return 676; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectExtension, default initialized and not managed by a soap context
	virtual tt__ObjectExtension *soap_alloc(void) const { return SOAP_NEW(tt__ObjectExtension); }
	         tt__ObjectExtension() { tt__ObjectExtension::soap_default(NULL); }
	virtual ~tt__ObjectExtension() { }
	friend SOAP_FMAC1 tt__ObjectExtension * SOAP_FMAC2 soap_instantiate_tt__ObjectExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1995 */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (677)
/* Type tt__Transformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Transformation complex type: */
class SOAP_CMAC tt__Transformation : public xsd__anyType
{
public:
	tt__Vector *Translate;	/* optional element of XSD type tt:Vector */
	tt__Vector *Scale;	/* optional element of XSD type tt:Vector */
	tt__TransformationExtension *Extension;	/* optional element of XSD type tt:TransformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Transformation (677)
	virtual int soap_type(void) const { return 677; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Transformation, default initialized and not managed by a soap context
	virtual tt__Transformation *soap_alloc(void) const { return SOAP_NEW(tt__Transformation); }
	         tt__Transformation() { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
	friend SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1998 */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (678)
/* Type tt__TransformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TransformationExtension complex type: */
class SOAP_CMAC tt__TransformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TransformationExtension (678)
	virtual int soap_type(void) const { return 678; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TransformationExtension, default initialized and not managed by a soap context
	virtual tt__TransformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__TransformationExtension); }
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
	friend SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2001 */
#ifndef SOAP_TYPE_tt__Frame
#define SOAP_TYPE_tt__Frame (679)
/* Type tt__Frame is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Frame complex type: */
class SOAP_CMAC tt__Frame : public xsd__anyType
{
public:
	tt__PTZStatus *PTZStatus;	/* optional element of XSD type tt:PTZStatus */
	tt__Transformation *Transformation;	/* optional element of XSD type tt:Transformation */
	int __sizeObject;	/* sequence of elements <Object> of XSD type tt:Object */
	tt__Object **Object;
	tt__ObjectTree *ObjectTree;	/* optional element of XSD type tt:ObjectTree */
	tt__FrameExtension *Extension;	/* optional element of XSD type tt:FrameExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Frame (679)
	virtual int soap_type(void) const { return 679; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Frame, default initialized and not managed by a soap context
	virtual tt__Frame *soap_alloc(void) const { return SOAP_NEW(tt__Frame); }
	         tt__Frame() { tt__Frame::soap_default(NULL); }
	virtual ~tt__Frame() { }
	friend SOAP_FMAC1 tt__Frame * SOAP_FMAC2 soap_instantiate_tt__Frame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2004 */
#ifndef SOAP_TYPE_tt__FrameExtension
#define SOAP_TYPE_tt__FrameExtension (680)
/* Type tt__FrameExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FrameExtension complex type: */
class SOAP_CMAC tt__FrameExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__MotionInCells *MotionInCells;	/* optional element of XSD type tt:MotionInCells */
	tt__FrameExtension2 *Extension;	/* optional element of XSD type tt:FrameExtension2 */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FrameExtension (680)
	virtual int soap_type(void) const { return 680; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FrameExtension, default initialized and not managed by a soap context
	virtual tt__FrameExtension *soap_alloc(void) const { return SOAP_NEW(tt__FrameExtension); }
	         tt__FrameExtension() { tt__FrameExtension::soap_default(NULL); }
	virtual ~tt__FrameExtension() { }
	friend SOAP_FMAC1 tt__FrameExtension * SOAP_FMAC2 soap_instantiate_tt__FrameExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2007 */
#ifndef SOAP_TYPE_tt__FrameExtension2
#define SOAP_TYPE_tt__FrameExtension2 (681)
/* Type tt__FrameExtension2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FrameExtension2 complex type: */
class SOAP_CMAC tt__FrameExtension2 : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FrameExtension2 (681)
	virtual int soap_type(void) const { return 681; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FrameExtension2, default initialized and not managed by a soap context
	virtual tt__FrameExtension2 *soap_alloc(void) const { return SOAP_NEW(tt__FrameExtension2); }
	         tt__FrameExtension2() { tt__FrameExtension2::soap_default(NULL); }
	virtual ~tt__FrameExtension2() { }
	friend SOAP_FMAC1 tt__FrameExtension2 * SOAP_FMAC2 soap_instantiate_tt__FrameExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2010 */
#ifndef SOAP_TYPE_tt__Merge
#define SOAP_TYPE_tt__Merge (682)
/* Type tt__Merge is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Merge complex type: */
class SOAP_CMAC tt__Merge : public xsd__anyType
{
public:
	int __sizefrom;	/* sequence of elements <from> of XSD type tt:ObjectId */
	tt__ObjectId **from;
	tt__ObjectId *to;	/* required element of XSD type tt:ObjectId */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Merge (682)
	virtual int soap_type(void) const { return 682; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Merge, default initialized and not managed by a soap context
	virtual tt__Merge *soap_alloc(void) const { return SOAP_NEW(tt__Merge); }
	         tt__Merge() { tt__Merge::soap_default(NULL); }
	virtual ~tt__Merge() { }
	friend SOAP_FMAC1 tt__Merge * SOAP_FMAC2 soap_instantiate_tt__Merge(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2013 */
#ifndef SOAP_TYPE_tt__Split
#define SOAP_TYPE_tt__Split (683)
/* Type tt__Split is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Split complex type: */
class SOAP_CMAC tt__Split : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of XSD type tt:ObjectId */
	int __sizeto;	/* sequence of elements <to> of XSD type tt:ObjectId */
	tt__ObjectId **to;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Split (683)
	virtual int soap_type(void) const { return 683; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Split, default initialized and not managed by a soap context
	virtual tt__Split *soap_alloc(void) const { return SOAP_NEW(tt__Split); }
	         tt__Split() { tt__Split::soap_default(NULL); }
	virtual ~tt__Split() { }
	friend SOAP_FMAC1 tt__Split * SOAP_FMAC2 soap_instantiate_tt__Split(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2016 */
#ifndef SOAP_TYPE_tt__Rename
#define SOAP_TYPE_tt__Rename (684)
/* Type tt__Rename is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Rename complex type: */
class SOAP_CMAC tt__Rename : public xsd__anyType
{
public:
	tt__ObjectId *from;	/* required element of XSD type tt:ObjectId */
	tt__ObjectId *to;	/* required element of XSD type tt:ObjectId */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Rename (684)
	virtual int soap_type(void) const { return 684; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Rename, default initialized and not managed by a soap context
	virtual tt__Rename *soap_alloc(void) const { return SOAP_NEW(tt__Rename); }
	         tt__Rename() { tt__Rename::soap_default(NULL); }
	virtual ~tt__Rename() { }
	friend SOAP_FMAC1 tt__Rename * SOAP_FMAC2 soap_instantiate_tt__Rename(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2019 */
#ifndef SOAP_TYPE_tt__ObjectId
#define SOAP_TYPE_tt__ObjectId (685)
/* Type tt__ObjectId is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectId simple type: */
class SOAP_CMAC tt__ObjectId : public xsd__anyType
{
public:
	char *ObjectId;	/* optional attribute of XSD type xsd:integer */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectId (685)
	virtual int soap_type(void) const { return 685; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectId, default initialized and not managed by a soap context
	virtual tt__ObjectId *soap_alloc(void) const { return SOAP_NEW(tt__ObjectId); }
	         tt__ObjectId() { tt__ObjectId::soap_default(NULL); }
	virtual ~tt__ObjectId() { }
	friend SOAP_FMAC1 tt__ObjectId * SOAP_FMAC2 soap_instantiate_tt__ObjectId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22000 */
#ifndef SOAP_TYPE__tt__Behaviour_Removed
#define SOAP_TYPE__tt__Behaviour_Removed (1955)
/* tt:Behaviour-Removed complex type: */
class SOAP_CMAC _tt__Behaviour_Removed
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Behaviour_Removed (1955)
	virtual int soap_type(void) const { return 1955; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Behaviour_Removed, default initialized and not managed by a soap context
	virtual _tt__Behaviour_Removed *soap_alloc(void) const { return SOAP_NEW(_tt__Behaviour_Removed); }
	         _tt__Behaviour_Removed() { _tt__Behaviour_Removed::soap_default(NULL); }
	virtual ~_tt__Behaviour_Removed() { }
	friend SOAP_FMAC1 _tt__Behaviour_Removed * SOAP_FMAC2 soap_instantiate__tt__Behaviour_Removed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22022 */
#ifndef SOAP_TYPE__tt__Behaviour_Idle
#define SOAP_TYPE__tt__Behaviour_Idle (1957)
/* tt:Behaviour-Idle complex type: */
class SOAP_CMAC _tt__Behaviour_Idle
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Behaviour_Idle (1957)
	virtual int soap_type(void) const { return 1957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Behaviour_Idle, default initialized and not managed by a soap context
	virtual _tt__Behaviour_Idle *soap_alloc(void) const { return SOAP_NEW(_tt__Behaviour_Idle); }
	         _tt__Behaviour_Idle() { _tt__Behaviour_Idle::soap_default(NULL); }
	virtual ~_tt__Behaviour_Idle() { }
	friend SOAP_FMAC1 _tt__Behaviour_Idle * SOAP_FMAC2 soap_instantiate__tt__Behaviour_Idle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2022 */
#ifndef SOAP_TYPE_tt__Behaviour
#define SOAP_TYPE_tt__Behaviour (686)
/* Type tt__Behaviour is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Behaviour complex type: */
class SOAP_CMAC tt__Behaviour : public xsd__anyType
{
public:
	_tt__Behaviour_Removed *Removed;	/* optional element of XSD type tt:Behaviour-Removed */
	_tt__Behaviour_Idle *Idle;	/* optional element of XSD type tt:Behaviour-Idle */
	tt__BehaviourExtension *Extension;	/* optional element of XSD type tt:BehaviourExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Behaviour (686)
	virtual int soap_type(void) const { return 686; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Behaviour, default initialized and not managed by a soap context
	virtual tt__Behaviour *soap_alloc(void) const { return SOAP_NEW(tt__Behaviour); }
	         tt__Behaviour() { tt__Behaviour::soap_default(NULL); }
	virtual ~tt__Behaviour() { }
	friend SOAP_FMAC1 tt__Behaviour * SOAP_FMAC2 soap_instantiate_tt__Behaviour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2025 */
#ifndef SOAP_TYPE_tt__BehaviourExtension
#define SOAP_TYPE_tt__BehaviourExtension (687)
/* Type tt__BehaviourExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:BehaviourExtension complex type: */
class SOAP_CMAC tt__BehaviourExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__BehaviourExtension (687)
	virtual int soap_type(void) const { return 687; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__BehaviourExtension, default initialized and not managed by a soap context
	virtual tt__BehaviourExtension *soap_alloc(void) const { return SOAP_NEW(tt__BehaviourExtension); }
	         tt__BehaviourExtension() { tt__BehaviourExtension::soap_default(NULL); }
	virtual ~tt__BehaviourExtension() { }
	friend SOAP_FMAC1 tt__BehaviourExtension * SOAP_FMAC2 soap_instantiate_tt__BehaviourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2028 */
#ifndef SOAP_TYPE_tt__ObjectTree
#define SOAP_TYPE_tt__ObjectTree (688)
/* Type tt__ObjectTree is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectTree complex type: */
class SOAP_CMAC tt__ObjectTree : public xsd__anyType
{
public:
	int __sizeRename;	/* sequence of elements <Rename> of XSD type tt:Rename */
	tt__Rename **Rename;
	int __sizeSplit;	/* sequence of elements <Split> of XSD type tt:Split */
	tt__Split **Split;
	int __sizeMerge;	/* sequence of elements <Merge> of XSD type tt:Merge */
	tt__Merge **Merge;
	int __sizeDelete;	/* sequence of elements <Delete> of XSD type tt:ObjectId */
	tt__ObjectId **Delete;
	tt__ObjectTreeExtension *Extension;	/* optional element of XSD type tt:ObjectTreeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectTree (688)
	virtual int soap_type(void) const { return 688; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectTree, default initialized and not managed by a soap context
	virtual tt__ObjectTree *soap_alloc(void) const { return SOAP_NEW(tt__ObjectTree); }
	         tt__ObjectTree() { tt__ObjectTree::soap_default(NULL); }
	virtual ~tt__ObjectTree() { }
	friend SOAP_FMAC1 tt__ObjectTree * SOAP_FMAC2 soap_instantiate_tt__ObjectTree(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2031 */
#ifndef SOAP_TYPE_tt__ObjectTreeExtension
#define SOAP_TYPE_tt__ObjectTreeExtension (689)
/* Type tt__ObjectTreeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ObjectTreeExtension complex type: */
class SOAP_CMAC tt__ObjectTreeExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ObjectTreeExtension (689)
	virtual int soap_type(void) const { return 689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ObjectTreeExtension, default initialized and not managed by a soap context
	virtual tt__ObjectTreeExtension *soap_alloc(void) const { return SOAP_NEW(tt__ObjectTreeExtension); }
	         tt__ObjectTreeExtension() { tt__ObjectTreeExtension::soap_default(NULL); }
	virtual ~tt__ObjectTreeExtension() { }
	friend SOAP_FMAC1 tt__ObjectTreeExtension * SOAP_FMAC2 soap_instantiate_tt__ObjectTreeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2034 */
#ifndef SOAP_TYPE_tt__MotionInCells
#define SOAP_TYPE_tt__MotionInCells (690)
/* Type tt__MotionInCells is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionInCells complex type: */
class SOAP_CMAC tt__MotionInCells : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Columns;	/* required attribute of XSD type xsd:integer */
	char *Rows;	/* required attribute of XSD type xsd:integer */
	xsd__base64Binary Cells;	/* required attribute of XSD type xsd:base64Binary */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionInCells (690)
	virtual int soap_type(void) const { return 690; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionInCells, default initialized and not managed by a soap context
	virtual tt__MotionInCells *soap_alloc(void) const { return SOAP_NEW(tt__MotionInCells); }
	         tt__MotionInCells() { tt__MotionInCells::soap_default(NULL); }
	virtual ~tt__MotionInCells() { }
	friend SOAP_FMAC1 tt__MotionInCells * SOAP_FMAC2 soap_instantiate_tt__MotionInCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2037 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (691)
/* Type tt__AnalyticsEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType
{
public:
	int __sizeAnalyticsModule;	/* sequence of elements <AnalyticsModule> of XSD type tt:Config */
	tt__Config **AnalyticsModule;
	tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfiguration (691)
	virtual int soap_type(void) const { return 691; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfiguration); }
	         tt__AnalyticsEngineConfiguration() { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2040 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (692)
/* Type tt__AnalyticsEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (692)
	virtual int soap_type(void) const { return 692; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineConfigurationExtension); }
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2043 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (693)
/* Type tt__RuleEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RuleEngineConfiguration complex type: */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType
{
public:
	int __sizeRule;	/* sequence of elements <Rule> of XSD type tt:Config */
	tt__Config **Rule;
	tt__RuleEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:RuleEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfiguration (693)
	virtual int soap_type(void) const { return 693; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfiguration); }
	         tt__RuleEngineConfiguration() { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
	friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2046 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (694)
/* Type tt__RuleEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RuleEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RuleEngineConfigurationExtension (694)
	virtual int soap_type(void) const { return 694; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RuleEngineConfigurationExtension); }
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2049 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (695)
/* Type tt__Config is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Config complex type: */
class SOAP_CMAC tt__Config : public xsd__anyType
{
public:
	tt__ItemList *Parameters;	/* required element of XSD type tt:ItemList */
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Config (695)
	virtual int soap_type(void) const { return 695; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Config, default initialized and not managed by a soap context
	virtual tt__Config *soap_alloc(void) const { return SOAP_NEW(tt__Config); }
	         tt__Config() { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
	friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22356 */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1972)
/* tt:ConfigDescription-Messages complex type: */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of XSD type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of XSD type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of XSD type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	char *ParentTopic;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__ConfigDescription_Messages (1972)
	virtual int soap_type(void) const { return 1972; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__ConfigDescription_Messages, default initialized and not managed by a soap context
	virtual _tt__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW(_tt__ConfigDescription_Messages); }
	         _tt__ConfigDescription_Messages() { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
	friend SOAP_FMAC1 _tt__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__tt__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2052 */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (696)
/* Type tt__ConfigDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigDescription complex type: */
class SOAP_CMAC tt__ConfigDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Parameters;	/* required element of XSD type tt:ItemListDescription */
	int __sizeMessages;	/* sequence of elements <Messages> of XSD type tt:ConfigDescription-Messages */
	_tt__ConfigDescription_Messages *Messages;
	tt__ConfigDescriptionExtension *Extension;	/* optional element of XSD type tt:ConfigDescriptionExtension */
	char *Name;	/* required attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescription (696)
	virtual int soap_type(void) const { return 696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescription, default initialized and not managed by a soap context
	virtual tt__ConfigDescription *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescription); }
	         tt__ConfigDescription() { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
	friend SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2055 */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (697)
/* Type tt__ConfigDescriptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ConfigDescriptionExtension complex type: */
class SOAP_CMAC tt__ConfigDescriptionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ConfigDescriptionExtension (697)
	virtual int soap_type(void) const { return 697; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ConfigDescriptionExtension, default initialized and not managed by a soap context
	virtual tt__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__ConfigDescriptionExtension); }
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
	friend SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2058 */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (698)
/* Type tt__SupportedRules is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedRules complex type: */
class SOAP_CMAC tt__SupportedRules : public xsd__anyType
{
public:
	int __sizeRuleContentSchemaLocation;	/* sequence of elements <RuleContentSchemaLocation> of XSD type xsd:anyURI */
	char **RuleContentSchemaLocation;
	int __sizeRuleDescription;	/* sequence of elements <RuleDescription> of XSD type tt:ConfigDescription */
	tt__ConfigDescription **RuleDescription;
	tt__SupportedRulesExtension *Extension;	/* optional element of XSD type tt:SupportedRulesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRules (698)
	virtual int soap_type(void) const { return 698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRules, default initialized and not managed by a soap context
	virtual tt__SupportedRules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRules); }
	         tt__SupportedRules() { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
	friend SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2061 */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (699)
/* Type tt__SupportedRulesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedRulesExtension complex type: */
class SOAP_CMAC tt__SupportedRulesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedRulesExtension (699)
	virtual int soap_type(void) const { return 699; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedRulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedRulesExtension); }
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2064 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (700)
/* Type tt__SupportedAnalyticsModules is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedAnalyticsModules complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModules : public xsd__anyType
{
public:
	int __sizeAnalyticsModuleContentSchemaLocation;	/* sequence of elements <AnalyticsModuleContentSchemaLocation> of XSD type xsd:anyURI */
	char **AnalyticsModuleContentSchemaLocation;
	int __sizeAnalyticsModuleDescription;	/* sequence of elements <AnalyticsModuleDescription> of XSD type tt:ConfigDescription */
	tt__ConfigDescription **AnalyticsModuleDescription;
	tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of XSD type tt:SupportedAnalyticsModulesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModules (700)
	virtual int soap_type(void) const { return 700; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModules, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModules); }
	         tt__SupportedAnalyticsModules() { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2067 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (701)
/* Type tt__SupportedAnalyticsModulesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SupportedAnalyticsModulesExtension complex type: */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (701)
	virtual int soap_type(void) const { return 701; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
	virtual tt__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW(tt__SupportedAnalyticsModulesExtension); }
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
	friend SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2070 */
#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (702)
/* Type tt__PolygonConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolygonConfiguration complex type: */
class SOAP_CMAC tt__PolygonConfiguration : public xsd__anyType
{
public:
	tt__Polygon *Polygon;	/* required element of XSD type tt:Polygon */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolygonConfiguration (702)
	virtual int soap_type(void) const { return 702; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolygonConfiguration, default initialized and not managed by a soap context
	virtual tt__PolygonConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolygonConfiguration); }
	         tt__PolygonConfiguration() { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
	friend SOAP_FMAC1 tt__PolygonConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolygonConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2073 */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (703)
/* Type tt__PolylineArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArray complex type: */
class SOAP_CMAC tt__PolylineArray : public xsd__anyType
{
public:
	int __sizeSegment;	/* sequence of elements <Segment> of XSD type tt:Polyline */
	tt__Polyline **Segment;
	tt__PolylineArrayExtension *Extension;	/* optional element of XSD type tt:PolylineArrayExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArray (703)
	virtual int soap_type(void) const { return 703; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArray, default initialized and not managed by a soap context
	virtual tt__PolylineArray *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArray); }
	         tt__PolylineArray() { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
	friend SOAP_FMAC1 tt__PolylineArray * SOAP_FMAC2 soap_instantiate_tt__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2076 */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (704)
/* Type tt__PolylineArrayExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArrayExtension complex type: */
class SOAP_CMAC tt__PolylineArrayExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayExtension (704)
	virtual int soap_type(void) const { return 704; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayExtension, default initialized and not managed by a soap context
	virtual tt__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayExtension); }
	         tt__PolylineArrayExtension() { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
	friend SOAP_FMAC1 tt__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2079 */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (705)
/* Type tt__PolylineArrayConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PolylineArrayConfiguration complex type: */
class SOAP_CMAC tt__PolylineArrayConfiguration : public xsd__anyType
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of XSD type tt:PolylineArray */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PolylineArrayConfiguration (705)
	virtual int soap_type(void) const { return 705; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PolylineArrayConfiguration, default initialized and not managed by a soap context
	virtual tt__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PolylineArrayConfiguration); }
	         tt__PolylineArrayConfiguration() { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
	friend SOAP_FMAC1 tt__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2082 */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (706)
/* Type tt__MotionExpression is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionExpression complex type: */
class SOAP_CMAC tt__MotionExpression : public xsd__anyType
{
public:
	char *Expression;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpression (706)
	virtual int soap_type(void) const { return 706; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpression, default initialized and not managed by a soap context
	virtual tt__MotionExpression *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpression); }
	         tt__MotionExpression() { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
	friend SOAP_FMAC1 tt__MotionExpression * SOAP_FMAC2 soap_instantiate_tt__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2085 */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (707)
/* Type tt__MotionExpressionConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MotionExpressionConfiguration complex type: */
class SOAP_CMAC tt__MotionExpressionConfiguration : public xsd__anyType
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of XSD type tt:MotionExpression */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MotionExpressionConfiguration (707)
	virtual int soap_type(void) const { return 707; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MotionExpressionConfiguration, default initialized and not managed by a soap context
	virtual tt__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MotionExpressionConfiguration); }
	         tt__MotionExpressionConfiguration() { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
	friend SOAP_FMAC1 tt__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_tt__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2088 */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (708)
/* Type tt__CellLayout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CellLayout complex type: */
class SOAP_CMAC tt__CellLayout : public xsd__anyType
{
public:
	tt__Transformation *Transformation;	/* required element of XSD type tt:Transformation */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Columns;	/* required attribute of XSD type xsd:integer */
	char *Rows;	/* required attribute of XSD type xsd:integer */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CellLayout (708)
	virtual int soap_type(void) const { return 708; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CellLayout, default initialized and not managed by a soap context
	virtual tt__CellLayout *soap_alloc(void) const { return SOAP_NEW(tt__CellLayout); }
	         tt__CellLayout() { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
	friend SOAP_FMAC1 tt__CellLayout * SOAP_FMAC2 soap_instantiate_tt__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22842 */
#ifndef SOAP_TYPE__tt__union_MetadataStream
#define SOAP_TYPE__tt__union_MetadataStream (1989)
/* xsd:choice complex type: */
union _tt__union_MetadataStream
{
#define SOAP_UNION__tt__union_MetadataStream_VideoAnalytics	(1)
	tt__VideoAnalyticsStream *VideoAnalytics;
#define SOAP_UNION__tt__union_MetadataStream_PTZ	(2)
	tt__PTZStream *PTZ;
#define SOAP_UNION__tt__union_MetadataStream_Event	(3)
	tt__EventStream *Event;
#define SOAP_UNION__tt__union_MetadataStream_Extension	(4)
	tt__MetadataStreamExtension *Extension;
};
#endif

/* ../../wsdl/onvif.h:22829 */
#ifndef SOAP_TYPE___tt__union_MetadataStream
#define SOAP_TYPE___tt__union_MetadataStream (1984)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_MetadataStream
{
public:
	int __union_MetadataStream;	/* union discriminant (of union defined below) */
	union _tt__union_MetadataStream union_MetadataStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_MetadataStream (1984)
	virtual int soap_type(void) const { return 1984; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_MetadataStream, default initialized and not managed by a soap context
	virtual __tt__union_MetadataStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_MetadataStream); }
	         __tt__union_MetadataStream() { __tt__union_MetadataStream::soap_default(NULL); }
	virtual ~__tt__union_MetadataStream() { }
	friend SOAP_FMAC1 __tt__union_MetadataStream * SOAP_FMAC2 soap_instantiate___tt__union_MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2091 */
#ifndef SOAP_TYPE_tt__MetadataStream
#define SOAP_TYPE_tt__MetadataStream (709)
/* Type tt__MetadataStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataStream complex type: */
class SOAP_CMAC tt__MetadataStream : public xsd__anyType
{
public:
	int __size_MetadataStream;	/* sequence of elements <-union-MetadataStream> of XSD type -tt:union-MetadataStream */
	__tt__union_MetadataStream *__union_MetadataStream;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataStream (709)
	virtual int soap_type(void) const { return 709; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataStream, default initialized and not managed by a soap context
	virtual tt__MetadataStream *soap_alloc(void) const { return SOAP_NEW(tt__MetadataStream); }
	         tt__MetadataStream() { tt__MetadataStream::soap_default(NULL); }
	virtual ~tt__MetadataStream() { }
	friend SOAP_FMAC1 tt__MetadataStream * SOAP_FMAC2 soap_instantiate_tt__MetadataStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2094 */
#ifndef SOAP_TYPE_tt__MetadataStreamExtension
#define SOAP_TYPE_tt__MetadataStreamExtension (710)
/* Type tt__MetadataStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataStreamExtension complex type: */
class SOAP_CMAC tt__MetadataStreamExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataStreamExtension (710)
	virtual int soap_type(void) const { return 710; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataStreamExtension, default initialized and not managed by a soap context
	virtual tt__MetadataStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataStreamExtension); }
	         tt__MetadataStreamExtension() { tt__MetadataStreamExtension::soap_default(NULL); }
	virtual ~tt__MetadataStreamExtension() { }
	friend SOAP_FMAC1 tt__MetadataStreamExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22904 */
#ifndef SOAP_TYPE__tt__union_VideoAnalyticsStream
#define SOAP_TYPE__tt__union_VideoAnalyticsStream (1994)
/* xsd:choice complex type: */
union _tt__union_VideoAnalyticsStream
{
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Frame	(1)
	tt__Frame *Frame;
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Extension	(2)
	tt__VideoAnalyticsStreamExtension *Extension;
};
#endif

/* ../../wsdl/onvif.h:22894 */
#ifndef SOAP_TYPE___tt__union_VideoAnalyticsStream
#define SOAP_TYPE___tt__union_VideoAnalyticsStream (1991)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_VideoAnalyticsStream
{
public:
	int __union_VideoAnalyticsStream;	/* union discriminant (of union defined below) */
	union _tt__union_VideoAnalyticsStream union_VideoAnalyticsStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_VideoAnalyticsStream (1991)
	virtual int soap_type(void) const { return 1991; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_VideoAnalyticsStream, default initialized and not managed by a soap context
	virtual __tt__union_VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_VideoAnalyticsStream); }
	         __tt__union_VideoAnalyticsStream() { __tt__union_VideoAnalyticsStream::soap_default(NULL); }
	virtual ~__tt__union_VideoAnalyticsStream() { }
	friend SOAP_FMAC1 __tt__union_VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate___tt__union_VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2097 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsStream
#define SOAP_TYPE_tt__VideoAnalyticsStream (711)
/* Type tt__VideoAnalyticsStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsStream complex type: */
class SOAP_CMAC tt__VideoAnalyticsStream : public xsd__anyType
{
public:
	int __size_VideoAnalyticsStream;	/* sequence of elements <-union-VideoAnalyticsStream> of XSD type -tt:union-VideoAnalyticsStream */
	__tt__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsStream (711)
	virtual int soap_type(void) const { return 711; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsStream, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsStream *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsStream); }
	         tt__VideoAnalyticsStream() { tt__VideoAnalyticsStream::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStream() { }
	friend SOAP_FMAC1 tt__VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2100 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsStreamExtension
#define SOAP_TYPE_tt__VideoAnalyticsStreamExtension (712)
/* Type tt__VideoAnalyticsStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsStreamExtension complex type: */
class SOAP_CMAC tt__VideoAnalyticsStreamExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsStreamExtension (712)
	virtual int soap_type(void) const { return 712; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsStreamExtension, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsStreamExtension); }
	         tt__VideoAnalyticsStreamExtension() { tt__VideoAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStreamExtension() { }
	friend SOAP_FMAC1 tt__VideoAnalyticsStreamExtension * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:22960 */
#ifndef SOAP_TYPE__tt__union_PTZStream
#define SOAP_TYPE__tt__union_PTZStream (1998)
/* xsd:choice complex type: */
union _tt__union_PTZStream
{
#define SOAP_UNION__tt__union_PTZStream_PTZStatus	(1)
	tt__PTZStatus *PTZStatus;
#define SOAP_UNION__tt__union_PTZStream_Extension	(2)
	tt__PTZStreamExtension *Extension;
};
#endif

/* ../../wsdl/onvif.h:22950 */
#ifndef SOAP_TYPE___tt__union_PTZStream
#define SOAP_TYPE___tt__union_PTZStream (1996)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_PTZStream
{
public:
	int __union_PTZStream;	/* union discriminant (of union defined below) */
	union _tt__union_PTZStream union_PTZStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_PTZStream (1996)
	virtual int soap_type(void) const { return 1996; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_PTZStream, default initialized and not managed by a soap context
	virtual __tt__union_PTZStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_PTZStream); }
	         __tt__union_PTZStream() { __tt__union_PTZStream::soap_default(NULL); }
	virtual ~__tt__union_PTZStream() { }
	friend SOAP_FMAC1 __tt__union_PTZStream * SOAP_FMAC2 soap_instantiate___tt__union_PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2103 */
#ifndef SOAP_TYPE_tt__PTZStream
#define SOAP_TYPE_tt__PTZStream (713)
/* Type tt__PTZStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStream complex type: */
class SOAP_CMAC tt__PTZStream : public xsd__anyType
{
public:
	int __size_PTZStream;	/* sequence of elements <-union-PTZStream> of XSD type -tt:union-PTZStream */
	__tt__union_PTZStream *__union_PTZStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStream (713)
	virtual int soap_type(void) const { return 713; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStream, default initialized and not managed by a soap context
	virtual tt__PTZStream *soap_alloc(void) const { return SOAP_NEW(tt__PTZStream); }
	         tt__PTZStream() { tt__PTZStream::soap_default(NULL); }
	virtual ~tt__PTZStream() { }
	friend SOAP_FMAC1 tt__PTZStream * SOAP_FMAC2 soap_instantiate_tt__PTZStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2106 */
#ifndef SOAP_TYPE_tt__PTZStreamExtension
#define SOAP_TYPE_tt__PTZStreamExtension (714)
/* Type tt__PTZStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZStreamExtension complex type: */
class SOAP_CMAC tt__PTZStreamExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZStreamExtension (714)
	virtual int soap_type(void) const { return 714; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZStreamExtension, default initialized and not managed by a soap context
	virtual tt__PTZStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__PTZStreamExtension); }
	         tt__PTZStreamExtension() { tt__PTZStreamExtension::soap_default(NULL); }
	virtual ~tt__PTZStreamExtension() { }
	friend SOAP_FMAC1 tt__PTZStreamExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:23016 */
#ifndef SOAP_TYPE__tt__union_EventStream
#define SOAP_TYPE__tt__union_EventStream (2003)
/* xsd:choice complex type: */
union _tt__union_EventStream
{
#define SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage	(1)
	wsnt__NotificationMessageHolderType *wsnt__NotificationMessage;
#define SOAP_UNION__tt__union_EventStream_Extension	(2)
	tt__EventStreamExtension *Extension;
};
#endif

/* ../../wsdl/onvif.h:23006 */
#ifndef SOAP_TYPE___tt__union_EventStream
#define SOAP_TYPE___tt__union_EventStream (2000)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_EventStream
{
public:
	int __union_EventStream;	/* union discriminant (of union defined below) */
	union _tt__union_EventStream union_EventStream;
public:
	/// Return the unique type ID value SOAP_TYPE___tt__union_EventStream (2000)
	virtual int soap_type(void) const { return 2000; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tt__union_EventStream, default initialized and not managed by a soap context
	virtual __tt__union_EventStream *soap_alloc(void) const { return SOAP_NEW(__tt__union_EventStream); }
	         __tt__union_EventStream() { __tt__union_EventStream::soap_default(NULL); }
	virtual ~__tt__union_EventStream() { }
	friend SOAP_FMAC1 __tt__union_EventStream * SOAP_FMAC2 soap_instantiate___tt__union_EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2109 */
#ifndef SOAP_TYPE_tt__EventStream
#define SOAP_TYPE_tt__EventStream (715)
/* Type tt__EventStream is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventStream complex type: */
class SOAP_CMAC tt__EventStream : public xsd__anyType
{
public:
	int __size_EventStream;	/* sequence of elements <-union-EventStream> of XSD type -tt:union-EventStream */
	__tt__union_EventStream *__union_EventStream;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventStream (715)
	virtual int soap_type(void) const { return 715; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventStream, default initialized and not managed by a soap context
	virtual tt__EventStream *soap_alloc(void) const { return SOAP_NEW(tt__EventStream); }
	         tt__EventStream() { tt__EventStream::soap_default(NULL); }
	virtual ~tt__EventStream() { }
	friend SOAP_FMAC1 tt__EventStream * SOAP_FMAC2 soap_instantiate_tt__EventStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2112 */
#ifndef SOAP_TYPE_tt__EventStreamExtension
#define SOAP_TYPE_tt__EventStreamExtension (716)
/* Type tt__EventStreamExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventStreamExtension complex type: */
class SOAP_CMAC tt__EventStreamExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventStreamExtension (716)
	virtual int soap_type(void) const { return 716; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventStreamExtension, default initialized and not managed by a soap context
	virtual tt__EventStreamExtension *soap_alloc(void) const { return SOAP_NEW(tt__EventStreamExtension); }
	         tt__EventStreamExtension() { tt__EventStreamExtension::soap_default(NULL); }
	virtual ~tt__EventStreamExtension() { }
	friend SOAP_FMAC1 tt__EventStreamExtension * SOAP_FMAC2 soap_instantiate_tt__EventStreamExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2115 */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (717)
/* Type tt__PaneConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneConfiguration complex type: */
class SOAP_CMAC tt__PaneConfiguration : public xsd__anyType
{
public:
	char *PaneName;	/* optional element of XSD type xsd:string */
	char *AudioOutputToken;	/* optional element of XSD type tt:ReferenceToken */
	char *AudioSourceToken;	/* optional element of XSD type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of XSD type tt:AudioEncoderConfiguration */
	char *ReceiverToken;	/* optional element of XSD type tt:ReferenceToken */
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneConfiguration (717)
	virtual int soap_type(void) const { return 717; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneConfiguration, default initialized and not managed by a soap context
	virtual tt__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PaneConfiguration); }
	         tt__PaneConfiguration() { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
	friend SOAP_FMAC1 tt__PaneConfiguration * SOAP_FMAC2 soap_instantiate_tt__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2118 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (718)
/* Type tt__PaneLayout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneLayout complex type: */
class SOAP_CMAC tt__PaneLayout : public xsd__anyType
{
public:
	char *Pane;	/* required element of XSD type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of XSD type tt:Rectangle */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayout (718)
	virtual int soap_type(void) const { return 718; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
	virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayout); }
	         tt__PaneLayout() { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
	friend SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2121 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (719)
/* Type tt__Layout is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Layout complex type: */
class SOAP_CMAC tt__Layout : public xsd__anyType
{
public:
	int __sizePaneLayout;	/* sequence of elements <PaneLayout> of XSD type tt:PaneLayout */
	tt__PaneLayout **PaneLayout;
	tt__LayoutExtension *Extension;	/* optional element of XSD type tt:LayoutExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Layout (719)
	virtual int soap_type(void) const { return 719; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Layout, default initialized and not managed by a soap context
	virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW(tt__Layout); }
	         tt__Layout() { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
	friend SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2124 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (720)
/* Type tt__LayoutExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutExtension complex type: */
class SOAP_CMAC tt__LayoutExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutExtension (720)
	virtual int soap_type(void) const { return 720; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
	virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutExtension); }
	         tt__LayoutExtension() { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
	friend SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2127 */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (721)
/* Type tt__CodingCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CodingCapabilities complex type: */
class SOAP_CMAC tt__CodingCapabilities : public xsd__anyType
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of XSD type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of XSD type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of XSD type tt:VideoDecoderConfigurationOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CodingCapabilities (721)
	virtual int soap_type(void) const { return 721; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CodingCapabilities, default initialized and not managed by a soap context
	virtual tt__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW(tt__CodingCapabilities); }
	         tt__CodingCapabilities() { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
	friend SOAP_FMAC1 tt__CodingCapabilities * SOAP_FMAC2 soap_instantiate_tt__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2130 */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (722)
/* Type tt__LayoutOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutOptions complex type: */
class SOAP_CMAC tt__LayoutOptions : public xsd__anyType
{
public:
	int __sizePaneLayoutOptions;	/* sequence of elements <PaneLayoutOptions> of XSD type tt:PaneLayoutOptions */
	tt__PaneLayoutOptions **PaneLayoutOptions;
	tt__LayoutOptionsExtension *Extension;	/* optional element of XSD type tt:LayoutOptionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptions (722)
	virtual int soap_type(void) const { return 722; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptions, default initialized and not managed by a soap context
	virtual tt__LayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptions); }
	         tt__LayoutOptions() { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
	friend SOAP_FMAC1 tt__LayoutOptions * SOAP_FMAC2 soap_instantiate_tt__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2133 */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (723)
/* Type tt__LayoutOptionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:LayoutOptionsExtension complex type: */
class SOAP_CMAC tt__LayoutOptionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__LayoutOptionsExtension (723)
	virtual int soap_type(void) const { return 723; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__LayoutOptionsExtension, default initialized and not managed by a soap context
	virtual tt__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW(tt__LayoutOptionsExtension); }
	         tt__LayoutOptionsExtension() { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
	friend SOAP_FMAC1 tt__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2136 */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (724)
/* Type tt__PaneLayoutOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneLayoutOptions complex type: */
class SOAP_CMAC tt__PaneLayoutOptions : public xsd__anyType
{
public:
	int __sizeArea;	/* sequence of elements <Area> of XSD type tt:Rectangle */
	tt__Rectangle **Area;
	tt__PaneOptionExtension *Extension;	/* optional element of XSD type tt:PaneOptionExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneLayoutOptions (724)
	virtual int soap_type(void) const { return 724; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneLayoutOptions, default initialized and not managed by a soap context
	virtual tt__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW(tt__PaneLayoutOptions); }
	         tt__PaneLayoutOptions() { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
	friend SOAP_FMAC1 tt__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_tt__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2139 */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (725)
/* Type tt__PaneOptionExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PaneOptionExtension complex type: */
class SOAP_CMAC tt__PaneOptionExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PaneOptionExtension (725)
	virtual int soap_type(void) const { return 725; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PaneOptionExtension, default initialized and not managed by a soap context
	virtual tt__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW(tt__PaneOptionExtension); }
	         tt__PaneOptionExtension() { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
	friend SOAP_FMAC1 tt__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_tt__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2142 */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (726)
/* Type tt__Receiver is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Receiver complex type: */
class SOAP_CMAC tt__Receiver : public xsd__anyType
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Receiver (726)
	virtual int soap_type(void) const { return 726; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Receiver, default initialized and not managed by a soap context
	virtual tt__Receiver *soap_alloc(void) const { return SOAP_NEW(tt__Receiver); }
	         tt__Receiver() { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
	friend SOAP_FMAC1 tt__Receiver * SOAP_FMAC2 soap_instantiate_tt__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2145 */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (727)
/* Type tt__ReceiverConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverConfiguration complex type: */
class SOAP_CMAC tt__ReceiverConfiguration : public xsd__anyType
{
public:
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	char *MediaUri;	/* required element of XSD type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverConfiguration (727)
	virtual int soap_type(void) const { return 727; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverConfiguration, default initialized and not managed by a soap context
	virtual tt__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverConfiguration); }
	         tt__ReceiverConfiguration() { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
	friend SOAP_FMAC1 tt__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2148 */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (728)
/* Type tt__ReceiverStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReceiverStateInformation complex type: */
class SOAP_CMAC tt__ReceiverStateInformation : public xsd__anyType
{
public:
	enum tt__ReceiverState State;	/* required element of XSD type tt:ReceiverState */
	bool AutoCreated;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReceiverStateInformation (728)
	virtual int soap_type(void) const { return 728; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReceiverStateInformation, default initialized and not managed by a soap context
	virtual tt__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__ReceiverStateInformation); }
	         tt__ReceiverStateInformation() { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
	friend SOAP_FMAC1 tt__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_tt__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2151 */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (729)
/* Type tt__SourceReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceReference complex type: */
class SOAP_CMAC tt__SourceReference : public xsd__anyType
{
public:
	char *Token;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Type;	/* optional attribute of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceReference (729)
	virtual int soap_type(void) const { return 729; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceReference, default initialized and not managed by a soap context
	virtual tt__SourceReference *soap_alloc(void) const { return SOAP_NEW(tt__SourceReference); }
	         tt__SourceReference() { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
	friend SOAP_FMAC1 tt__SourceReference * SOAP_FMAC2 soap_instantiate_tt__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2154 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (730)
/* Type tt__DateTimeRange is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DateTimeRange complex type: */
class SOAP_CMAC tt__DateTimeRange : public xsd__anyType
{
public:
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DateTimeRange (730)
	virtual int soap_type(void) const { return 730; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
	virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW(tt__DateTimeRange); }
	         tt__DateTimeRange() { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
	friend SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2157 */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (731)
/* Type tt__RecordingSummary is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingSummary complex type: */
class SOAP_CMAC tt__RecordingSummary : public xsd__anyType
{
public:
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataUntil;	/* required element of XSD type xsd:dateTime */
	int NumberRecordings;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSummary (731)
	virtual int soap_type(void) const { return 731; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSummary, default initialized and not managed by a soap context
	virtual tt__RecordingSummary *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSummary); }
	         tt__RecordingSummary() { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
	friend SOAP_FMAC1 tt__RecordingSummary * SOAP_FMAC2 soap_instantiate_tt__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2160 */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (732)
/* Type tt__SearchScope is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchScope complex type: */
class SOAP_CMAC tt__SearchScope : public xsd__anyType
{
public:
	int __sizeIncludedSources;	/* sequence of elements <IncludedSources> of XSD type tt:SourceReference */
	tt__SourceReference **IncludedSources;
	int __sizeIncludedRecordings;	/* sequence of elements <IncludedRecordings> of XSD type tt:RecordingReference */
	char **IncludedRecordings;
	char *RecordingInformationFilter;	/* optional element of XSD type tt:XPathExpression */
	tt__SearchScopeExtension *Extension;	/* optional element of XSD type tt:SearchScopeExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScope (732)
	virtual int soap_type(void) const { return 732; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScope, default initialized and not managed by a soap context
	virtual tt__SearchScope *soap_alloc(void) const { return SOAP_NEW(tt__SearchScope); }
	         tt__SearchScope() { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
	friend SOAP_FMAC1 tt__SearchScope * SOAP_FMAC2 soap_instantiate_tt__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2163 */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (733)
/* Type tt__SearchScopeExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SearchScopeExtension complex type: */
class SOAP_CMAC tt__SearchScopeExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SearchScopeExtension (733)
	virtual int soap_type(void) const { return 733; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SearchScopeExtension, default initialized and not managed by a soap context
	virtual tt__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW(tt__SearchScopeExtension); }
	         tt__SearchScopeExtension() { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
	friend SOAP_FMAC1 tt__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_tt__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2169 */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (735)
/* Type tt__PTZPositionFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZPositionFilter complex type: */
class SOAP_CMAC tt__PTZPositionFilter : public xsd__anyType
{
public:
	tt__PTZVector *MinPosition;	/* required element of XSD type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of XSD type tt:PTZVector */
	bool EnterOrExit;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZPositionFilter (735)
	virtual int soap_type(void) const { return 735; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZPositionFilter, default initialized and not managed by a soap context
	virtual tt__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW(tt__PTZPositionFilter); }
	         tt__PTZPositionFilter() { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
	friend SOAP_FMAC1 tt__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_tt__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2172 */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (736)
/* Type tt__MetadataFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataFilter complex type: */
class SOAP_CMAC tt__MetadataFilter : public xsd__anyType
{
public:
	char *MetadataStreamFilter;	/* required element of XSD type tt:XPathExpression */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataFilter (736)
	virtual int soap_type(void) const { return 736; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataFilter, default initialized and not managed by a soap context
	virtual tt__MetadataFilter *soap_alloc(void) const { return SOAP_NEW(tt__MetadataFilter); }
	         tt__MetadataFilter() { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
	friend SOAP_FMAC1 tt__MetadataFilter * SOAP_FMAC2 soap_instantiate_tt__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2175 */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (737)
/* Type tt__FindRecordingResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindRecordingResultList complex type: */
class SOAP_CMAC tt__FindRecordingResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeRecordingInformation;	/* sequence of elements <RecordingInformation> of XSD type tt:RecordingInformation */
	tt__RecordingInformation **RecordingInformation;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindRecordingResultList (737)
	virtual int soap_type(void) const { return 737; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindRecordingResultList, default initialized and not managed by a soap context
	virtual tt__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindRecordingResultList); }
	         tt__FindRecordingResultList() { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
	friend SOAP_FMAC1 tt__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_tt__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2178 */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (738)
/* Type tt__FindEventResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindEventResultList complex type: */
class SOAP_CMAC tt__FindEventResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindEventResult */
	tt__FindEventResult **Result;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResultList (738)
	virtual int soap_type(void) const { return 738; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResultList, default initialized and not managed by a soap context
	virtual tt__FindEventResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResultList); }
	         tt__FindEventResultList() { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
	friend SOAP_FMAC1 tt__FindEventResultList * SOAP_FMAC2 soap_instantiate_tt__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2181 */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (739)
/* Type tt__FindEventResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindEventResult complex type: */
class SOAP_CMAC tt__FindEventResult : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	wsnt__NotificationMessageHolderType *Event;	/* required element of XSD type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindEventResult (739)
	virtual int soap_type(void) const { return 739; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindEventResult, default initialized and not managed by a soap context
	virtual tt__FindEventResult *soap_alloc(void) const { return SOAP_NEW(tt__FindEventResult); }
	         tt__FindEventResult() { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
	friend SOAP_FMAC1 tt__FindEventResult * SOAP_FMAC2 soap_instantiate_tt__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2184 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (740)
/* Type tt__FindPTZPositionResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindPTZPositionResultList complex type: */
class SOAP_CMAC tt__FindPTZPositionResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindPTZPositionResult */
	tt__FindPTZPositionResult **Result;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResultList (740)
	virtual int soap_type(void) const { return 740; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResultList, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResultList); }
	         tt__FindPTZPositionResultList() { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2187 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (741)
/* Type tt__FindPTZPositionResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindPTZPositionResult complex type: */
class SOAP_CMAC tt__FindPTZPositionResult : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindPTZPositionResult (741)
	virtual int soap_type(void) const { return 741; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindPTZPositionResult, default initialized and not managed by a soap context
	virtual tt__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW(tt__FindPTZPositionResult); }
	         tt__FindPTZPositionResult() { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
	friend SOAP_FMAC1 tt__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2190 */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (742)
/* Type tt__FindMetadataResultList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindMetadataResultList complex type: */
class SOAP_CMAC tt__FindMetadataResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of XSD type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> of XSD type tt:FindMetadataResult */
	tt__FindMetadataResult **Result;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResultList (742)
	virtual int soap_type(void) const { return 742; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResultList, default initialized and not managed by a soap context
	virtual tt__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResultList); }
	         tt__FindMetadataResultList() { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
	friend SOAP_FMAC1 tt__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2193 */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (743)
/* Type tt__FindMetadataResult is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:FindMetadataResult complex type: */
class SOAP_CMAC tt__FindMetadataResult : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	time_t Time;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__FindMetadataResult (743)
	virtual int soap_type(void) const { return 743; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__FindMetadataResult, default initialized and not managed by a soap context
	virtual tt__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW(tt__FindMetadataResult); }
	         tt__FindMetadataResult() { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
	friend SOAP_FMAC1 tt__FindMetadataResult * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2196 */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (744)
/* Type tt__RecordingInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingInformation complex type: */
class SOAP_CMAC tt__RecordingInformation : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of XSD type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of XSD type xsd:dateTime */
	char *Content;	/* required element of XSD type tt:Description */
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:TrackInformation */
	tt__TrackInformation **Track;
	enum tt__RecordingStatus RecordingStatus;	/* required element of XSD type tt:RecordingStatus */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingInformation (744)
	virtual int soap_type(void) const { return 744; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingInformation, default initialized and not managed by a soap context
	virtual tt__RecordingInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingInformation); }
	         tt__RecordingInformation() { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
	friend SOAP_FMAC1 tt__RecordingInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2199 */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (745)
/* Type tt__RecordingSourceInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingSourceInformation complex type: */
class SOAP_CMAC tt__RecordingSourceInformation : public xsd__anyType
{
public:
	char *SourceId;	/* required element of XSD type xsd:anyURI */
	char *Name;	/* required element of XSD type tt:Name */
	char *Location;	/* required element of XSD type tt:Description */
	char *Description;	/* required element of XSD type tt:Description */
	char *Address;	/* required element of XSD type xsd:anyURI */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingSourceInformation (745)
	virtual int soap_type(void) const { return 745; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingSourceInformation, default initialized and not managed by a soap context
	virtual tt__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingSourceInformation); }
	         tt__RecordingSourceInformation() { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
	friend SOAP_FMAC1 tt__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2202 */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (746)
/* Type tt__TrackInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackInformation complex type: */
class SOAP_CMAC tt__TrackInformation : public xsd__anyType
{
public:
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	char *Description;	/* required element of XSD type tt:Description */
	time_t DataFrom;	/* required element of XSD type xsd:dateTime */
	time_t DataTo;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackInformation (746)
	virtual int soap_type(void) const { return 746; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackInformation, default initialized and not managed by a soap context
	virtual tt__TrackInformation *soap_alloc(void) const { return SOAP_NEW(tt__TrackInformation); }
	         tt__TrackInformation() { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
	friend SOAP_FMAC1 tt__TrackInformation * SOAP_FMAC2 soap_instantiate_tt__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2205 */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (747)
/* Type tt__MediaAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MediaAttributes complex type: */
class SOAP_CMAC tt__MediaAttributes : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	int __sizeTrackAttributes;	/* sequence of elements <TrackAttributes> of XSD type tt:TrackAttributes */
	tt__TrackAttributes **TrackAttributes;
	time_t From;	/* required element of XSD type xsd:dateTime */
	time_t Until;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MediaAttributes (747)
	virtual int soap_type(void) const { return 747; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MediaAttributes, default initialized and not managed by a soap context
	virtual tt__MediaAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MediaAttributes); }
	         tt__MediaAttributes() { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
	friend SOAP_FMAC1 tt__MediaAttributes * SOAP_FMAC2 soap_instantiate_tt__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2208 */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (748)
/* Type tt__TrackAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackAttributes complex type: */
class SOAP_CMAC tt__TrackAttributes : public xsd__anyType
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of XSD type tt:TrackInformation */
	tt__VideoAttributes *VideoAttributes;	/* optional element of XSD type tt:VideoAttributes */
	tt__AudioAttributes *AudioAttributes;	/* optional element of XSD type tt:AudioAttributes */
	tt__MetadataAttributes *MetadataAttributes;	/* optional element of XSD type tt:MetadataAttributes */
	tt__TrackAttributesExtension *Extension;	/* optional element of XSD type tt:TrackAttributesExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributes (748)
	virtual int soap_type(void) const { return 748; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributes, default initialized and not managed by a soap context
	virtual tt__TrackAttributes *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributes); }
	         tt__TrackAttributes() { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
	friend SOAP_FMAC1 tt__TrackAttributes * SOAP_FMAC2 soap_instantiate_tt__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2211 */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (749)
/* Type tt__TrackAttributesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackAttributesExtension complex type: */
class SOAP_CMAC tt__TrackAttributesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackAttributesExtension (749)
	virtual int soap_type(void) const { return 749; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackAttributesExtension, default initialized and not managed by a soap context
	virtual tt__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW(tt__TrackAttributesExtension); }
	         tt__TrackAttributesExtension() { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
	friend SOAP_FMAC1 tt__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_tt__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2214 */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (750)
/* Type tt__VideoAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAttributes complex type: */
class SOAP_CMAC tt__VideoAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	int Width;	/* required element of XSD type xsd:int */
	int Height;	/* required element of XSD type xsd:int */
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	float Framerate;	/* required element of XSD type xsd:float */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAttributes (750)
	virtual int soap_type(void) const { return 750; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAttributes, default initialized and not managed by a soap context
	virtual tt__VideoAttributes *soap_alloc(void) const { return SOAP_NEW(tt__VideoAttributes); }
	         tt__VideoAttributes() { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
	friend SOAP_FMAC1 tt__VideoAttributes * SOAP_FMAC2 soap_instantiate_tt__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2217 */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (751)
/* Type tt__AudioAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioAttributes complex type: */
class SOAP_CMAC tt__AudioAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of XSD type xsd:int */
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Samplerate;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioAttributes (751)
	virtual int soap_type(void) const { return 751; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioAttributes, default initialized and not managed by a soap context
	virtual tt__AudioAttributes *soap_alloc(void) const { return SOAP_NEW(tt__AudioAttributes); }
	         tt__AudioAttributes() { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
	friend SOAP_FMAC1 tt__AudioAttributes * SOAP_FMAC2 soap_instantiate_tt__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2220 */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (752)
/* Type tt__MetadataAttributes is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataAttributes complex type: */
class SOAP_CMAC tt__MetadataAttributes : public xsd__anyType
{
public:
	bool CanContainPTZ;	/* required element of XSD type xsd:boolean */
	bool CanContainAnalytics;	/* required element of XSD type xsd:boolean */
	bool CanContainNotifications;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataAttributes (752)
	virtual int soap_type(void) const { return 752; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataAttributes, default initialized and not managed by a soap context
	virtual tt__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW(tt__MetadataAttributes); }
	         tt__MetadataAttributes() { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
	friend SOAP_FMAC1 tt__MetadataAttributes * SOAP_FMAC2 soap_instantiate_tt__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2223 */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (753)
/* Type tt__RecordingConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingConfiguration complex type: */
class SOAP_CMAC tt__RecordingConfiguration : public xsd__anyType
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of XSD type tt:RecordingSourceInformation */
	char *Content;	/* required element of XSD type tt:Description */
	LONG64 MaximumRetentionTime;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingConfiguration (753)
	virtual int soap_type(void) const { return 753; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingConfiguration); }
	         tt__RecordingConfiguration() { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2226 */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (754)
/* Type tt__TrackConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:TrackConfiguration complex type: */
class SOAP_CMAC tt__TrackConfiguration : public xsd__anyType
{
public:
	enum tt__TrackType TrackType;	/* required element of XSD type tt:TrackType */
	char *Description;	/* required element of XSD type tt:Description */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__TrackConfiguration (754)
	virtual int soap_type(void) const { return 754; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__TrackConfiguration, default initialized and not managed by a soap context
	virtual tt__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__TrackConfiguration); }
	         tt__TrackConfiguration() { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
	friend SOAP_FMAC1 tt__TrackConfiguration * SOAP_FMAC2 soap_instantiate_tt__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2229 */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (755)
/* Type tt__GetRecordingsResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetRecordingsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingsResponseItem : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of XSD type tt:RecordingConfiguration */
	tt__GetTracksResponseList *Tracks;	/* required element of XSD type tt:GetTracksResponseList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingsResponseItem (755)
	virtual int soap_type(void) const { return 755; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingsResponseItem); }
	         tt__GetRecordingsResponseItem() { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2232 */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (756)
/* Type tt__GetTracksResponseList is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetTracksResponseList complex type: */
class SOAP_CMAC tt__GetTracksResponseList : public xsd__anyType
{
public:
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:GetTracksResponseItem */
	tt__GetTracksResponseItem **Track;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseList (756)
	virtual int soap_type(void) const { return 756; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseList, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseList); }
	         tt__GetTracksResponseList() { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
	friend SOAP_FMAC1 tt__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2235 */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (757)
/* Type tt__GetTracksResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetTracksResponseItem complex type: */
class SOAP_CMAC tt__GetTracksResponseItem : public xsd__anyType
{
public:
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of XSD type tt:TrackConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetTracksResponseItem (757)
	virtual int soap_type(void) const { return 757; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetTracksResponseItem, default initialized and not managed by a soap context
	virtual tt__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetTracksResponseItem); }
	         tt__GetTracksResponseItem() { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
	friend SOAP_FMAC1 tt__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2238 */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (758)
/* Type tt__RecordingJobConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobConfiguration complex type: */
class SOAP_CMAC tt__RecordingJobConfiguration : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *Mode;	/* required element of XSD type tt:RecordingJobMode */
	int Priority;	/* required element of XSD type xsd:int */
	int __sizeSource;	/* sequence of elements <Source> of XSD type tt:RecordingJobSource */
	tt__RecordingJobSource **Source;
	tt__RecordingJobConfigurationExtension *Extension;	/* optional element of XSD type tt:RecordingJobConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfiguration (758)
	virtual int soap_type(void) const { return 758; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfiguration, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfiguration); }
	         tt__RecordingJobConfiguration() { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
	friend SOAP_FMAC1 tt__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2241 */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (759)
/* Type tt__RecordingJobConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobConfigurationExtension complex type: */
class SOAP_CMAC tt__RecordingJobConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobConfigurationExtension (759)
	virtual int soap_type(void) const { return 759; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobConfigurationExtension); }
	         tt__RecordingJobConfigurationExtension() { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2244 */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (760)
/* Type tt__RecordingJobSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobSource complex type: */
class SOAP_CMAC tt__RecordingJobSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* optional element of XSD type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of XSD type xsd:boolean */
	int __sizeTracks;	/* sequence of elements <Tracks> of XSD type tt:RecordingJobTrack */
	tt__RecordingJobTrack **Tracks;
	tt__RecordingJobSourceExtension *Extension;	/* optional element of XSD type tt:RecordingJobSourceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSource (760)
	virtual int soap_type(void) const { return 760; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSource); }
	         tt__RecordingJobSource() { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
	friend SOAP_FMAC1 tt__RecordingJobSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2247 */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (761)
/* Type tt__RecordingJobSourceExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobSourceExtension complex type: */
class SOAP_CMAC tt__RecordingJobSourceExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobSourceExtension (761)
	virtual int soap_type(void) const { return 761; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobSourceExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobSourceExtension); }
	         tt__RecordingJobSourceExtension() { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2250 */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (762)
/* Type tt__RecordingJobTrack is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobTrack complex type: */
class SOAP_CMAC tt__RecordingJobTrack : public xsd__anyType
{
public:
	char *SourceTag;	/* required element of XSD type xsd:string */
	char *Destination;	/* required element of XSD type tt:TrackReference */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobTrack (762)
	virtual int soap_type(void) const { return 762; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobTrack); }
	         tt__RecordingJobTrack() { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2253 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (763)
/* Type tt__RecordingJobStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateInformation complex type: */
class SOAP_CMAC tt__RecordingJobStateInformation : public xsd__anyType
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	int __sizeSources;	/* sequence of elements <Sources> of XSD type tt:RecordingJobStateSource */
	tt__RecordingJobStateSource **Sources;
	tt__RecordingJobStateInformationExtension *Extension;	/* optional element of XSD type tt:RecordingJobStateInformationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformation (763)
	virtual int soap_type(void) const { return 763; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformation, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformation); }
	         tt__RecordingJobStateInformation() { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2256 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (764)
/* Type tt__RecordingJobStateInformationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateInformationExtension complex type: */
class SOAP_CMAC tt__RecordingJobStateInformationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateInformationExtension (764)
	virtual int soap_type(void) const { return 764; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateInformationExtension); }
	         tt__RecordingJobStateInformationExtension() { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
	friend SOAP_FMAC1 tt__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2259 */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (765)
/* Type tt__RecordingJobStateSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateSource complex type: */
class SOAP_CMAC tt__RecordingJobStateSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* required element of XSD type tt:SourceReference */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	tt__RecordingJobStateTracks *Tracks;	/* required element of XSD type tt:RecordingJobStateTracks */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateSource (765)
	virtual int soap_type(void) const { return 765; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateSource, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateSource); }
	         tt__RecordingJobStateSource() { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
	friend SOAP_FMAC1 tt__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2262 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (766)
/* Type tt__RecordingJobStateTracks is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateTracks complex type: */
class SOAP_CMAC tt__RecordingJobStateTracks : public xsd__anyType
{
public:
	int __sizeTrack;	/* sequence of elements <Track> of XSD type tt:RecordingJobStateTrack */
	tt__RecordingJobStateTrack **Track;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTracks (766)
	virtual int soap_type(void) const { return 766; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTracks, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTracks); }
	         tt__RecordingJobStateTracks() { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2265 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (767)
/* Type tt__RecordingJobStateTrack is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RecordingJobStateTrack complex type: */
class SOAP_CMAC tt__RecordingJobStateTrack : public xsd__anyType
{
public:
	char *SourceTag;	/* required element of XSD type xsd:string */
	char *Destination;	/* required element of XSD type tt:TrackReference */
	char *Error;	/* optional element of XSD type xsd:string */
	char *State;	/* required element of XSD type tt:RecordingJobState */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RecordingJobStateTrack (767)
	virtual int soap_type(void) const { return 767; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RecordingJobStateTrack, default initialized and not managed by a soap context
	virtual tt__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW(tt__RecordingJobStateTrack); }
	         tt__RecordingJobStateTrack() { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
	friend SOAP_FMAC1 tt__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2268 */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (768)
/* Type tt__GetRecordingJobsResponseItem is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:GetRecordingJobsResponseItem complex type: */
class SOAP_CMAC tt__GetRecordingJobsResponseItem : public xsd__anyType
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__GetRecordingJobsResponseItem (768)
	virtual int soap_type(void) const { return 768; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
	virtual tt__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW(tt__GetRecordingJobsResponseItem); }
	         tt__GetRecordingJobsResponseItem() { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
	friend SOAP_FMAC1 tt__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2271 */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (769)
/* Type tt__ReplayConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ReplayConfiguration complex type: */
class SOAP_CMAC tt__ReplayConfiguration : public xsd__anyType
{
public:
	LONG64 SessionTimeout;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ReplayConfiguration (769)
	virtual int soap_type(void) const { return 769; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ReplayConfiguration, default initialized and not managed by a soap context
	virtual tt__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__ReplayConfiguration); }
	         tt__ReplayConfiguration() { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
	friend SOAP_FMAC1 tt__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2277 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (771)
/* Type tt__AnalyticsDeviceEngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceEngineConfiguration complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration : public xsd__anyType
{
public:
	int __sizeEngineConfiguration;	/* sequence of elements <EngineConfiguration> of XSD type tt:EngineConfiguration */
	tt__EngineConfiguration **EngineConfiguration;
	tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of XSD type tt:AnalyticsDeviceEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (771)
	virtual int soap_type(void) const { return 771; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfiguration); }
	         tt__AnalyticsDeviceEngineConfiguration() { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2280 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (772)
/* Type tt__AnalyticsDeviceEngineConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsDeviceEngineConfigurationExtension complex type: */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (772)
	virtual int soap_type(void) const { return 772; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsDeviceEngineConfigurationExtension); }
	         tt__AnalyticsDeviceEngineConfigurationExtension() { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2283 */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (773)
/* Type tt__EngineConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EngineConfiguration complex type: */
class SOAP_CMAC tt__EngineConfiguration : public xsd__anyType
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of XSD type tt:AnalyticsEngineInputInfo */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EngineConfiguration (773)
	virtual int soap_type(void) const { return 773; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EngineConfiguration, default initialized and not managed by a soap context
	virtual tt__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__EngineConfiguration); }
	         tt__EngineConfiguration() { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
	friend SOAP_FMAC1 tt__EngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2286 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (774)
/* Type tt__AnalyticsEngineInputInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInputInfo complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfo : public xsd__anyType
{
public:
	tt__Config *InputInfo;	/* optional element of XSD type tt:Config */
	tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of XSD type tt:AnalyticsEngineInputInfoExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfo (774)
	virtual int soap_type(void) const { return 774; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfo); }
	         tt__AnalyticsEngineInputInfo() { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2289 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (775)
/* Type tt__AnalyticsEngineInputInfoExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInputInfoExtension complex type: */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (775)
	virtual int soap_type(void) const { return 775; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInputInfoExtension); }
	         tt__AnalyticsEngineInputInfoExtension() { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2295 */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (777)
/* Type tt__SourceIdentification is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceIdentification complex type: */
class SOAP_CMAC tt__SourceIdentification : public xsd__anyType
{
public:
	char *Name;	/* required element of XSD type xsd:string */
	int __sizeToken;	/* sequence of elements <Token> of XSD type tt:ReferenceToken */
	char **Token;
	tt__SourceIdentificationExtension *Extension;	/* optional element of XSD type tt:SourceIdentificationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentification (777)
	virtual int soap_type(void) const { return 777; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentification, default initialized and not managed by a soap context
	virtual tt__SourceIdentification *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentification); }
	         tt__SourceIdentification() { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
	friend SOAP_FMAC1 tt__SourceIdentification * SOAP_FMAC2 soap_instantiate_tt__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2298 */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (778)
/* Type tt__SourceIdentificationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:SourceIdentificationExtension complex type: */
class SOAP_CMAC tt__SourceIdentificationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__SourceIdentificationExtension (778)
	virtual int soap_type(void) const { return 778; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__SourceIdentificationExtension, default initialized and not managed by a soap context
	virtual tt__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW(tt__SourceIdentificationExtension); }
	         tt__SourceIdentificationExtension() { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
	friend SOAP_FMAC1 tt__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_tt__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2301 */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (779)
/* Type tt__MetadataInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataInput complex type: */
class SOAP_CMAC tt__MetadataInput : public xsd__anyType
{
public:
	int __sizeMetadataConfig;	/* sequence of elements <MetadataConfig> of XSD type tt:Config */
	tt__Config **MetadataConfig;
	tt__MetadataInputExtension *Extension;	/* optional element of XSD type tt:MetadataInputExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInput (779)
	virtual int soap_type(void) const { return 779; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInput, default initialized and not managed by a soap context
	virtual tt__MetadataInput *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInput); }
	         tt__MetadataInput() { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
	friend SOAP_FMAC1 tt__MetadataInput * SOAP_FMAC2 soap_instantiate_tt__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2304 */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (780)
/* Type tt__MetadataInputExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataInputExtension complex type: */
class SOAP_CMAC tt__MetadataInputExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataInputExtension (780)
	virtual int soap_type(void) const { return 780; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataInputExtension, default initialized and not managed by a soap context
	virtual tt__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW(tt__MetadataInputExtension); }
	         tt__MetadataInputExtension() { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
	friend SOAP_FMAC1 tt__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2310 */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (782)
/* Type tt__AnalyticsStateInformation is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsStateInformation complex type: */
class SOAP_CMAC tt__AnalyticsStateInformation : public xsd__anyType
{
public:
	char *AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	tt__AnalyticsState *State;	/* required element of XSD type tt:AnalyticsState */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsStateInformation (782)
	virtual int soap_type(void) const { return 782; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsStateInformation, default initialized and not managed by a soap context
	virtual tt__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsStateInformation); }
	         tt__AnalyticsStateInformation() { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
	friend SOAP_FMAC1 tt__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_tt__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2313 */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (783)
/* Type tt__AnalyticsState is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsState complex type: */
class SOAP_CMAC tt__AnalyticsState : public xsd__anyType
{
public:
	char *Error;	/* optional element of XSD type xsd:string */
	char *State;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsState (783)
	virtual int soap_type(void) const { return 783; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsState, default initialized and not managed by a soap context
	virtual tt__AnalyticsState *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsState); }
	         tt__AnalyticsState() { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
	friend SOAP_FMAC1 tt__AnalyticsState * SOAP_FMAC2 soap_instantiate_tt__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2316 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (784)
/* Type tt__ActionEngineEventPayload is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ActionEngineEventPayload complex type: */
class SOAP_CMAC tt__ActionEngineEventPayload : public xsd__anyType
{
public:
	struct SOAP_ENV__Envelope *RequestInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Envelope *ResponseInfo;	/* optional element of XSD type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of XSD type SOAP-ENV:Fault */
	tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of XSD type tt:ActionEngineEventPayloadExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayload (784)
	virtual int soap_type(void) const { return 784; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayload, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayload); }
	         tt__ActionEngineEventPayload() { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2319 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (785)
/* Type tt__ActionEngineEventPayloadExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:ActionEngineEventPayloadExtension complex type: */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__ActionEngineEventPayloadExtension (785)
	virtual int soap_type(void) const { return 785; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
	virtual tt__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW(tt__ActionEngineEventPayloadExtension); }
	         tt__ActionEngineEventPayloadExtension() { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
	friend SOAP_FMAC1 tt__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2322 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (786)
/* tt:Message complex type: */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Key;	/* optional element of XSD type tt:ItemList */
	tt__ItemList *Data;	/* optional element of XSD type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of XSD type tt:MessageExtension */
	time_t UtcTime;	/* required attribute of XSD type xsd:dateTime */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute of XSD type tt:PropertyOperation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tt__Message (786)
	virtual int soap_type(void) const { return 786; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tt__Message, default initialized and not managed by a soap context
	virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW(_tt__Message); }
	         _tt__Message() { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
	friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2325 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (787)
/* Type wsnt__QueryExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:QueryExpressionType complex type: */
class SOAP_CMAC wsnt__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__QueryExpressionType (787)
	virtual int soap_type(void) const { return 787; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
	virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__QueryExpressionType); }
	         wsnt__QueryExpressionType() { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
	friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2328 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (788)
/* Type wsnt__TopicExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionType complex type: */
class SOAP_CMAC wsnt__TopicExpressionType : public xsd__anyType
{
public:
	char *__any;
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionType (788)
	virtual int soap_type(void) const { return 788; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionType); }
	         wsnt__TopicExpressionType() { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2331 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (789)
/* Type wsnt__FilterType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:FilterType complex type: */
class SOAP_CMAC wsnt__FilterType : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__FilterType (789)
	virtual int soap_type(void) const { return 789; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
	virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW(wsnt__FilterType); }
	         wsnt__FilterType() { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
	friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2334 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (790)
/* Type wsnt__SubscriptionPolicyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscriptionPolicyType complex type: */
class SOAP_CMAC wsnt__SubscriptionPolicyType : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscriptionPolicyType (790)
	virtual int soap_type(void) const { return 790; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
	virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscriptionPolicyType); }
	         wsnt__SubscriptionPolicyType() { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
	friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:25753 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (2070)
/* wsnt:NotificationMessageHolderType-Message complex type: */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (2070)
	virtual int soap_type(void) const { return 2070; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
	virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationMessageHolderType_Message); }
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
	friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2337 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (791)
/* Type wsnt__NotificationMessageHolderType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotificationMessageHolderType complex type: */
class SOAP_CMAC wsnt__NotificationMessageHolderType : public xsd__anyType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of XSD type wsnt:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of XSD type wsnt:NotificationMessageHolderType-Message */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotificationMessageHolderType (791)
	virtual int soap_type(void) const { return 791; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
	virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotificationMessageHolderType); }
	         wsnt__NotificationMessageHolderType() { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
	friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2400 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (812)
/* wsnt:NotificationProducerRP complex type: */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	int __sizeTopicExpression;	/* sequence of elements <TopicExpression> of XSD type wsnt:TopicExpressionType */
	wsnt__TopicExpressionType **TopicExpression;
	bool FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	int __sizeTopicExpressionDialect;	/* sequence of elements <TopicExpressionDialect> of XSD type xsd:anyURI */
	char **TopicExpressionDialect;
	wstop__TopicSetType *wstop__TopicSet;	/* optional element of XSD type wstop:TopicSetType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__NotificationProducerRP (812)
	virtual int soap_type(void) const { return 812; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
	virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__NotificationProducerRP); }
	         _wsnt__NotificationProducerRP() { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
	friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2403 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (813)
/* wsnt:SubscriptionManagerRP complex type: */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of XSD type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscriptionManagerRP (813)
	virtual int soap_type(void) const { return 813; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
	virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscriptionManagerRP); }
	         _wsnt__SubscriptionManagerRP() { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
	friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2406 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (814)
/* wsnt:Notify complex type: */
class SOAP_CMAC _wsnt__Notify
{
public:
	int __sizeNotificationMessage;	/* sequence of elements <NotificationMessage> of XSD type wsnt:NotificationMessageHolderType */
	wsnt__NotificationMessageHolderType **NotificationMessage;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Notify (814)
	virtual int soap_type(void) const { return 814; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
	virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW(_wsnt__Notify); }
	         _wsnt__Notify() { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
	friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2409 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (815)
/* wsnt:UseRaw complex type: */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UseRaw (815)
	virtual int soap_type(void) const { return 815; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
	virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW(_wsnt__UseRaw); }
	         _wsnt__UseRaw() { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
	friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:25905 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (2075)
/* wsnt:Subscribe-SubscriptionPolicy complex type: */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (2075)
	virtual int soap_type(void) const { return 2075; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe_SubscriptionPolicy); }
	         _wsnt__Subscribe_SubscriptionPolicy() { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2412 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (816)
/* wsnt:Subscribe complex type: */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of XSD type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	char *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type wsnt:Subscribe-SubscriptionPolicy */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Subscribe (816)
	virtual int soap_type(void) const { return 816; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
	virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Subscribe); }
	         _wsnt__Subscribe() { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
	friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2415 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (817)
/* wsnt:SubscribeResponse complex type: */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__SubscribeResponse (817)
	virtual int soap_type(void) const { return 817; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__SubscribeResponse); }
	         _wsnt__SubscribeResponse() { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2418 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (818)
/* wsnt:GetCurrentMessage complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of XSD type wsnt:TopicExpressionType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessage (818)
	virtual int soap_type(void) const { return 818; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessage); }
	         _wsnt__GetCurrentMessage() { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2421 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (819)
/* wsnt:GetCurrentMessageResponse complex type: */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetCurrentMessageResponse (819)
	virtual int soap_type(void) const { return 819; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetCurrentMessageResponse); }
	         _wsnt__GetCurrentMessageResponse() { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
	friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2424 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (820)
/* wsnt:GetMessages complex type: */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	char *MaximumNumber;	/* optional element of XSD type xsd:nonNegativeInteger */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessages (820)
	virtual int soap_type(void) const { return 820; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
	virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessages); }
	         _wsnt__GetMessages() { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
	friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2427 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (821)
/* wsnt:GetMessagesResponse complex type: */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	int __sizeNotificationMessage;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NotificationMessage> of XSD type wsnt:NotificationMessageHolderType */
	wsnt__NotificationMessageHolderType **NotificationMessage;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__GetMessagesResponse (821)
	virtual int soap_type(void) const { return 821; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
	virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__GetMessagesResponse); }
	         _wsnt__GetMessagesResponse() { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
	friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2430 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (822)
/* wsnt:DestroyPullPoint complex type: */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPoint (822)
	virtual int soap_type(void) const { return 822; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPoint); }
	         _wsnt__DestroyPullPoint() { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2433 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (823)
/* wsnt:DestroyPullPointResponse complex type: */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__DestroyPullPointResponse (823)
	virtual int soap_type(void) const { return 823; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__DestroyPullPointResponse); }
	         _wsnt__DestroyPullPointResponse() { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2436 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (824)
/* wsnt:CreatePullPoint complex type: */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPoint (824)
	virtual int soap_type(void) const { return 824; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPoint); }
	         _wsnt__CreatePullPoint() { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2439 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (825)
/* wsnt:CreatePullPointResponse complex type: */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__CreatePullPointResponse (825)
	virtual int soap_type(void) const { return 825; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
	virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__CreatePullPointResponse); }
	         _wsnt__CreatePullPointResponse() { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
	friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2442 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (826)
/* wsnt:Renew complex type: */
class SOAP_CMAC _wsnt__Renew
{
public:
	char *TerminationTime;	/* required element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Renew (826)
	virtual int soap_type(void) const { return 826; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
	virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW(_wsnt__Renew); }
	         _wsnt__Renew() { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
	friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2445 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (827)
/* wsnt:RenewResponse complex type: */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__RenewResponse (827)
	virtual int soap_type(void) const { return 827; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
	virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__RenewResponse); }
	         _wsnt__RenewResponse() { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
	friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2448 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (828)
/* wsnt:Unsubscribe complex type: */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__Unsubscribe (828)
	virtual int soap_type(void) const { return 828; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
	virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_wsnt__Unsubscribe); }
	         _wsnt__Unsubscribe() { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
	friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2451 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (829)
/* wsnt:UnsubscribeResponse complex type: */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__UnsubscribeResponse (829)
	virtual int soap_type(void) const { return 829; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
	virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__UnsubscribeResponse); }
	         _wsnt__UnsubscribeResponse() { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
	friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2454 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (830)
/* wsnt:PauseSubscription complex type: */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscription (830)
	virtual int soap_type(void) const { return 830; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscription); }
	         _wsnt__PauseSubscription() { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2457 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (831)
/* wsnt:PauseSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__PauseSubscriptionResponse (831)
	virtual int soap_type(void) const { return 831; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__PauseSubscriptionResponse); }
	         _wsnt__PauseSubscriptionResponse() { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2460 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (832)
/* wsnt:ResumeSubscription complex type: */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscription (832)
	virtual int soap_type(void) const { return 832; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscription); }
	         _wsnt__ResumeSubscription() { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2463 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (833)
/* wsnt:ResumeSubscriptionResponse complex type: */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__wsnt__ResumeSubscriptionResponse (833)
	virtual int soap_type(void) const { return 833; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
	virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_wsnt__ResumeSubscriptionResponse); }
	         _wsnt__ResumeSubscriptionResponse() { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
	friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:26509 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (2077)
/* wsrfbf:BaseFaultType-ErrorCode complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode
{
public:
	char *dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (2077)
	virtual int soap_type(void) const { return 2077; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode); }
	         _wsrfbf__BaseFaultType_ErrorCode() { _wsrfbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:26530 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (2079)
/* wsrfbf:BaseFaultType-Description simple type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description
{
public:
	char *__item;	/* mixed XML content */
	char *xml__lang;	/* optional attribute of XSD type xml:lang */
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_Description (2079)
	virtual int soap_type(void) const { return 2079; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_Description); }
	         _wsrfbf__BaseFaultType_Description() { _wsrfbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_Description() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:26547 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (2081)
/* wsrfbf:BaseFaultType-FaultCause complex type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (2081)
	virtual int soap_type(void) const { return 2081; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
	virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause); }
	         _wsrfbf__BaseFaultType_FaultCause() { _wsrfbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
	friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2466 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (834)
/* Type wsrfbf__BaseFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfbf:BaseFaultType complex type: */
class SOAP_CMAC wsrfbf__BaseFaultType : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	time_t Timestamp;	/* required element of XSD type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of XSD type wsa5:EndpointReferenceType */
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of XSD type wsrfbf:BaseFaultType-ErrorCode */
	int __sizeDescription;	/* sequence of elements <Description> of XSD type wsrfbf:BaseFaultType-Description */
	_wsrfbf__BaseFaultType_Description *Description;
	_wsrfbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of XSD type wsrfbf:BaseFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfbf__BaseFaultType (834)
	virtual int soap_type(void) const { return 834; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
	virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfbf__BaseFaultType); }
	         wsrfbf__BaseFaultType() { wsrfbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsrfbf__BaseFaultType() { }
	friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2469 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (835)
/* Type wstop__Documentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:Documentation complex type: */
class SOAP_CMAC wstop__Documentation : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__Documentation (835)
	virtual int soap_type(void) const { return 835; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
	virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW(wstop__Documentation); }
	         wstop__Documentation() { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
	friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2472 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (836)
/* Type wstop__ExtensibleDocumented is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:ExtensibleDocumented complex type: */
class SOAP_CMAC wstop__ExtensibleDocumented : public xsd__anyType
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__ExtensibleDocumented (836)
	virtual int soap_type(void) const { return 836; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
	virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(wstop__ExtensibleDocumented); }
	         wstop__ExtensibleDocumented() { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
	friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2475 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (837)
/* Type wstop__QueryExpressionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:QueryExpressionType complex type: */
class SOAP_CMAC wstop__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	char *Dialect;	/* required attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__QueryExpressionType (837)
	virtual int soap_type(void) const { return 837; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
	virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(wstop__QueryExpressionType); }
	         wstop__QueryExpressionType() { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
	friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:26697 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (2084)
/* tds:Service-Capabilities complex type: */
class SOAP_CMAC _tds__Service_Capabilities
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__Service_Capabilities (2084)
	virtual int soap_type(void) const { return 2084; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
	virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__Service_Capabilities); }
	         _tds__Service_Capabilities() { _tds__Service_Capabilities::soap_default(NULL); }
	virtual ~_tds__Service_Capabilities() { }
	friend SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2487 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (841)
/* Type tds__Service is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:Service complex type: */
class SOAP_CMAC tds__Service : public xsd__anyType
{
public:
	char *Namespace;	/* required element of XSD type xsd:anyURI */
	char *XAddr;	/* required element of XSD type xsd:anyURI */
	_tds__Service_Capabilities *Capabilities;	/* optional element of XSD type tds:Service-Capabilities */
	tt__OnvifVersion *Version;	/* required element of XSD type tt:OnvifVersion */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__Service (841)
	virtual int soap_type(void) const { return 841; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__Service, default initialized and not managed by a soap context
	virtual tds__Service *soap_alloc(void) const { return SOAP_NEW(tds__Service); }
	         tds__Service() { tds__Service::soap_default(NULL); }
	virtual ~tds__Service() { }
	friend SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2490 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (842)
/* Type tds__DeviceServiceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:DeviceServiceCapabilities complex type: */
class SOAP_CMAC tds__DeviceServiceCapabilities : public xsd__anyType
{
public:
	tds__NetworkCapabilities *Network;	/* required element of XSD type tds:NetworkCapabilities */
	tds__SecurityCapabilities *Security;	/* required element of XSD type tds:SecurityCapabilities */
	tds__SystemCapabilities *System;	/* required element of XSD type tds:SystemCapabilities */
	tds__MiscCapabilities *Misc;	/* optional element of XSD type tds:MiscCapabilities */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__DeviceServiceCapabilities (842)
	virtual int soap_type(void) const { return 842; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
	virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__DeviceServiceCapabilities); }
	         tds__DeviceServiceCapabilities() { tds__DeviceServiceCapabilities::soap_default(NULL); }
	virtual ~tds__DeviceServiceCapabilities() { }
	friend SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2493 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (843)
/* Type tds__NetworkCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:NetworkCapabilities simple type: */
class SOAP_CMAC tds__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional attribute of XSD type xsd:boolean */
	bool *ZeroConfiguration;	/* optional attribute of XSD type xsd:boolean */
	bool *IPVersion6;	/* optional attribute of XSD type xsd:boolean */
	bool *DynDNS;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot11Configuration;	/* optional attribute of XSD type xsd:boolean */
	int *Dot1XConfigurations;	/* optional attribute of XSD type xsd:int */
	bool *HostnameFromDHCP;	/* optional attribute of XSD type xsd:boolean */
	int *NTP;	/* optional attribute of XSD type xsd:int */
	bool *DHCPv6;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__NetworkCapabilities (843)
	virtual int soap_type(void) const { return 843; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
	virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__NetworkCapabilities); }
	         tds__NetworkCapabilities() { tds__NetworkCapabilities::soap_default(NULL); }
	virtual ~tds__NetworkCapabilities() { }
	friend SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2496 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (844)
/* Type tds__SecurityCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:SecurityCapabilities simple type: */
class SOAP_CMAC tds__SecurityCapabilities : public xsd__anyType
{
public:
	bool *TLS1_x002e0;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e1;	/* optional attribute of XSD type xsd:boolean */
	bool *TLS1_x002e2;	/* optional attribute of XSD type xsd:boolean */
	bool *OnboardKeyGeneration;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessPolicyConfig;	/* optional attribute of XSD type xsd:boolean */
	bool *DefaultAccessPolicy;	/* optional attribute of XSD type xsd:boolean */
	bool *Dot1X;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteUserHandling;	/* optional attribute of XSD type xsd:boolean */
	bool *X_x002e509Token;	/* optional attribute of XSD type xsd:boolean */
	bool *SAMLToken;	/* optional attribute of XSD type xsd:boolean */
	bool *KerberosToken;	/* optional attribute of XSD type xsd:boolean */
	bool *UsernameToken;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpDigest;	/* optional attribute of XSD type xsd:boolean */
	bool *RELToken;	/* optional attribute of XSD type xsd:boolean */
	char *SupportedEAPMethods;	/* optional attribute of XSD type tds:EAPMethodTypes */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SecurityCapabilities (844)
	virtual int soap_type(void) const { return 844; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
	virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SecurityCapabilities); }
	         tds__SecurityCapabilities() { tds__SecurityCapabilities::soap_default(NULL); }
	virtual ~tds__SecurityCapabilities() { }
	friend SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2499 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (845)
/* Type tds__SystemCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:SystemCapabilities simple type: */
class SOAP_CMAC tds__SystemCapabilities : public xsd__anyType
{
public:
	bool *DiscoveryResolve;	/* optional attribute of XSD type xsd:boolean */
	bool *DiscoveryBye;	/* optional attribute of XSD type xsd:boolean */
	bool *RemoteDiscovery;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *SystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *FirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpFirmwareUpgrade;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemBackup;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSystemLogging;	/* optional attribute of XSD type xsd:boolean */
	bool *HttpSupportInformation;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__SystemCapabilities (845)
	virtual int soap_type(void) const { return 845; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
	virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__SystemCapabilities); }
	         tds__SystemCapabilities() { tds__SystemCapabilities::soap_default(NULL); }
	virtual ~tds__SystemCapabilities() { }
	friend SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2502 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (846)
/* Type tds__MiscCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tds:MiscCapabilities simple type: */
class SOAP_CMAC tds__MiscCapabilities : public xsd__anyType
{
public:
	char *AuxiliaryCommands;	/* optional attribute of XSD type tt:StringAttrList */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tds__MiscCapabilities (846)
	virtual int soap_type(void) const { return 846; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
	virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW(tds__MiscCapabilities); }
	         tds__MiscCapabilities() { tds__MiscCapabilities::soap_default(NULL); }
	virtual ~tds__MiscCapabilities() { }
	friend SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2505 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (847)
/* tds:GetServices complex type: */
class SOAP_CMAC _tds__GetServices
{
public:
	bool IncludeCapability;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServices (847)
	virtual int soap_type(void) const { return 847; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
	virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW(_tds__GetServices); }
	         _tds__GetServices() { _tds__GetServices::soap_default(NULL); }
	virtual ~_tds__GetServices() { }
	friend SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2508 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (848)
/* tds:GetServicesResponse complex type: */
class SOAP_CMAC _tds__GetServicesResponse
{
public:
	int __sizeService;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Service> of XSD type tds:Service */
	tds__Service **Service;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServicesResponse (848)
	virtual int soap_type(void) const { return 848; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServicesResponse); }
	         _tds__GetServicesResponse() { _tds__GetServicesResponse::soap_default(NULL); }
	virtual ~_tds__GetServicesResponse() { }
	friend SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2511 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (849)
/* tds:GetServiceCapabilities complex type: */
class SOAP_CMAC _tds__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilities (849)
	virtual int soap_type(void) const { return 849; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilities); }
	         _tds__GetServiceCapabilities() { _tds__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2514 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (850)
/* tds:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse
{
public:
	tds__DeviceServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tds:DeviceServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetServiceCapabilitiesResponse (850)
	virtual int soap_type(void) const { return 850; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetServiceCapabilitiesResponse); }
	         _tds__GetServiceCapabilitiesResponse() { _tds__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2517 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (851)
/* tds:GetDeviceInformation complex type: */
class SOAP_CMAC _tds__GetDeviceInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformation (851)
	virtual int soap_type(void) const { return 851; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformation); }
	         _tds__GetDeviceInformation() { _tds__GetDeviceInformation::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformation() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2520 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (852)
/* tds:GetDeviceInformationResponse complex type: */
class SOAP_CMAC _tds__GetDeviceInformationResponse
{
public:
	char *Manufacturer;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	char *Model;	/* required element of XSD type xsd:string */
	char *FirmwareVersion;	/* required element of XSD type xsd:string */
	char *SerialNumber;	/* required element of XSD type xsd:string */
	char *HardwareId;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDeviceInformationResponse (852)
	virtual int soap_type(void) const { return 852; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDeviceInformationResponse); }
	         _tds__GetDeviceInformationResponse() { _tds__GetDeviceInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetDeviceInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2523 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (853)
/* tds:SetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of XSD type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of XSD type xsd:boolean */
	tt__TimeZone *TimeZone;	/* optional element of XSD type tt:TimeZone */
	tt__DateTime *UTCDateTime;	/* optional element of XSD type tt:DateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTime (853)
	virtual int soap_type(void) const { return 853; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTime); }
	         _tds__SetSystemDateAndTime() { _tds__SetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2526 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (854)
/* tds:SetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemDateAndTimeResponse (854)
	virtual int soap_type(void) const { return 854; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemDateAndTimeResponse); }
	         _tds__SetSystemDateAndTimeResponse() { _tds__SetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2529 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (855)
/* tds:GetSystemDateAndTime complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTime
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTime (855)
	virtual int soap_type(void) const { return 855; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTime); }
	         _tds__GetSystemDateAndTime() { _tds__GetSystemDateAndTime::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTime() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2532 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (856)
/* tds:GetSystemDateAndTimeResponse complex type: */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse
{
public:
	tt__SystemDateTime *SystemDateAndTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemDateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemDateAndTimeResponse (856)
	virtual int soap_type(void) const { return 856; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemDateAndTimeResponse); }
	         _tds__GetSystemDateAndTimeResponse() { _tds__GetSystemDateAndTimeResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemDateAndTimeResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2535 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (857)
/* tds:SetSystemFactoryDefault complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefault
{
public:
	enum tt__FactoryDefaultType FactoryDefault;	/* required element of XSD type tt:FactoryDefaultType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefault (857)
	virtual int soap_type(void) const { return 857; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefault); }
	         _tds__SetSystemFactoryDefault() { _tds__SetSystemFactoryDefault::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefault() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2538 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (858)
/* tds:SetSystemFactoryDefaultResponse complex type: */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (858)
	virtual int soap_type(void) const { return 858; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
	virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetSystemFactoryDefaultResponse); }
	         _tds__SetSystemFactoryDefaultResponse() { _tds__SetSystemFactoryDefaultResponse::soap_default(NULL); }
	virtual ~_tds__SetSystemFactoryDefaultResponse() { }
	friend SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2541 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (859)
/* tds:UpgradeSystemFirmware complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmware
{
public:
	tt__AttachmentData *Firmware;	/* required element of XSD type tt:AttachmentData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmware (859)
	virtual int soap_type(void) const { return 859; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmware); }
	         _tds__UpgradeSystemFirmware() { _tds__UpgradeSystemFirmware::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmware() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2544 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (860)
/* tds:UpgradeSystemFirmwareResponse complex type: */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse
{
public:
	char *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (860)
	virtual int soap_type(void) const { return 860; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
	virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW(_tds__UpgradeSystemFirmwareResponse); }
	         _tds__UpgradeSystemFirmwareResponse() { _tds__UpgradeSystemFirmwareResponse::soap_default(NULL); }
	virtual ~_tds__UpgradeSystemFirmwareResponse() { }
	friend SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2547 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (861)
/* tds:SystemReboot complex type: */
class SOAP_CMAC _tds__SystemReboot
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemReboot (861)
	virtual int soap_type(void) const { return 861; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
	virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW(_tds__SystemReboot); }
	         _tds__SystemReboot() { _tds__SystemReboot::soap_default(NULL); }
	virtual ~_tds__SystemReboot() { }
	friend SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2550 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (862)
/* tds:SystemRebootResponse complex type: */
class SOAP_CMAC _tds__SystemRebootResponse
{
public:
	char *Message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SystemRebootResponse (862)
	virtual int soap_type(void) const { return 862; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
	virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SystemRebootResponse); }
	         _tds__SystemRebootResponse() { _tds__SystemRebootResponse::soap_default(NULL); }
	virtual ~_tds__SystemRebootResponse() { }
	friend SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2553 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (863)
/* tds:RestoreSystem complex type: */
class SOAP_CMAC _tds__RestoreSystem
{
public:
	int __sizeBackupFiles;	/* sequence of elements <BackupFiles> of XSD type tt:BackupFile */
	tt__BackupFile **BackupFiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystem (863)
	virtual int soap_type(void) const { return 863; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
	virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystem); }
	         _tds__RestoreSystem() { _tds__RestoreSystem::soap_default(NULL); }
	virtual ~_tds__RestoreSystem() { }
	friend SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2556 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (864)
/* tds:RestoreSystemResponse complex type: */
class SOAP_CMAC _tds__RestoreSystemResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RestoreSystemResponse (864)
	virtual int soap_type(void) const { return 864; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
	virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RestoreSystemResponse); }
	         _tds__RestoreSystemResponse() { _tds__RestoreSystemResponse::soap_default(NULL); }
	virtual ~_tds__RestoreSystemResponse() { }
	friend SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2559 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (865)
/* tds:GetSystemBackup complex type: */
class SOAP_CMAC _tds__GetSystemBackup
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackup (865)
	virtual int soap_type(void) const { return 865; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackup); }
	         _tds__GetSystemBackup() { _tds__GetSystemBackup::soap_default(NULL); }
	virtual ~_tds__GetSystemBackup() { }
	friend SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2562 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (866)
/* tds:GetSystemBackupResponse complex type: */
class SOAP_CMAC _tds__GetSystemBackupResponse
{
public:
	int __sizeBackupFiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <BackupFiles> of XSD type tt:BackupFile */
	tt__BackupFile **BackupFiles;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemBackupResponse (866)
	virtual int soap_type(void) const { return 866; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemBackupResponse); }
	         _tds__GetSystemBackupResponse() { _tds__GetSystemBackupResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemBackupResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2565 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (867)
/* tds:GetSystemSupportInformation complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformation
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformation (867)
	virtual int soap_type(void) const { return 867; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformation); }
	         _tds__GetSystemSupportInformation() { _tds__GetSystemSupportInformation::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformation() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2568 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (868)
/* tds:GetSystemSupportInformationResponse complex type: */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse
{
public:
	tt__SupportInformation *SupportInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemSupportInformationResponse (868)
	virtual int soap_type(void) const { return 868; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemSupportInformationResponse); }
	         _tds__GetSystemSupportInformationResponse() { _tds__GetSystemSupportInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemSupportInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2571 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (869)
/* tds:GetSystemLog complex type: */
class SOAP_CMAC _tds__GetSystemLog
{
public:
	enum tt__SystemLogType LogType;	/* required element of XSD type tt:SystemLogType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLog (869)
	virtual int soap_type(void) const { return 869; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
	virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLog); }
	         _tds__GetSystemLog() { _tds__GetSystemLog::soap_default(NULL); }
	virtual ~_tds__GetSystemLog() { }
	friend SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2574 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (870)
/* tds:GetSystemLogResponse complex type: */
class SOAP_CMAC _tds__GetSystemLogResponse
{
public:
	tt__SystemLog *SystemLog;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SystemLog */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemLogResponse (870)
	virtual int soap_type(void) const { return 870; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemLogResponse); }
	         _tds__GetSystemLogResponse() { _tds__GetSystemLogResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemLogResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2577 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (871)
/* tds:GetScopes complex type: */
class SOAP_CMAC _tds__GetScopes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopes (871)
	virtual int soap_type(void) const { return 871; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
	virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopes); }
	         _tds__GetScopes() { _tds__GetScopes::soap_default(NULL); }
	virtual ~_tds__GetScopes() { }
	friend SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2580 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (872)
/* tds:GetScopesResponse complex type: */
class SOAP_CMAC _tds__GetScopesResponse
{
public:
	int __sizeScopes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Scopes> of XSD type tt:Scope */
	tt__Scope **Scopes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetScopesResponse (872)
	virtual int soap_type(void) const { return 872; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetScopesResponse); }
	         _tds__GetScopesResponse() { _tds__GetScopesResponse::soap_default(NULL); }
	virtual ~_tds__GetScopesResponse() { }
	friend SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2583 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (873)
/* tds:SetScopes complex type: */
class SOAP_CMAC _tds__SetScopes
{
public:
	int __sizeScopes;	/* sequence of elements <Scopes> of XSD type xsd:anyURI */
	char **Scopes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopes (873)
	virtual int soap_type(void) const { return 873; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
	virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopes); }
	         _tds__SetScopes() { _tds__SetScopes::soap_default(NULL); }
	virtual ~_tds__SetScopes() { }
	friend SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2586 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (874)
/* tds:SetScopesResponse complex type: */
class SOAP_CMAC _tds__SetScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetScopesResponse (874)
	virtual int soap_type(void) const { return 874; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
	virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetScopesResponse); }
	         _tds__SetScopesResponse() { _tds__SetScopesResponse::soap_default(NULL); }
	virtual ~_tds__SetScopesResponse() { }
	friend SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2589 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (875)
/* tds:AddScopes complex type: */
class SOAP_CMAC _tds__AddScopes
{
public:
	int __sizeScopeItem;	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopes (875)
	virtual int soap_type(void) const { return 875; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
	virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopes); }
	         _tds__AddScopes() { _tds__AddScopes::soap_default(NULL); }
	virtual ~_tds__AddScopes() { }
	friend SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2592 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (876)
/* tds:AddScopesResponse complex type: */
class SOAP_CMAC _tds__AddScopesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddScopesResponse (876)
	virtual int soap_type(void) const { return 876; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
	virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddScopesResponse); }
	         _tds__AddScopesResponse() { _tds__AddScopesResponse::soap_default(NULL); }
	virtual ~_tds__AddScopesResponse() { }
	friend SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2595 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (877)
/* tds:RemoveScopes complex type: */
class SOAP_CMAC _tds__RemoveScopes
{
public:
	int __sizeScopeItem;	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopes (877)
	virtual int soap_type(void) const { return 877; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
	virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopes); }
	         _tds__RemoveScopes() { _tds__RemoveScopes::soap_default(NULL); }
	virtual ~_tds__RemoveScopes() { }
	friend SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2598 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (878)
/* tds:RemoveScopesResponse complex type: */
class SOAP_CMAC _tds__RemoveScopesResponse
{
public:
	int __sizeScopeItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ScopeItem> of XSD type xsd:anyURI */
	char **ScopeItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveScopesResponse (878)
	virtual int soap_type(void) const { return 878; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveScopesResponse); }
	         _tds__RemoveScopesResponse() { _tds__RemoveScopesResponse::soap_default(NULL); }
	virtual ~_tds__RemoveScopesResponse() { }
	friend SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2601 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (879)
/* tds:GetDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryMode (879)
	virtual int soap_type(void) const { return 879; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryMode); }
	         _tds__GetDiscoveryMode() { _tds__GetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2604 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (880)
/* tds:GetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDiscoveryModeResponse (880)
	virtual int soap_type(void) const { return 880; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDiscoveryModeResponse); }
	         _tds__GetDiscoveryModeResponse() { _tds__GetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2607 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (881)
/* tds:SetDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetDiscoveryMode
{
public:
	enum tt__DiscoveryMode DiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryMode (881)
	virtual int soap_type(void) const { return 881; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryMode); }
	         _tds__SetDiscoveryMode() { _tds__SetDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2610 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (882)
/* tds:SetDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDiscoveryModeResponse (882)
	virtual int soap_type(void) const { return 882; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDiscoveryModeResponse); }
	         _tds__SetDiscoveryModeResponse() { _tds__SetDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2613 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (883)
/* tds:GetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryMode (883)
	virtual int soap_type(void) const { return 883; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryMode); }
	         _tds__GetRemoteDiscoveryMode() { _tds__GetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2616 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (884)
/* tds:GetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (884)
	virtual int soap_type(void) const { return 884; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteDiscoveryModeResponse); }
	         _tds__GetRemoteDiscoveryModeResponse() { _tds__GetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2619 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (885)
/* tds:SetRemoteDiscoveryMode complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode
{
public:
	enum tt__DiscoveryMode RemoteDiscoveryMode;	/* required element of XSD type tt:DiscoveryMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryMode (885)
	virtual int soap_type(void) const { return 885; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryMode); }
	         _tds__SetRemoteDiscoveryMode() { _tds__SetRemoteDiscoveryMode::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryMode() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2622 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (886)
/* tds:SetRemoteDiscoveryModeResponse complex type: */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (886)
	virtual int soap_type(void) const { return 886; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteDiscoveryModeResponse); }
	         _tds__SetRemoteDiscoveryModeResponse() { _tds__SetRemoteDiscoveryModeResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2625 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (887)
/* tds:GetDPAddresses complex type: */
class SOAP_CMAC _tds__GetDPAddresses
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddresses (887)
	virtual int soap_type(void) const { return 887; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddresses); }
	         _tds__GetDPAddresses() { _tds__GetDPAddresses::soap_default(NULL); }
	virtual ~_tds__GetDPAddresses() { }
	friend SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2628 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (888)
/* tds:GetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__GetDPAddressesResponse
{
public:
	int __sizeDPAddress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <DPAddress> of XSD type tt:NetworkHost */
	tt__NetworkHost **DPAddress;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDPAddressesResponse (888)
	virtual int soap_type(void) const { return 888; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDPAddressesResponse); }
	         _tds__GetDPAddressesResponse() { _tds__GetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__GetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2631 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (889)
/* tds:SetDPAddresses complex type: */
class SOAP_CMAC _tds__SetDPAddresses
{
public:
	int __sizeDPAddress;	/* sequence of elements <DPAddress> of XSD type tt:NetworkHost */
	tt__NetworkHost **DPAddress;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddresses (889)
	virtual int soap_type(void) const { return 889; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
	virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddresses); }
	         _tds__SetDPAddresses() { _tds__SetDPAddresses::soap_default(NULL); }
	virtual ~_tds__SetDPAddresses() { }
	friend SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2634 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (890)
/* tds:SetDPAddressesResponse complex type: */
class SOAP_CMAC _tds__SetDPAddressesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDPAddressesResponse (890)
	virtual int soap_type(void) const { return 890; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
	virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDPAddressesResponse); }
	         _tds__SetDPAddressesResponse() { _tds__SetDPAddressesResponse::soap_default(NULL); }
	virtual ~_tds__SetDPAddressesResponse() { }
	friend SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2637 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (891)
/* tds:GetEndpointReference complex type: */
class SOAP_CMAC _tds__GetEndpointReference
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReference (891)
	virtual int soap_type(void) const { return 891; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReference); }
	         _tds__GetEndpointReference() { _tds__GetEndpointReference::soap_default(NULL); }
	virtual ~_tds__GetEndpointReference() { }
	friend SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2640 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (892)
/* tds:GetEndpointReferenceResponse complex type: */
class SOAP_CMAC _tds__GetEndpointReferenceResponse
{
public:
	char *GUID;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetEndpointReferenceResponse (892)
	virtual int soap_type(void) const { return 892; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
	virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetEndpointReferenceResponse); }
	         _tds__GetEndpointReferenceResponse() { _tds__GetEndpointReferenceResponse::soap_default(NULL); }
	virtual ~_tds__GetEndpointReferenceResponse() { }
	friend SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2643 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (893)
/* tds:GetRemoteUser complex type: */
class SOAP_CMAC _tds__GetRemoteUser
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUser (893)
	virtual int soap_type(void) const { return 893; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUser); }
	         _tds__GetRemoteUser() { _tds__GetRemoteUser::soap_default(NULL); }
	virtual ~_tds__GetRemoteUser() { }
	friend SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2646 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (894)
/* tds:GetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__GetRemoteUserResponse
{
public:
	tt__RemoteUser *RemoteUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRemoteUserResponse (894)
	virtual int soap_type(void) const { return 894; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRemoteUserResponse); }
	         _tds__GetRemoteUserResponse() { _tds__GetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__GetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2649 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (895)
/* tds:SetRemoteUser complex type: */
class SOAP_CMAC _tds__SetRemoteUser
{
public:
	tt__RemoteUser *RemoteUser;	/* optional element of XSD type tt:RemoteUser */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUser (895)
	virtual int soap_type(void) const { return 895; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUser); }
	         _tds__SetRemoteUser() { _tds__SetRemoteUser::soap_default(NULL); }
	virtual ~_tds__SetRemoteUser() { }
	friend SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2652 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (896)
/* tds:SetRemoteUserResponse complex type: */
class SOAP_CMAC _tds__SetRemoteUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRemoteUserResponse (896)
	virtual int soap_type(void) const { return 896; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRemoteUserResponse); }
	         _tds__SetRemoteUserResponse() { _tds__SetRemoteUserResponse::soap_default(NULL); }
	virtual ~_tds__SetRemoteUserResponse() { }
	friend SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2655 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (897)
/* tds:GetUsers complex type: */
class SOAP_CMAC _tds__GetUsers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsers (897)
	virtual int soap_type(void) const { return 897; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
	virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsers); }
	         _tds__GetUsers() { _tds__GetUsers::soap_default(NULL); }
	virtual ~_tds__GetUsers() { }
	friend SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2658 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (898)
/* tds:GetUsersResponse complex type: */
class SOAP_CMAC _tds__GetUsersResponse
{
public:
	int __sizeUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetUsersResponse (898)
	virtual int soap_type(void) const { return 898; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
	virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetUsersResponse); }
	         _tds__GetUsersResponse() { _tds__GetUsersResponse::soap_default(NULL); }
	virtual ~_tds__GetUsersResponse() { }
	friend SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2661 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (899)
/* tds:CreateUsers complex type: */
class SOAP_CMAC _tds__CreateUsers
{
public:
	int __sizeUser;	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsers (899)
	virtual int soap_type(void) const { return 899; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
	virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsers); }
	         _tds__CreateUsers() { _tds__CreateUsers::soap_default(NULL); }
	virtual ~_tds__CreateUsers() { }
	friend SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2664 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (900)
/* tds:CreateUsersResponse complex type: */
class SOAP_CMAC _tds__CreateUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateUsersResponse (900)
	virtual int soap_type(void) const { return 900; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
	virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateUsersResponse); }
	         _tds__CreateUsersResponse() { _tds__CreateUsersResponse::soap_default(NULL); }
	virtual ~_tds__CreateUsersResponse() { }
	friend SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2667 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (901)
/* tds:DeleteUsers complex type: */
class SOAP_CMAC _tds__DeleteUsers
{
public:
	int __sizeUsername;	/* sequence of elements <Username> of XSD type xsd:string */
	char **Username;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsers (901)
	virtual int soap_type(void) const { return 901; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
	virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsers); }
	         _tds__DeleteUsers() { _tds__DeleteUsers::soap_default(NULL); }
	virtual ~_tds__DeleteUsers() { }
	friend SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2670 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (902)
/* tds:DeleteUsersResponse complex type: */
class SOAP_CMAC _tds__DeleteUsersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteUsersResponse (902)
	virtual int soap_type(void) const { return 902; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteUsersResponse); }
	         _tds__DeleteUsersResponse() { _tds__DeleteUsersResponse::soap_default(NULL); }
	virtual ~_tds__DeleteUsersResponse() { }
	friend SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2673 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (903)
/* tds:SetUser complex type: */
class SOAP_CMAC _tds__SetUser
{
public:
	int __sizeUser;	/* sequence of elements <User> of XSD type tt:User */
	tt__User **User;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUser (903)
	virtual int soap_type(void) const { return 903; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
	virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW(_tds__SetUser); }
	         _tds__SetUser() { _tds__SetUser::soap_default(NULL); }
	virtual ~_tds__SetUser() { }
	friend SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2676 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (904)
/* tds:SetUserResponse complex type: */
class SOAP_CMAC _tds__SetUserResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetUserResponse (904)
	virtual int soap_type(void) const { return 904; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
	virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetUserResponse); }
	         _tds__SetUserResponse() { _tds__SetUserResponse::soap_default(NULL); }
	virtual ~_tds__SetUserResponse() { }
	friend SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2679 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (905)
/* tds:GetWsdlUrl complex type: */
class SOAP_CMAC _tds__GetWsdlUrl
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrl (905)
	virtual int soap_type(void) const { return 905; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrl); }
	         _tds__GetWsdlUrl() { _tds__GetWsdlUrl::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrl() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2682 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (906)
/* tds:GetWsdlUrlResponse complex type: */
class SOAP_CMAC _tds__GetWsdlUrlResponse
{
public:
	char *WsdlUrl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetWsdlUrlResponse (906)
	virtual int soap_type(void) const { return 906; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
	virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetWsdlUrlResponse); }
	         _tds__GetWsdlUrlResponse() { _tds__GetWsdlUrlResponse::soap_default(NULL); }
	virtual ~_tds__GetWsdlUrlResponse() { }
	friend SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2685 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (907)
/* tds:GetCapabilities complex type: */
class SOAP_CMAC _tds__GetCapabilities
{
public:
	int __sizeCategory;	/* sequence of elements <Category> of XSD type tt:CapabilityCategory */
	enum tt__CapabilityCategory *Category;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilities (907)
	virtual int soap_type(void) const { return 907; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
	virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilities); }
	         _tds__GetCapabilities() { _tds__GetCapabilities::soap_default(NULL); }
	virtual ~_tds__GetCapabilities() { }
	friend SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2688 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (908)
/* tds:GetCapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetCapabilitiesResponse
{
public:
	tt__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCapabilitiesResponse (908)
	virtual int soap_type(void) const { return 908; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCapabilitiesResponse); }
	         _tds__GetCapabilitiesResponse() { _tds__GetCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2691 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (909)
/* tds:GetHostname complex type: */
class SOAP_CMAC _tds__GetHostname
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostname (909)
	virtual int soap_type(void) const { return 909; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
	virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostname); }
	         _tds__GetHostname() { _tds__GetHostname::soap_default(NULL); }
	virtual ~_tds__GetHostname() { }
	friend SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2694 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (910)
/* tds:GetHostnameResponse complex type: */
class SOAP_CMAC _tds__GetHostnameResponse
{
public:
	tt__HostnameInformation *HostnameInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:HostnameInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetHostnameResponse (910)
	virtual int soap_type(void) const { return 910; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetHostnameResponse); }
	         _tds__GetHostnameResponse() { _tds__GetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__GetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2697 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (911)
/* tds:SetHostname complex type: */
class SOAP_CMAC _tds__SetHostname
{
public:
	char *Name;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostname (911)
	virtual int soap_type(void) const { return 911; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
	virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostname); }
	         _tds__SetHostname() { _tds__SetHostname::soap_default(NULL); }
	virtual ~_tds__SetHostname() { }
	friend SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2700 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (912)
/* tds:SetHostnameResponse complex type: */
class SOAP_CMAC _tds__SetHostnameResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameResponse (912)
	virtual int soap_type(void) const { return 912; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameResponse); }
	         _tds__SetHostnameResponse() { _tds__SetHostnameResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2703 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (913)
/* tds:SetHostnameFromDHCP complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCP (913)
	virtual int soap_type(void) const { return 913; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCP); }
	         _tds__SetHostnameFromDHCP() { _tds__SetHostnameFromDHCP::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCP() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2706 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (914)
/* tds:SetHostnameFromDHCPResponse complex type: */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetHostnameFromDHCPResponse (914)
	virtual int soap_type(void) const { return 914; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
	virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetHostnameFromDHCPResponse); }
	         _tds__SetHostnameFromDHCPResponse() { _tds__SetHostnameFromDHCPResponse::soap_default(NULL); }
	virtual ~_tds__SetHostnameFromDHCPResponse() { }
	friend SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2709 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (915)
/* tds:GetDNS complex type: */
class SOAP_CMAC _tds__GetDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNS (915)
	virtual int soap_type(void) const { return 915; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
	virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNS); }
	         _tds__GetDNS() { _tds__GetDNS::soap_default(NULL); }
	virtual ~_tds__GetDNS() { }
	friend SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2712 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (916)
/* tds:GetDNSResponse complex type: */
class SOAP_CMAC _tds__GetDNSResponse
{
public:
	tt__DNSInformation *DNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDNSResponse (916)
	virtual int soap_type(void) const { return 916; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDNSResponse); }
	         _tds__GetDNSResponse() { _tds__GetDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2715 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (917)
/* tds:SetDNS complex type: */
class SOAP_CMAC _tds__SetDNS
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeSearchDomain;	/* sequence of elements <SearchDomain> of XSD type xsd:token */
	char **SearchDomain;
	int __sizeDNSManual;	/* sequence of elements <DNSManual> of XSD type tt:IPAddress */
	tt__IPAddress **DNSManual;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNS (917)
	virtual int soap_type(void) const { return 917; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
	virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNS); }
	         _tds__SetDNS() { _tds__SetDNS::soap_default(NULL); }
	virtual ~_tds__SetDNS() { }
	friend SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2718 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (918)
/* tds:SetDNSResponse complex type: */
class SOAP_CMAC _tds__SetDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDNSResponse (918)
	virtual int soap_type(void) const { return 918; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDNSResponse); }
	         _tds__SetDNSResponse() { _tds__SetDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2721 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (919)
/* tds:GetNTP complex type: */
class SOAP_CMAC _tds__GetNTP
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTP (919)
	virtual int soap_type(void) const { return 919; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
	virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTP); }
	         _tds__GetNTP() { _tds__GetNTP::soap_default(NULL); }
	virtual ~_tds__GetNTP() { }
	friend SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2724 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (920)
/* tds:GetNTPResponse complex type: */
class SOAP_CMAC _tds__GetNTPResponse
{
public:
	tt__NTPInformation *NTPInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NTPInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNTPResponse (920)
	virtual int soap_type(void) const { return 920; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNTPResponse); }
	         _tds__GetNTPResponse() { _tds__GetNTPResponse::soap_default(NULL); }
	virtual ~_tds__GetNTPResponse() { }
	friend SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2727 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (921)
/* tds:SetNTP complex type: */
class SOAP_CMAC _tds__SetNTP
{
public:
	bool FromDHCP;	/* required element of XSD type xsd:boolean */
	int __sizeNTPManual;	/* sequence of elements <NTPManual> of XSD type tt:NetworkHost */
	tt__NetworkHost **NTPManual;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTP (921)
	virtual int soap_type(void) const { return 921; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
	virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTP); }
	         _tds__SetNTP() { _tds__SetNTP::soap_default(NULL); }
	virtual ~_tds__SetNTP() { }
	friend SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2730 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (922)
/* tds:SetNTPResponse complex type: */
class SOAP_CMAC _tds__SetNTPResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNTPResponse (922)
	virtual int soap_type(void) const { return 922; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
	virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNTPResponse); }
	         _tds__SetNTPResponse() { _tds__SetNTPResponse::soap_default(NULL); }
	virtual ~_tds__SetNTPResponse() { }
	friend SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2733 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (923)
/* tds:GetDynamicDNS complex type: */
class SOAP_CMAC _tds__GetDynamicDNS
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNS (923)
	virtual int soap_type(void) const { return 923; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNS); }
	         _tds__GetDynamicDNS() { _tds__GetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2736 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (924)
/* tds:GetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__GetDynamicDNSResponse
{
public:
	tt__DynamicDNSInformation *DynamicDNSInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:DynamicDNSInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDynamicDNSResponse (924)
	virtual int soap_type(void) const { return 924; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDynamicDNSResponse); }
	         _tds__GetDynamicDNSResponse() { _tds__GetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__GetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2739 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (925)
/* tds:SetDynamicDNS complex type: */
class SOAP_CMAC _tds__SetDynamicDNS
{
public:
	enum tt__DynamicDNSType Type;	/* required element of XSD type tt:DynamicDNSType */
	char *Name;	/* optional element of XSD type tt:DNSName */
	LONG64 *TTL;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNS (925)
	virtual int soap_type(void) const { return 925; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNS); }
	         _tds__SetDynamicDNS() { _tds__SetDynamicDNS::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNS() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2742 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (926)
/* tds:SetDynamicDNSResponse complex type: */
class SOAP_CMAC _tds__SetDynamicDNSResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDynamicDNSResponse (926)
	virtual int soap_type(void) const { return 926; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
	virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDynamicDNSResponse); }
	         _tds__SetDynamicDNSResponse() { _tds__SetDynamicDNSResponse::soap_default(NULL); }
	virtual ~_tds__SetDynamicDNSResponse() { }
	friend SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2745 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (927)
/* tds:GetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__GetNetworkInterfaces
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfaces (927)
	virtual int soap_type(void) const { return 927; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfaces); }
	         _tds__GetNetworkInterfaces() { _tds__GetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2748 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (928)
/* tds:GetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse
{
public:
	int __sizeNetworkInterfaces;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NetworkInterfaces> of XSD type tt:NetworkInterface */
	tt__NetworkInterface **NetworkInterfaces;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkInterfacesResponse (928)
	virtual int soap_type(void) const { return 928; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkInterfacesResponse); }
	         _tds__GetNetworkInterfacesResponse() { _tds__GetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2751 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (929)
/* tds:SetNetworkInterfaces complex type: */
class SOAP_CMAC _tds__SetNetworkInterfaces
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__NetworkInterfaceSetConfiguration *NetworkInterface;	/* required element of XSD type tt:NetworkInterfaceSetConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfaces (929)
	virtual int soap_type(void) const { return 929; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfaces); }
	         _tds__SetNetworkInterfaces() { _tds__SetNetworkInterfaces::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfaces() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2754 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (930)
/* tds:SetNetworkInterfacesResponse complex type: */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse
{
public:
	bool RebootNeeded;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkInterfacesResponse (930)
	virtual int soap_type(void) const { return 930; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkInterfacesResponse); }
	         _tds__SetNetworkInterfacesResponse() { _tds__SetNetworkInterfacesResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkInterfacesResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2757 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (931)
/* tds:GetNetworkProtocols complex type: */
class SOAP_CMAC _tds__GetNetworkProtocols
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocols (931)
	virtual int soap_type(void) const { return 931; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocols); }
	         _tds__GetNetworkProtocols() { _tds__GetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2760 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (932)
/* tds:GetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse
{
public:
	int __sizeNetworkProtocols;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NetworkProtocols> of XSD type tt:NetworkProtocol */
	tt__NetworkProtocol **NetworkProtocols;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkProtocolsResponse (932)
	virtual int soap_type(void) const { return 932; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkProtocolsResponse); }
	         _tds__GetNetworkProtocolsResponse() { _tds__GetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2763 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (933)
/* tds:SetNetworkProtocols complex type: */
class SOAP_CMAC _tds__SetNetworkProtocols
{
public:
	int __sizeNetworkProtocols;	/* sequence of elements <NetworkProtocols> of XSD type tt:NetworkProtocol */
	tt__NetworkProtocol **NetworkProtocols;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocols (933)
	virtual int soap_type(void) const { return 933; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocols); }
	         _tds__SetNetworkProtocols() { _tds__SetNetworkProtocols::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocols() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2766 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (934)
/* tds:SetNetworkProtocolsResponse complex type: */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkProtocolsResponse (934)
	virtual int soap_type(void) const { return 934; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkProtocolsResponse); }
	         _tds__SetNetworkProtocolsResponse() { _tds__SetNetworkProtocolsResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkProtocolsResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2769 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (935)
/* tds:GetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGateway
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGateway (935)
	virtual int soap_type(void) const { return 935; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGateway); }
	         _tds__GetNetworkDefaultGateway() { _tds__GetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2772 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (936)
/* tds:GetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse
{
public:
	tt__NetworkGateway *NetworkGateway;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkGateway */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (936)
	virtual int soap_type(void) const { return 936; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetNetworkDefaultGatewayResponse); }
	         _tds__GetNetworkDefaultGatewayResponse() { _tds__GetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2775 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (937)
/* tds:SetNetworkDefaultGateway complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGateway
{
public:
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> of XSD type tt:IPv4Address */
	char **IPv4Address;
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> of XSD type tt:IPv6Address */
	char **IPv6Address;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGateway (937)
	virtual int soap_type(void) const { return 937; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGateway); }
	         _tds__SetNetworkDefaultGateway() { _tds__SetNetworkDefaultGateway::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGateway() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2778 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (938)
/* tds:SetNetworkDefaultGatewayResponse complex type: */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (938)
	virtual int soap_type(void) const { return 938; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
	virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetNetworkDefaultGatewayResponse); }
	         _tds__SetNetworkDefaultGatewayResponse() { _tds__SetNetworkDefaultGatewayResponse::soap_default(NULL); }
	virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
	friend SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2781 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (939)
/* tds:GetZeroConfiguration complex type: */
class SOAP_CMAC _tds__GetZeroConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfiguration (939)
	virtual int soap_type(void) const { return 939; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfiguration); }
	         _tds__GetZeroConfiguration() { _tds__GetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__GetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2784 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (940)
/* tds:GetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetZeroConfigurationResponse
{
public:
	tt__NetworkZeroConfiguration *ZeroConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:NetworkZeroConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetZeroConfigurationResponse (940)
	virtual int soap_type(void) const { return 940; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetZeroConfigurationResponse); }
	         _tds__GetZeroConfigurationResponse() { _tds__GetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2787 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (941)
/* tds:SetZeroConfiguration complex type: */
class SOAP_CMAC _tds__SetZeroConfiguration
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfiguration (941)
	virtual int soap_type(void) const { return 941; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfiguration); }
	         _tds__SetZeroConfiguration() { _tds__SetZeroConfiguration::soap_default(NULL); }
	virtual ~_tds__SetZeroConfiguration() { }
	friend SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2790 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (942)
/* tds:SetZeroConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetZeroConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetZeroConfigurationResponse (942)
	virtual int soap_type(void) const { return 942; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetZeroConfigurationResponse); }
	         _tds__SetZeroConfigurationResponse() { _tds__SetZeroConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetZeroConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2793 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (943)
/* tds:GetIPAddressFilter complex type: */
class SOAP_CMAC _tds__GetIPAddressFilter
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilter (943)
	virtual int soap_type(void) const { return 943; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilter); }
	         _tds__GetIPAddressFilter() { _tds__GetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2796 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (944)
/* tds:GetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__GetIPAddressFilterResponse
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetIPAddressFilterResponse (944)
	virtual int soap_type(void) const { return 944; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetIPAddressFilterResponse); }
	         _tds__GetIPAddressFilterResponse() { _tds__GetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__GetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2799 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (945)
/* tds:SetIPAddressFilter complex type: */
class SOAP_CMAC _tds__SetIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilter (945)
	virtual int soap_type(void) const { return 945; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilter); }
	         _tds__SetIPAddressFilter() { _tds__SetIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2802 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (946)
/* tds:SetIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__SetIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetIPAddressFilterResponse (946)
	virtual int soap_type(void) const { return 946; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetIPAddressFilterResponse); }
	         _tds__SetIPAddressFilterResponse() { _tds__SetIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__SetIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2805 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (947)
/* tds:AddIPAddressFilter complex type: */
class SOAP_CMAC _tds__AddIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilter (947)
	virtual int soap_type(void) const { return 947; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilter); }
	         _tds__AddIPAddressFilter() { _tds__AddIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2808 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (948)
/* tds:AddIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__AddIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__AddIPAddressFilterResponse (948)
	virtual int soap_type(void) const { return 948; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__AddIPAddressFilterResponse); }
	         _tds__AddIPAddressFilterResponse() { _tds__AddIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__AddIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2811 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (949)
/* tds:RemoveIPAddressFilter complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilter
{
public:
	tt__IPAddressFilter *IPAddressFilter;	/* required element of XSD type tt:IPAddressFilter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilter (949)
	virtual int soap_type(void) const { return 949; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilter); }
	         _tds__RemoveIPAddressFilter() { _tds__RemoveIPAddressFilter::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilter() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2814 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (950)
/* tds:RemoveIPAddressFilterResponse complex type: */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__RemoveIPAddressFilterResponse (950)
	virtual int soap_type(void) const { return 950; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
	virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW(_tds__RemoveIPAddressFilterResponse); }
	         _tds__RemoveIPAddressFilterResponse() { _tds__RemoveIPAddressFilterResponse::soap_default(NULL); }
	virtual ~_tds__RemoveIPAddressFilterResponse() { }
	friend SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2817 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (951)
/* tds:GetAccessPolicy complex type: */
class SOAP_CMAC _tds__GetAccessPolicy
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicy (951)
	virtual int soap_type(void) const { return 951; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicy); }
	         _tds__GetAccessPolicy() { _tds__GetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2820 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (952)
/* tds:GetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__GetAccessPolicyResponse
{
public:
	tt__BinaryData *PolicyFile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetAccessPolicyResponse (952)
	virtual int soap_type(void) const { return 952; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetAccessPolicyResponse); }
	         _tds__GetAccessPolicyResponse() { _tds__GetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__GetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2823 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (953)
/* tds:SetAccessPolicy complex type: */
class SOAP_CMAC _tds__SetAccessPolicy
{
public:
	tt__BinaryData *PolicyFile;	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicy (953)
	virtual int soap_type(void) const { return 953; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicy); }
	         _tds__SetAccessPolicy() { _tds__SetAccessPolicy::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicy() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2826 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (954)
/* tds:SetAccessPolicyResponse complex type: */
class SOAP_CMAC _tds__SetAccessPolicyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetAccessPolicyResponse (954)
	virtual int soap_type(void) const { return 954; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
	virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetAccessPolicyResponse); }
	         _tds__SetAccessPolicyResponse() { _tds__SetAccessPolicyResponse::soap_default(NULL); }
	virtual ~_tds__SetAccessPolicyResponse() { }
	friend SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2829 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (955)
/* tds:CreateCertificate complex type: */
class SOAP_CMAC _tds__CreateCertificate
{
public:
	char *CertificateID;	/* optional element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	time_t *ValidNotBefore;	/* optional element of XSD type xsd:dateTime */
	time_t *ValidNotAfter;	/* optional element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificate (955)
	virtual int soap_type(void) const { return 955; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
	virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificate); }
	         _tds__CreateCertificate() { _tds__CreateCertificate::soap_default(NULL); }
	virtual ~_tds__CreateCertificate() { }
	friend SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2832 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (956)
/* tds:CreateCertificateResponse complex type: */
class SOAP_CMAC _tds__CreateCertificateResponse
{
public:
	tt__Certificate *NvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Certificate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateCertificateResponse (956)
	virtual int soap_type(void) const { return 956; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
	virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateCertificateResponse); }
	         _tds__CreateCertificateResponse() { _tds__CreateCertificateResponse::soap_default(NULL); }
	virtual ~_tds__CreateCertificateResponse() { }
	friend SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2835 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (957)
/* tds:GetCertificates complex type: */
class SOAP_CMAC _tds__GetCertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificates (957)
	virtual int soap_type(void) const { return 957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
	virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificates); }
	         _tds__GetCertificates() { _tds__GetCertificates::soap_default(NULL); }
	virtual ~_tds__GetCertificates() { }
	friend SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2838 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (958)
/* tds:GetCertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesResponse
{
public:
	int __sizeNvtCertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <NvtCertificate> of XSD type tt:Certificate */
	tt__Certificate **NvtCertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesResponse (958)
	virtual int soap_type(void) const { return 958; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesResponse); }
	         _tds__GetCertificatesResponse() { _tds__GetCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2841 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (959)
/* tds:GetCertificatesStatus complex type: */
class SOAP_CMAC _tds__GetCertificatesStatus
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatus (959)
	virtual int soap_type(void) const { return 959; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatus); }
	         _tds__GetCertificatesStatus() { _tds__GetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2844 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (960)
/* tds:GetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__GetCertificatesStatusResponse
{
public:
	int __sizeCertificateStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <CertificateStatus> of XSD type tt:CertificateStatus */
	tt__CertificateStatus **CertificateStatus;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificatesStatusResponse (960)
	virtual int soap_type(void) const { return 960; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificatesStatusResponse); }
	         _tds__GetCertificatesStatusResponse() { _tds__GetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2847 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (961)
/* tds:SetCertificatesStatus complex type: */
class SOAP_CMAC _tds__SetCertificatesStatus
{
public:
	int __sizeCertificateStatus;	/* sequence of elements <CertificateStatus> of XSD type tt:CertificateStatus */
	tt__CertificateStatus **CertificateStatus;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatus (961)
	virtual int soap_type(void) const { return 961; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatus); }
	         _tds__SetCertificatesStatus() { _tds__SetCertificatesStatus::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatus() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2850 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (962)
/* tds:SetCertificatesStatusResponse complex type: */
class SOAP_CMAC _tds__SetCertificatesStatusResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetCertificatesStatusResponse (962)
	virtual int soap_type(void) const { return 962; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
	virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetCertificatesStatusResponse); }
	         _tds__SetCertificatesStatusResponse() { _tds__SetCertificatesStatusResponse::soap_default(NULL); }
	virtual ~_tds__SetCertificatesStatusResponse() { }
	friend SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2853 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (963)
/* tds:DeleteCertificates complex type: */
class SOAP_CMAC _tds__DeleteCertificates
{
public:
	int __sizeCertificateID;	/* sequence of elements <CertificateID> of XSD type xsd:token */
	char **CertificateID;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificates (963)
	virtual int soap_type(void) const { return 963; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificates); }
	         _tds__DeleteCertificates() { _tds__DeleteCertificates::soap_default(NULL); }
	virtual ~_tds__DeleteCertificates() { }
	friend SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2856 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (964)
/* tds:DeleteCertificatesResponse complex type: */
class SOAP_CMAC _tds__DeleteCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteCertificatesResponse (964)
	virtual int soap_type(void) const { return 964; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteCertificatesResponse); }
	         _tds__DeleteCertificatesResponse() { _tds__DeleteCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__DeleteCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2859 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (965)
/* tds:GetPkcs10Request complex type: */
class SOAP_CMAC _tds__GetPkcs10Request
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	char *Subject;	/* optional element of XSD type xsd:string */
	tt__BinaryData *Attributes;	/* optional element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10Request (965)
	virtual int soap_type(void) const { return 965; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10Request); }
	         _tds__GetPkcs10Request() { _tds__GetPkcs10Request::soap_default(NULL); }
	virtual ~_tds__GetPkcs10Request() { }
	friend SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2862 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (966)
/* tds:GetPkcs10RequestResponse complex type: */
class SOAP_CMAC _tds__GetPkcs10RequestResponse
{
public:
	tt__BinaryData *Pkcs10Request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:BinaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetPkcs10RequestResponse (966)
	virtual int soap_type(void) const { return 966; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
	virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetPkcs10RequestResponse); }
	         _tds__GetPkcs10RequestResponse() { _tds__GetPkcs10RequestResponse::soap_default(NULL); }
	virtual ~_tds__GetPkcs10RequestResponse() { }
	friend SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2865 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (967)
/* tds:LoadCertificates complex type: */
class SOAP_CMAC _tds__LoadCertificates
{
public:
	int __sizeNVTCertificate;	/* sequence of elements <NVTCertificate> of XSD type tt:Certificate */
	tt__Certificate **NVTCertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificates (967)
	virtual int soap_type(void) const { return 967; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificates); }
	         _tds__LoadCertificates() { _tds__LoadCertificates::soap_default(NULL); }
	virtual ~_tds__LoadCertificates() { }
	friend SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2868 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (968)
/* tds:LoadCertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificatesResponse (968)
	virtual int soap_type(void) const { return 968; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificatesResponse); }
	         _tds__LoadCertificatesResponse() { _tds__LoadCertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2871 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (969)
/* tds:GetClientCertificateMode complex type: */
class SOAP_CMAC _tds__GetClientCertificateMode
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateMode (969)
	virtual int soap_type(void) const { return 969; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateMode); }
	         _tds__GetClientCertificateMode() { _tds__GetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2874 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (970)
/* tds:GetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__GetClientCertificateModeResponse
{
public:
	bool Enabled;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetClientCertificateModeResponse (970)
	virtual int soap_type(void) const { return 970; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetClientCertificateModeResponse); }
	         _tds__GetClientCertificateModeResponse() { _tds__GetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__GetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2877 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (971)
/* tds:SetClientCertificateMode complex type: */
class SOAP_CMAC _tds__SetClientCertificateMode
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateMode (971)
	virtual int soap_type(void) const { return 971; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateMode); }
	         _tds__SetClientCertificateMode() { _tds__SetClientCertificateMode::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateMode() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2880 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (972)
/* tds:SetClientCertificateModeResponse complex type: */
class SOAP_CMAC _tds__SetClientCertificateModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetClientCertificateModeResponse (972)
	virtual int soap_type(void) const { return 972; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
	virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetClientCertificateModeResponse); }
	         _tds__SetClientCertificateModeResponse() { _tds__SetClientCertificateModeResponse::soap_default(NULL); }
	virtual ~_tds__SetClientCertificateModeResponse() { }
	friend SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2883 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (973)
/* tds:GetCACertificates complex type: */
class SOAP_CMAC _tds__GetCACertificates
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificates (973)
	virtual int soap_type(void) const { return 973; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
	virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificates); }
	         _tds__GetCACertificates() { _tds__GetCACertificates::soap_default(NULL); }
	virtual ~_tds__GetCACertificates() { }
	friend SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2886 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (974)
/* tds:GetCACertificatesResponse complex type: */
class SOAP_CMAC _tds__GetCACertificatesResponse
{
public:
	int __sizeCACertificate;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <CACertificate> of XSD type tt:Certificate */
	tt__Certificate **CACertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCACertificatesResponse (974)
	virtual int soap_type(void) const { return 974; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCACertificatesResponse); }
	         _tds__GetCACertificatesResponse() { _tds__GetCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__GetCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2889 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (975)
/* tds:LoadCertificateWithPrivateKey complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey
{
public:
	int __sizeCertificateWithPrivateKey;	/* sequence of elements <CertificateWithPrivateKey> of XSD type tt:CertificateWithPrivateKey */
	tt__CertificateWithPrivateKey **CertificateWithPrivateKey;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKey (975)
	virtual int soap_type(void) const { return 975; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKey); }
	         _tds__LoadCertificateWithPrivateKey() { _tds__LoadCertificateWithPrivateKey::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKey() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2892 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (976)
/* tds:LoadCertificateWithPrivateKeyResponse complex type: */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (976)
	virtual int soap_type(void) const { return 976; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCertificateWithPrivateKeyResponse); }
	         _tds__LoadCertificateWithPrivateKeyResponse() { _tds__LoadCertificateWithPrivateKeyResponse::soap_default(NULL); }
	virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
	friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2895 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (977)
/* tds:GetCertificateInformation complex type: */
class SOAP_CMAC _tds__GetCertificateInformation
{
public:
	char *CertificateID;	/* required element of XSD type xsd:token */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformation (977)
	virtual int soap_type(void) const { return 977; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformation); }
	         _tds__GetCertificateInformation() { _tds__GetCertificateInformation::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformation() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2898 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (978)
/* tds:GetCertificateInformationResponse complex type: */
class SOAP_CMAC _tds__GetCertificateInformationResponse
{
public:
	tt__CertificateInformation *CertificateInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:CertificateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetCertificateInformationResponse (978)
	virtual int soap_type(void) const { return 978; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
	virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetCertificateInformationResponse); }
	         _tds__GetCertificateInformationResponse() { _tds__GetCertificateInformationResponse::soap_default(NULL); }
	virtual ~_tds__GetCertificateInformationResponse() { }
	friend SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2901 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (979)
/* tds:LoadCACertificates complex type: */
class SOAP_CMAC _tds__LoadCACertificates
{
public:
	int __sizeCACertificate;	/* sequence of elements <CACertificate> of XSD type tt:Certificate */
	tt__Certificate **CACertificate;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificates (979)
	virtual int soap_type(void) const { return 979; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificates); }
	         _tds__LoadCACertificates() { _tds__LoadCACertificates::soap_default(NULL); }
	virtual ~_tds__LoadCACertificates() { }
	friend SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2904 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (980)
/* tds:LoadCACertificatesResponse complex type: */
class SOAP_CMAC _tds__LoadCACertificatesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__LoadCACertificatesResponse (980)
	virtual int soap_type(void) const { return 980; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
	virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__LoadCACertificatesResponse); }
	         _tds__LoadCACertificatesResponse() { _tds__LoadCACertificatesResponse::soap_default(NULL); }
	virtual ~_tds__LoadCACertificatesResponse() { }
	friend SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2907 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (981)
/* tds:CreateDot1XConfiguration complex type: */
class SOAP_CMAC _tds__CreateDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfiguration (981)
	virtual int soap_type(void) const { return 981; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfiguration); }
	         _tds__CreateDot1XConfiguration() { _tds__CreateDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2910 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (982)
/* tds:CreateDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__CreateDot1XConfigurationResponse (982)
	virtual int soap_type(void) const { return 982; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__CreateDot1XConfigurationResponse); }
	         _tds__CreateDot1XConfigurationResponse() { _tds__CreateDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__CreateDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2913 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (983)
/* tds:SetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__SetDot1XConfiguration
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfiguration (983)
	virtual int soap_type(void) const { return 983; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfiguration); }
	         _tds__SetDot1XConfiguration() { _tds__SetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2916 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (984)
/* tds:SetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetDot1XConfigurationResponse (984)
	virtual int soap_type(void) const { return 984; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetDot1XConfigurationResponse); }
	         _tds__SetDot1XConfigurationResponse() { _tds__SetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__SetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2919 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (985)
/* tds:GetDot1XConfiguration complex type: */
class SOAP_CMAC _tds__GetDot1XConfiguration
{
public:
	char *Dot1XConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfiguration (985)
	virtual int soap_type(void) const { return 985; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfiguration); }
	         _tds__GetDot1XConfiguration() { _tds__GetDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2922 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (986)
/* tds:GetDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse
{
public:
	tt__Dot1XConfiguration *Dot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot1XConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationResponse (986)
	virtual int soap_type(void) const { return 986; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationResponse); }
	         _tds__GetDot1XConfigurationResponse() { _tds__GetDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2925 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (987)
/* tds:GetDot1XConfigurations complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurations (987)
	virtual int soap_type(void) const { return 987; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurations); }
	         _tds__GetDot1XConfigurations() { _tds__GetDot1XConfigurations::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurations() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2928 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (988)
/* tds:GetDot1XConfigurationsResponse complex type: */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse
{
public:
	int __sizeDot1XConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Dot1XConfiguration> of XSD type tt:Dot1XConfiguration */
	tt__Dot1XConfiguration **Dot1XConfiguration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot1XConfigurationsResponse (988)
	virtual int soap_type(void) const { return 988; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot1XConfigurationsResponse); }
	         _tds__GetDot1XConfigurationsResponse() { _tds__GetDot1XConfigurationsResponse::soap_default(NULL); }
	virtual ~_tds__GetDot1XConfigurationsResponse() { }
	friend SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2931 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (989)
/* tds:DeleteDot1XConfiguration complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfiguration
{
public:
	int __sizeDot1XConfigurationToken;	/* sequence of elements <Dot1XConfigurationToken> of XSD type tt:ReferenceToken */
	char **Dot1XConfigurationToken;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfiguration (989)
	virtual int soap_type(void) const { return 989; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfiguration); }
	         _tds__DeleteDot1XConfiguration() { _tds__DeleteDot1XConfiguration::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfiguration() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2934 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (990)
/* tds:DeleteDot1XConfigurationResponse complex type: */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (990)
	virtual int soap_type(void) const { return 990; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
	virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tds__DeleteDot1XConfigurationResponse); }
	         _tds__DeleteDot1XConfigurationResponse() { _tds__DeleteDot1XConfigurationResponse::soap_default(NULL); }
	virtual ~_tds__DeleteDot1XConfigurationResponse() { }
	friend SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2937 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (991)
/* tds:GetRelayOutputs complex type: */
class SOAP_CMAC _tds__GetRelayOutputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputs (991)
	virtual int soap_type(void) const { return 991; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputs); }
	         _tds__GetRelayOutputs() { _tds__GetRelayOutputs::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputs() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2940 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (992)
/* tds:GetRelayOutputsResponse complex type: */
class SOAP_CMAC _tds__GetRelayOutputsResponse
{
public:
	int __sizeRelayOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <RelayOutputs> of XSD type tt:RelayOutput */
	tt__RelayOutput **RelayOutputs;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetRelayOutputsResponse (992)
	virtual int soap_type(void) const { return 992; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
	virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetRelayOutputsResponse); }
	         _tds__GetRelayOutputsResponse() { _tds__GetRelayOutputsResponse::soap_default(NULL); }
	virtual ~_tds__GetRelayOutputsResponse() { }
	friend SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2943 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (993)
/* tds:SetRelayOutputSettings complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettings
{
public:
	char *RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettings (993)
	virtual int soap_type(void) const { return 993; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettings); }
	         _tds__SetRelayOutputSettings() { _tds__SetRelayOutputSettings::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettings() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2946 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (994)
/* tds:SetRelayOutputSettingsResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputSettingsResponse (994)
	virtual int soap_type(void) const { return 994; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputSettingsResponse); }
	         _tds__SetRelayOutputSettingsResponse() { _tds__SetRelayOutputSettingsResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputSettingsResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2949 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (995)
/* tds:SetRelayOutputState complex type: */
class SOAP_CMAC _tds__SetRelayOutputState
{
public:
	char *RelayOutputToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__RelayLogicalState LogicalState;	/* required element of XSD type tt:RelayLogicalState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputState (995)
	virtual int soap_type(void) const { return 995; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputState); }
	         _tds__SetRelayOutputState() { _tds__SetRelayOutputState::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputState() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2952 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (996)
/* tds:SetRelayOutputStateResponse complex type: */
class SOAP_CMAC _tds__SetRelayOutputStateResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SetRelayOutputStateResponse (996)
	virtual int soap_type(void) const { return 996; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
	virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SetRelayOutputStateResponse); }
	         _tds__SetRelayOutputStateResponse() { _tds__SetRelayOutputStateResponse::soap_default(NULL); }
	virtual ~_tds__SetRelayOutputStateResponse() { }
	friend SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2955 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (997)
/* tds:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommand
{
public:
	char *AuxiliaryCommand;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommand (997)
	virtual int soap_type(void) const { return 997; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommand); }
	         _tds__SendAuxiliaryCommand() { _tds__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommand() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2958 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (998)
/* tds:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse
{
public:
	char *AuxiliaryCommandResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__SendAuxiliaryCommandResponse (998)
	virtual int soap_type(void) const { return 998; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tds__SendAuxiliaryCommandResponse); }
	         _tds__SendAuxiliaryCommandResponse() { _tds__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tds__SendAuxiliaryCommandResponse() { }
	friend SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2961 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (999)
/* tds:GetDot11Capabilities complex type: */
class SOAP_CMAC _tds__GetDot11Capabilities
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Capabilities (999)
	virtual int soap_type(void) const { return 999; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
	virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Capabilities); }
	         _tds__GetDot11Capabilities() { _tds__GetDot11Capabilities::soap_default(NULL); }
	virtual ~_tds__GetDot11Capabilities() { }
	friend SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2964 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (1000)
/* tds:GetDot11CapabilitiesResponse complex type: */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse
{
public:
	tt__Dot11Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11CapabilitiesResponse (1000)
	virtual int soap_type(void) const { return 1000; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11CapabilitiesResponse); }
	         _tds__GetDot11CapabilitiesResponse() { _tds__GetDot11CapabilitiesResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11CapabilitiesResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2967 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (1001)
/* tds:GetDot11Status complex type: */
class SOAP_CMAC _tds__GetDot11Status
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11Status (1001)
	virtual int soap_type(void) const { return 1001; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
	virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11Status); }
	         _tds__GetDot11Status() { _tds__GetDot11Status::soap_default(NULL); }
	virtual ~_tds__GetDot11Status() { }
	friend SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2970 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (1002)
/* tds:GetDot11StatusResponse complex type: */
class SOAP_CMAC _tds__GetDot11StatusResponse
{
public:
	tt__Dot11Status *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Dot11Status */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetDot11StatusResponse (1002)
	virtual int soap_type(void) const { return 1002; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
	virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetDot11StatusResponse); }
	         _tds__GetDot11StatusResponse() { _tds__GetDot11StatusResponse::soap_default(NULL); }
	virtual ~_tds__GetDot11StatusResponse() { }
	friend SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2973 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (1003)
/* tds:ScanAvailableDot11Networks complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11Networks
{
public:
	char *InterfaceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11Networks (1003)
	virtual int soap_type(void) const { return 1003; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11Networks); }
	         _tds__ScanAvailableDot11Networks() { _tds__ScanAvailableDot11Networks::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11Networks() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2976 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (1004)
/* tds:ScanAvailableDot11NetworksResponse complex type: */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse
{
public:
	int __sizeNetworks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Networks> of XSD type tt:Dot11AvailableNetworks */
	tt__Dot11AvailableNetworks **Networks;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (1004)
	virtual int soap_type(void) const { return 1004; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
	virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW(_tds__ScanAvailableDot11NetworksResponse); }
	         _tds__ScanAvailableDot11NetworksResponse() { _tds__ScanAvailableDot11NetworksResponse::soap_default(NULL); }
	virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
	friend SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2979 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (1005)
/* tds:GetSystemUris complex type: */
class SOAP_CMAC _tds__GetSystemUris
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUris (1005)
	virtual int soap_type(void) const { return 1005; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
	virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUris); }
	         _tds__GetSystemUris() { _tds__GetSystemUris::soap_default(NULL); }
	virtual ~_tds__GetSystemUris() { }
	friend SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:30633 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (2133)
/* tds:GetSystemUrisResponse-Extension complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse_Extension (2133)
	virtual int soap_type(void) const { return 2133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse_Extension); }
	         _tds__GetSystemUrisResponse_Extension() { _tds__GetSystemUrisResponse_Extension::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse_Extension() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2982 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (1006)
/* tds:GetSystemUrisResponse complex type: */
class SOAP_CMAC _tds__GetSystemUrisResponse
{
public:
	tt__SystemLogUriList *SystemLogUris;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:SystemLogUriList */
	char *SupportInfoUri;	/* optional element of XSD type xsd:anyURI */
	char *SystemBackupUri;	/* optional element of XSD type xsd:anyURI */
	_tds__GetSystemUrisResponse_Extension *Extension;	/* optional element of XSD type tds:GetSystemUrisResponse-Extension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__GetSystemUrisResponse (1006)
	virtual int soap_type(void) const { return 1006; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
	virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW(_tds__GetSystemUrisResponse); }
	         _tds__GetSystemUrisResponse() { _tds__GetSystemUrisResponse::soap_default(NULL); }
	virtual ~_tds__GetSystemUrisResponse() { }
	friend SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2985 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (1007)
/* tds:StartFirmwareUpgrade complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgrade
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgrade (1007)
	virtual int soap_type(void) const { return 1007; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgrade); }
	         _tds__StartFirmwareUpgrade() { _tds__StartFirmwareUpgrade::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgrade() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2988 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (1008)
/* tds:StartFirmwareUpgradeResponse complex type: */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse
{
public:
	char *UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 UploadDelay;	/* external (custom serializer) */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartFirmwareUpgradeResponse (1008)
	virtual int soap_type(void) const { return 1008; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
	virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartFirmwareUpgradeResponse); }
	         _tds__StartFirmwareUpgradeResponse() { _tds__StartFirmwareUpgradeResponse::soap_default(NULL); }
	virtual ~_tds__StartFirmwareUpgradeResponse() { }
	friend SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2991 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (1009)
/* tds:StartSystemRestore complex type: */
class SOAP_CMAC _tds__StartSystemRestore
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestore (1009)
	virtual int soap_type(void) const { return 1009; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestore); }
	         _tds__StartSystemRestore() { _tds__StartSystemRestore::soap_default(NULL); }
	virtual ~_tds__StartSystemRestore() { }
	friend SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2994 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (1010)
/* tds:StartSystemRestoreResponse complex type: */
class SOAP_CMAC _tds__StartSystemRestoreResponse
{
public:
	char *UploadUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	LONG64 ExpectedDownTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tds__StartSystemRestoreResponse (1010)
	virtual int soap_type(void) const { return 1010; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
	virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW(_tds__StartSystemRestoreResponse); }
	         _tds__StartSystemRestoreResponse() { _tds__StartSystemRestoreResponse::soap_default(NULL); }
	virtual ~_tds__StartSystemRestoreResponse() { }
	friend SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2997 */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (1011)
/* Type tev__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tev:Capabilities complex type: */
class SOAP_CMAC tev__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *WSSubscriptionPolicySupport;	/* optional attribute of XSD type xsd:boolean */
	bool *WSPullPointSupport;	/* optional attribute of XSD type xsd:boolean */
	bool *WSPausableSubscriptionManagerInterfaceSupport;	/* optional attribute of XSD type xsd:boolean */
	int *MaxNotificationProducers;	/* optional attribute of XSD type xsd:int */
	int *MaxPullPoints;	/* optional attribute of XSD type xsd:int */
	bool *PersistentNotificationStorage;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tev__Capabilities (1011)
	virtual int soap_type(void) const { return 1011; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tev__Capabilities, default initialized and not managed by a soap context
	virtual tev__Capabilities *soap_alloc(void) const { return SOAP_NEW(tev__Capabilities); }
	         tev__Capabilities() { tev__Capabilities::soap_default(NULL); }
	virtual ~tev__Capabilities() { }
	friend SOAP_FMAC1 tev__Capabilities * SOAP_FMAC2 soap_instantiate_tev__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3000 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (1012)
/* tev:GetServiceCapabilities complex type: */
class SOAP_CMAC _tev__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetServiceCapabilities (1012)
	virtual int soap_type(void) const { return 1012; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tev__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tev__GetServiceCapabilities); }
	         _tev__GetServiceCapabilities() { _tev__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tev__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3003 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (1013)
/* tev:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tev__GetServiceCapabilitiesResponse
{
public:
	tev__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tev:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetServiceCapabilitiesResponse (1013)
	virtual int soap_type(void) const { return 1013; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tev__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__GetServiceCapabilitiesResponse); }
	         _tev__GetServiceCapabilitiesResponse() { _tev__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tev__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:30885 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (2136)
/* tev:CreatePullPointSubscription-SubscriptionPolicy complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscription_SubscriptionPolicy
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (2136)
	virtual int soap_type(void) const { return 2136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscription_SubscriptionPolicy); }
	         _tev__CreatePullPointSubscription_SubscriptionPolicy() { _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription_SubscriptionPolicy() { }
	friend SOAP_FMAC1 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3006 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (1014)
/* tev:CreatePullPointSubscription complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscription
{
public:
	wsnt__FilterType *Filter;	/* optional element of XSD type wsnt:FilterType */
	char *InitialTerminationTime;	/* optional element of XSD type wsnt:AbsoluteOrRelativeTimeType */
	_tev__CreatePullPointSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of XSD type tev:CreatePullPointSubscription-SubscriptionPolicy */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscription (1014)
	virtual int soap_type(void) const { return 1014; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscription, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscription *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscription); }
	         _tev__CreatePullPointSubscription() { _tev__CreatePullPointSubscription::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscription() { }
	friend SOAP_FMAC1 _tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3009 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (1015)
/* tev:CreatePullPointSubscriptionResponse complex type: */
class SOAP_CMAC _tev__CreatePullPointSubscriptionResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type wsa5:EndpointReferenceType */
	time_t wsnt__CurrentTime;	/* required element of XSD type xsd:dateTime */
	time_t wsnt__TerminationTime;	/* required element of XSD type xsd:dateTime */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (1015)
	virtual int soap_type(void) const { return 1015; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__CreatePullPointSubscriptionResponse, default initialized and not managed by a soap context
	virtual _tev__CreatePullPointSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_tev__CreatePullPointSubscriptionResponse); }
	         _tev__CreatePullPointSubscriptionResponse() { _tev__CreatePullPointSubscriptionResponse::soap_default(NULL); }
	virtual ~_tev__CreatePullPointSubscriptionResponse() { }
	friend SOAP_FMAC1 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3012 */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (1016)
/* tev:PullMessages complex type: */
class SOAP_CMAC _tev__PullMessages
{
public:
	LONG64 Timeout;	/* external (custom serializer) */
	int MessageLimit;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessages (1016)
	virtual int soap_type(void) const { return 1016; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessages, default initialized and not managed by a soap context
	virtual _tev__PullMessages *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessages); }
	         _tev__PullMessages() { _tev__PullMessages::soap_default(NULL); }
	virtual ~_tev__PullMessages() { }
	friend SOAP_FMAC1 _tev__PullMessages * SOAP_FMAC2 soap_instantiate__tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3015 */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (1017)
/* tev:PullMessagesResponse complex type: */
class SOAP_CMAC _tev__PullMessagesResponse
{
public:
	time_t CurrentTime;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	time_t TerminationTime;	/* required element of XSD type xsd:dateTime */
	int __sizeNotificationMessage;	/* sequence of elements <wsnt:NotificationMessage> of XSD type wsnt:NotificationMessageHolderType */
	wsnt__NotificationMessageHolderType **wsnt__NotificationMessage;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessagesResponse (1017)
	virtual int soap_type(void) const { return 1017; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessagesResponse, default initialized and not managed by a soap context
	virtual _tev__PullMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessagesResponse); }
	         _tev__PullMessagesResponse() { _tev__PullMessagesResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesResponse() { }
	friend SOAP_FMAC1 _tev__PullMessagesResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3018 */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (1018)
/* tev:PullMessagesFaultResponse complex type: */
class SOAP_CMAC _tev__PullMessagesFaultResponse
{
public:
	LONG64 MaxTimeout;	/* external (custom serializer) */
	int MaxMessageLimit;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__PullMessagesFaultResponse (1018)
	virtual int soap_type(void) const { return 1018; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__PullMessagesFaultResponse, default initialized and not managed by a soap context
	virtual _tev__PullMessagesFaultResponse *soap_alloc(void) const { return SOAP_NEW(_tev__PullMessagesFaultResponse); }
	         _tev__PullMessagesFaultResponse() { _tev__PullMessagesFaultResponse::soap_default(NULL); }
	virtual ~_tev__PullMessagesFaultResponse() { }
	friend SOAP_FMAC1 _tev__PullMessagesFaultResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesFaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3021 */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (1019)
/* tev:Seek complex type: */
class SOAP_CMAC _tev__Seek
{
public:
	time_t UtcTime;	/* required element of XSD type xsd:dateTime */
	bool *Reverse;	/* optional element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__Seek (1019)
	virtual int soap_type(void) const { return 1019; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__Seek, default initialized and not managed by a soap context
	virtual _tev__Seek *soap_alloc(void) const { return SOAP_NEW(_tev__Seek); }
	         _tev__Seek() { _tev__Seek::soap_default(NULL); }
	virtual ~_tev__Seek() { }
	friend SOAP_FMAC1 _tev__Seek * SOAP_FMAC2 soap_instantiate__tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3024 */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (1020)
/* tev:SeekResponse complex type: */
class SOAP_CMAC _tev__SeekResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SeekResponse (1020)
	virtual int soap_type(void) const { return 1020; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SeekResponse, default initialized and not managed by a soap context
	virtual _tev__SeekResponse *soap_alloc(void) const { return SOAP_NEW(_tev__SeekResponse); }
	         _tev__SeekResponse() { _tev__SeekResponse::soap_default(NULL); }
	virtual ~_tev__SeekResponse() { }
	friend SOAP_FMAC1 _tev__SeekResponse * SOAP_FMAC2 soap_instantiate__tev__SeekResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3027 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (1021)
/* tev:SetSynchronizationPoint complex type: */
class SOAP_CMAC _tev__SetSynchronizationPoint
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SetSynchronizationPoint (1021)
	virtual int soap_type(void) const { return 1021; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SetSynchronizationPoint, default initialized and not managed by a soap context
	virtual _tev__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW(_tev__SetSynchronizationPoint); }
	         _tev__SetSynchronizationPoint() { _tev__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPoint() { }
	friend SOAP_FMAC1 _tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3030 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (1022)
/* tev:SetSynchronizationPointResponse complex type: */
class SOAP_CMAC _tev__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__SetSynchronizationPointResponse (1022)
	virtual int soap_type(void) const { return 1022; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__SetSynchronizationPointResponse, default initialized and not managed by a soap context
	virtual _tev__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW(_tev__SetSynchronizationPointResponse); }
	         _tev__SetSynchronizationPointResponse() { _tev__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_tev__SetSynchronizationPointResponse() { }
	friend SOAP_FMAC1 _tev__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3033 */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (1023)
/* tev:GetEventProperties complex type: */
class SOAP_CMAC _tev__GetEventProperties
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetEventProperties (1023)
	virtual int soap_type(void) const { return 1023; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetEventProperties, default initialized and not managed by a soap context
	virtual _tev__GetEventProperties *soap_alloc(void) const { return SOAP_NEW(_tev__GetEventProperties); }
	         _tev__GetEventProperties() { _tev__GetEventProperties::soap_default(NULL); }
	virtual ~_tev__GetEventProperties() { }
	friend SOAP_FMAC1 _tev__GetEventProperties * SOAP_FMAC2 soap_instantiate__tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3036 */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (1024)
/* tev:GetEventPropertiesResponse complex type: */
class SOAP_CMAC _tev__GetEventPropertiesResponse
{
public:
	int __sizeTopicNamespaceLocation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <TopicNamespaceLocation> of XSD type xsd:anyURI */
	char **TopicNamespaceLocation;
	bool wsnt__FixedTopicSet;	/* optional element of XSD type xsd:boolean */
	wstop__TopicSetType *wstop__TopicSet;	/* required element of XSD type wstop:TopicSetType */
	int __sizeTopicExpressionDialect;	/* sequence of elements <wsnt:TopicExpressionDialect> of XSD type xsd:anyURI */
	char **wsnt__TopicExpressionDialect;
	int __sizeMessageContentFilterDialect;	/* sequence of elements <MessageContentFilterDialect> of XSD type xsd:anyURI */
	char **MessageContentFilterDialect;
	int __sizeProducerPropertiesFilterDialect;	/* sequence of elements <ProducerPropertiesFilterDialect> of XSD type xsd:anyURI */
	char **ProducerPropertiesFilterDialect;
	int __sizeMessageContentSchemaLocation;	/* sequence of elements <MessageContentSchemaLocation> of XSD type xsd:anyURI */
	char **MessageContentSchemaLocation;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tev__GetEventPropertiesResponse (1024)
	virtual int soap_type(void) const { return 1024; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tev__GetEventPropertiesResponse, default initialized and not managed by a soap context
	virtual _tev__GetEventPropertiesResponse *soap_alloc(void) const { return SOAP_NEW(_tev__GetEventPropertiesResponse); }
	         _tev__GetEventPropertiesResponse() { _tev__GetEventPropertiesResponse::soap_default(NULL); }
	virtual ~_tev__GetEventPropertiesResponse() { }
	friend SOAP_FMAC1 _tev__GetEventPropertiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventPropertiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3045 */
#ifndef SOAP_TYPE_tls__Capabilities
#define SOAP_TYPE_tls__Capabilities (1027)
/* Type tls__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tls:Capabilities complex type: */
class SOAP_CMAC tls__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *FixedLayout;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tls__Capabilities (1027)
	virtual int soap_type(void) const { return 1027; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tls__Capabilities, default initialized and not managed by a soap context
	virtual tls__Capabilities *soap_alloc(void) const { return SOAP_NEW(tls__Capabilities); }
	         tls__Capabilities() { tls__Capabilities::soap_default(NULL); }
	virtual ~tls__Capabilities() { }
	friend SOAP_FMAC1 tls__Capabilities * SOAP_FMAC2 soap_instantiate_tls__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3048 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilities
#define SOAP_TYPE__tls__GetServiceCapabilities (1028)
/* tls:GetServiceCapabilities complex type: */
class SOAP_CMAC _tls__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilities (1028)
	virtual int soap_type(void) const { return 1028; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilities); }
	         _tls__GetServiceCapabilities() { _tls__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tls__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3051 */
#ifndef SOAP_TYPE__tls__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tls__GetServiceCapabilitiesResponse (1029)
/* tls:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tls__GetServiceCapabilitiesResponse
{
public:
	tls__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tls:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetServiceCapabilitiesResponse (1029)
	virtual int soap_type(void) const { return 1029; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tls__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetServiceCapabilitiesResponse); }
	         _tls__GetServiceCapabilitiesResponse() { _tls__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tls__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tls__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tls__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3054 */
#ifndef SOAP_TYPE__tls__GetLayout
#define SOAP_TYPE__tls__GetLayout (1030)
/* tls:GetLayout complex type: */
class SOAP_CMAC _tls__GetLayout
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayout (1030)
	virtual int soap_type(void) const { return 1030; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayout, default initialized and not managed by a soap context
	virtual _tls__GetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayout); }
	         _tls__GetLayout() { _tls__GetLayout::soap_default(NULL); }
	virtual ~_tls__GetLayout() { }
	friend SOAP_FMAC1 _tls__GetLayout * SOAP_FMAC2 soap_instantiate__tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3057 */
#ifndef SOAP_TYPE__tls__GetLayoutResponse
#define SOAP_TYPE__tls__GetLayoutResponse (1031)
/* tls:GetLayoutResponse complex type: */
class SOAP_CMAC _tls__GetLayoutResponse
{
public:
	tt__Layout *Layout;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Layout */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetLayoutResponse (1031)
	virtual int soap_type(void) const { return 1031; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__GetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetLayoutResponse); }
	         _tls__GetLayoutResponse() { _tls__GetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__GetLayoutResponse() { }
	friend SOAP_FMAC1 _tls__GetLayoutResponse * SOAP_FMAC2 soap_instantiate__tls__GetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3060 */
#ifndef SOAP_TYPE__tls__SetLayout
#define SOAP_TYPE__tls__SetLayout (1032)
/* tls:SetLayout complex type: */
class SOAP_CMAC _tls__SetLayout
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayout (1032)
	virtual int soap_type(void) const { return 1032; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayout, default initialized and not managed by a soap context
	virtual _tls__SetLayout *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayout); }
	         _tls__SetLayout() { _tls__SetLayout::soap_default(NULL); }
	virtual ~_tls__SetLayout() { }
	friend SOAP_FMAC1 _tls__SetLayout * SOAP_FMAC2 soap_instantiate__tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3063 */
#ifndef SOAP_TYPE__tls__SetLayoutResponse
#define SOAP_TYPE__tls__SetLayoutResponse (1033)
/* tls:SetLayoutResponse complex type: */
class SOAP_CMAC _tls__SetLayoutResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetLayoutResponse (1033)
	virtual int soap_type(void) const { return 1033; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetLayoutResponse, default initialized and not managed by a soap context
	virtual _tls__SetLayoutResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetLayoutResponse); }
	         _tls__SetLayoutResponse() { _tls__SetLayoutResponse::soap_default(NULL); }
	virtual ~_tls__SetLayoutResponse() { }
	friend SOAP_FMAC1 _tls__SetLayoutResponse * SOAP_FMAC2 soap_instantiate__tls__SetLayoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3066 */
#ifndef SOAP_TYPE__tls__GetDisplayOptions
#define SOAP_TYPE__tls__GetDisplayOptions (1034)
/* tls:GetDisplayOptions complex type: */
class SOAP_CMAC _tls__GetDisplayOptions
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptions (1034)
	virtual int soap_type(void) const { return 1034; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptions, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptions *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptions); }
	         _tls__GetDisplayOptions() { _tls__GetDisplayOptions::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptions() { }
	friend SOAP_FMAC1 _tls__GetDisplayOptions * SOAP_FMAC2 soap_instantiate__tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3069 */
#ifndef SOAP_TYPE__tls__GetDisplayOptionsResponse
#define SOAP_TYPE__tls__GetDisplayOptionsResponse (1035)
/* tls:GetDisplayOptionsResponse complex type: */
class SOAP_CMAC _tls__GetDisplayOptionsResponse
{
public:
	tt__LayoutOptions *LayoutOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type tt:LayoutOptions */
	tt__CodingCapabilities *CodingCapabilities;	/* required element of XSD type tt:CodingCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetDisplayOptionsResponse (1035)
	virtual int soap_type(void) const { return 1035; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetDisplayOptionsResponse, default initialized and not managed by a soap context
	virtual _tls__GetDisplayOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetDisplayOptionsResponse); }
	         _tls__GetDisplayOptionsResponse() { _tls__GetDisplayOptionsResponse::soap_default(NULL); }
	virtual ~_tls__GetDisplayOptionsResponse() { }
	friend SOAP_FMAC1 _tls__GetDisplayOptionsResponse * SOAP_FMAC2 soap_instantiate__tls__GetDisplayOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3072 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurations
#define SOAP_TYPE__tls__GetPaneConfigurations (1036)
/* tls:GetPaneConfigurations complex type: */
class SOAP_CMAC _tls__GetPaneConfigurations
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurations (1036)
	virtual int soap_type(void) const { return 1036; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurations); }
	         _tls__GetPaneConfigurations() { _tls__GetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurations() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3075 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationsResponse
#define SOAP_TYPE__tls__GetPaneConfigurationsResponse (1037)
/* tls:GetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationsResponse
{
public:
	int __sizePaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PaneConfiguration> of XSD type tt:PaneConfiguration */
	tt__PaneConfiguration **PaneConfiguration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationsResponse (1037)
	virtual int soap_type(void) const { return 1037; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationsResponse); }
	         _tls__GetPaneConfigurationsResponse() { _tls__GetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationsResponse() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3078 */
#ifndef SOAP_TYPE__tls__GetPaneConfiguration
#define SOAP_TYPE__tls__GetPaneConfiguration (1038)
/* tls:GetPaneConfiguration complex type: */
class SOAP_CMAC _tls__GetPaneConfiguration
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	char *Pane;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfiguration (1038)
	virtual int soap_type(void) const { return 1038; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfiguration); }
	         _tls__GetPaneConfiguration() { _tls__GetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__GetPaneConfiguration() { }
	friend SOAP_FMAC1 _tls__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3081 */
#ifndef SOAP_TYPE__tls__GetPaneConfigurationResponse
#define SOAP_TYPE__tls__GetPaneConfigurationResponse (1039)
/* tls:GetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__GetPaneConfigurationResponse
{
public:
	tt__PaneConfiguration *PaneConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PaneConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__GetPaneConfigurationResponse (1039)
	virtual int soap_type(void) const { return 1039; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__GetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__GetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__GetPaneConfigurationResponse); }
	         _tls__GetPaneConfigurationResponse() { _tls__GetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__GetPaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__GetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__GetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3084 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurations
#define SOAP_TYPE__tls__SetPaneConfigurations (1040)
/* tls:SetPaneConfigurations complex type: */
class SOAP_CMAC _tls__SetPaneConfigurations
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	int __sizePaneConfiguration;	/* sequence of elements <PaneConfiguration> of XSD type tt:PaneConfiguration */
	tt__PaneConfiguration **PaneConfiguration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurations (1040)
	virtual int soap_type(void) const { return 1040; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurations, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurations *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurations); }
	         _tls__SetPaneConfigurations() { _tls__SetPaneConfigurations::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurations() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3087 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationsResponse
#define SOAP_TYPE__tls__SetPaneConfigurationsResponse (1041)
/* tls:SetPaneConfigurationsResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationsResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationsResponse (1041)
	virtual int soap_type(void) const { return 1041; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationsResponse); }
	         _tls__SetPaneConfigurationsResponse() { _tls__SetPaneConfigurationsResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationsResponse() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3090 */
#ifndef SOAP_TYPE__tls__SetPaneConfiguration
#define SOAP_TYPE__tls__SetPaneConfiguration (1042)
/* tls:SetPaneConfiguration complex type: */
class SOAP_CMAC _tls__SetPaneConfiguration
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfiguration (1042)
	virtual int soap_type(void) const { return 1042; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfiguration); }
	         _tls__SetPaneConfiguration() { _tls__SetPaneConfiguration::soap_default(NULL); }
	virtual ~_tls__SetPaneConfiguration() { }
	friend SOAP_FMAC1 _tls__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3093 */
#ifndef SOAP_TYPE__tls__SetPaneConfigurationResponse
#define SOAP_TYPE__tls__SetPaneConfigurationResponse (1043)
/* tls:SetPaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__SetPaneConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__SetPaneConfigurationResponse (1043)
	virtual int soap_type(void) const { return 1043; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__SetPaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__SetPaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__SetPaneConfigurationResponse); }
	         _tls__SetPaneConfigurationResponse() { _tls__SetPaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__SetPaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__SetPaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__SetPaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3096 */
#ifndef SOAP_TYPE__tls__CreatePaneConfiguration
#define SOAP_TYPE__tls__CreatePaneConfiguration (1044)
/* tls:CreatePaneConfiguration complex type: */
class SOAP_CMAC _tls__CreatePaneConfiguration
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	tt__PaneConfiguration *PaneConfiguration;	/* required element of XSD type tt:PaneConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfiguration (1044)
	virtual int soap_type(void) const { return 1044; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfiguration); }
	         _tls__CreatePaneConfiguration() { _tls__CreatePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfiguration() { }
	friend SOAP_FMAC1 _tls__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3099 */
#ifndef SOAP_TYPE__tls__CreatePaneConfigurationResponse
#define SOAP_TYPE__tls__CreatePaneConfigurationResponse (1045)
/* tls:CreatePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__CreatePaneConfigurationResponse
{
public:
	char *PaneToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__CreatePaneConfigurationResponse (1045)
	virtual int soap_type(void) const { return 1045; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__CreatePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__CreatePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__CreatePaneConfigurationResponse); }
	         _tls__CreatePaneConfigurationResponse() { _tls__CreatePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__CreatePaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__CreatePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__CreatePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3102 */
#ifndef SOAP_TYPE__tls__DeletePaneConfiguration
#define SOAP_TYPE__tls__DeletePaneConfiguration (1046)
/* tls:DeletePaneConfiguration complex type: */
class SOAP_CMAC _tls__DeletePaneConfiguration
{
public:
	char *VideoOutput;	/* required element of XSD type tt:ReferenceToken */
	char *PaneToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfiguration (1046)
	virtual int soap_type(void) const { return 1046; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfiguration, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfiguration *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfiguration); }
	         _tls__DeletePaneConfiguration() { _tls__DeletePaneConfiguration::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfiguration() { }
	friend SOAP_FMAC1 _tls__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate__tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3105 */
#ifndef SOAP_TYPE__tls__DeletePaneConfigurationResponse
#define SOAP_TYPE__tls__DeletePaneConfigurationResponse (1047)
/* tls:DeletePaneConfigurationResponse complex type: */
class SOAP_CMAC _tls__DeletePaneConfigurationResponse
{
public:
	int __size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tls__DeletePaneConfigurationResponse (1047)
	virtual int soap_type(void) const { return 1047; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tls__DeletePaneConfigurationResponse, default initialized and not managed by a soap context
	virtual _tls__DeletePaneConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tls__DeletePaneConfigurationResponse); }
	         _tls__DeletePaneConfigurationResponse() { _tls__DeletePaneConfigurationResponse::soap_default(NULL); }
	virtual ~_tls__DeletePaneConfigurationResponse() { }
	friend SOAP_FMAC1 _tls__DeletePaneConfigurationResponse * SOAP_FMAC2 soap_instantiate__tls__DeletePaneConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3108 */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (1048)
/* Type timg__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* timg:Capabilities complex type: */
class SOAP_CMAC timg__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *ImageStabilization;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_timg__Capabilities (1048)
	virtual int soap_type(void) const { return 1048; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type timg__Capabilities, default initialized and not managed by a soap context
	virtual timg__Capabilities *soap_alloc(void) const { return SOAP_NEW(timg__Capabilities); }
	         timg__Capabilities() { timg__Capabilities::soap_default(NULL); }
	virtual ~timg__Capabilities() { }
	friend SOAP_FMAC1 timg__Capabilities * SOAP_FMAC2 soap_instantiate_timg__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3111 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (1049)
/* timg:GetServiceCapabilities complex type: */
class SOAP_CMAC _timg__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetServiceCapabilities (1049)
	virtual int soap_type(void) const { return 1049; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _timg__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_timg__GetServiceCapabilities); }
	         _timg__GetServiceCapabilities() { _timg__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_timg__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3114 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (1050)
/* timg:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _timg__GetServiceCapabilitiesResponse
{
public:
	timg__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type timg:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetServiceCapabilitiesResponse (1050)
	virtual int soap_type(void) const { return 1050; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _timg__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetServiceCapabilitiesResponse); }
	         _timg__GetServiceCapabilitiesResponse() { _timg__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_timg__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__timg__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3117 */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (1051)
/* timg:GetImagingSettings complex type: */
class SOAP_CMAC _timg__GetImagingSettings
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetImagingSettings (1051)
	virtual int soap_type(void) const { return 1051; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetImagingSettings, default initialized and not managed by a soap context
	virtual _timg__GetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_timg__GetImagingSettings); }
	         _timg__GetImagingSettings() { _timg__GetImagingSettings::soap_default(NULL); }
	virtual ~_timg__GetImagingSettings() { }
	friend SOAP_FMAC1 _timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate__timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3120 */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (1052)
/* timg:GetImagingSettingsResponse complex type: */
class SOAP_CMAC _timg__GetImagingSettingsResponse
{
public:
	tt__ImagingSettings20 *ImagingSettings;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingSettings20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetImagingSettingsResponse (1052)
	virtual int soap_type(void) const { return 1052; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetImagingSettingsResponse, default initialized and not managed by a soap context
	virtual _timg__GetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetImagingSettingsResponse); }
	         _timg__GetImagingSettingsResponse() { _timg__GetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__GetImagingSettingsResponse() { }
	friend SOAP_FMAC1 _timg__GetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__timg__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3123 */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (1053)
/* timg:SetImagingSettings complex type: */
class SOAP_CMAC _timg__SetImagingSettings
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__ImagingSettings20 *ImagingSettings;	/* required element of XSD type tt:ImagingSettings20 */
	bool *ForcePersistence;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__SetImagingSettings (1053)
	virtual int soap_type(void) const { return 1053; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__SetImagingSettings, default initialized and not managed by a soap context
	virtual _timg__SetImagingSettings *soap_alloc(void) const { return SOAP_NEW(_timg__SetImagingSettings); }
	         _timg__SetImagingSettings() { _timg__SetImagingSettings::soap_default(NULL); }
	virtual ~_timg__SetImagingSettings() { }
	friend SOAP_FMAC1 _timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate__timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3126 */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (1054)
/* timg:SetImagingSettingsResponse complex type: */
class SOAP_CMAC _timg__SetImagingSettingsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__SetImagingSettingsResponse (1054)
	virtual int soap_type(void) const { return 1054; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__SetImagingSettingsResponse, default initialized and not managed by a soap context
	virtual _timg__SetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__SetImagingSettingsResponse); }
	         _timg__SetImagingSettingsResponse() { _timg__SetImagingSettingsResponse::soap_default(NULL); }
	virtual ~_timg__SetImagingSettingsResponse() { }
	friend SOAP_FMAC1 _timg__SetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__timg__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3129 */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (1055)
/* timg:GetOptions complex type: */
class SOAP_CMAC _timg__GetOptions
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetOptions (1055)
	virtual int soap_type(void) const { return 1055; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetOptions, default initialized and not managed by a soap context
	virtual _timg__GetOptions *soap_alloc(void) const { return SOAP_NEW(_timg__GetOptions); }
	         _timg__GetOptions() { _timg__GetOptions::soap_default(NULL); }
	virtual ~_timg__GetOptions() { }
	friend SOAP_FMAC1 _timg__GetOptions * SOAP_FMAC2 soap_instantiate__timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3132 */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (1056)
/* timg:GetOptionsResponse complex type: */
class SOAP_CMAC _timg__GetOptionsResponse
{
public:
	tt__ImagingOptions20 *ImagingOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingOptions20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetOptionsResponse (1056)
	virtual int soap_type(void) const { return 1056; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetOptionsResponse, default initialized and not managed by a soap context
	virtual _timg__GetOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetOptionsResponse); }
	         _timg__GetOptionsResponse() { _timg__GetOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetOptionsResponse() { }
	friend SOAP_FMAC1 _timg__GetOptionsResponse * SOAP_FMAC2 soap_instantiate__timg__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3135 */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (1057)
/* timg:Move complex type: */
class SOAP_CMAC _timg__Move
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__FocusMove *Focus;	/* required element of XSD type tt:FocusMove */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__Move (1057)
	virtual int soap_type(void) const { return 1057; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__Move, default initialized and not managed by a soap context
	virtual _timg__Move *soap_alloc(void) const { return SOAP_NEW(_timg__Move); }
	         _timg__Move() { _timg__Move::soap_default(NULL); }
	virtual ~_timg__Move() { }
	friend SOAP_FMAC1 _timg__Move * SOAP_FMAC2 soap_instantiate__timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3138 */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (1058)
/* timg:MoveResponse complex type: */
class SOAP_CMAC _timg__MoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__MoveResponse (1058)
	virtual int soap_type(void) const { return 1058; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__MoveResponse, default initialized and not managed by a soap context
	virtual _timg__MoveResponse *soap_alloc(void) const { return SOAP_NEW(_timg__MoveResponse); }
	         _timg__MoveResponse() { _timg__MoveResponse::soap_default(NULL); }
	virtual ~_timg__MoveResponse() { }
	friend SOAP_FMAC1 _timg__MoveResponse * SOAP_FMAC2 soap_instantiate__timg__MoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3141 */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (1059)
/* timg:GetMoveOptions complex type: */
class SOAP_CMAC _timg__GetMoveOptions
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetMoveOptions (1059)
	virtual int soap_type(void) const { return 1059; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetMoveOptions, default initialized and not managed by a soap context
	virtual _timg__GetMoveOptions *soap_alloc(void) const { return SOAP_NEW(_timg__GetMoveOptions); }
	         _timg__GetMoveOptions() { _timg__GetMoveOptions::soap_default(NULL); }
	virtual ~_timg__GetMoveOptions() { }
	friend SOAP_FMAC1 _timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate__timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3144 */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (1060)
/* timg:GetMoveOptionsResponse complex type: */
class SOAP_CMAC _timg__GetMoveOptionsResponse
{
public:
	tt__MoveOptions20 *MoveOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:MoveOptions20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetMoveOptionsResponse (1060)
	virtual int soap_type(void) const { return 1060; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetMoveOptionsResponse, default initialized and not managed by a soap context
	virtual _timg__GetMoveOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetMoveOptionsResponse); }
	         _timg__GetMoveOptionsResponse() { _timg__GetMoveOptionsResponse::soap_default(NULL); }
	virtual ~_timg__GetMoveOptionsResponse() { }
	friend SOAP_FMAC1 _timg__GetMoveOptionsResponse * SOAP_FMAC2 soap_instantiate__timg__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3147 */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (1061)
/* timg:Stop complex type: */
class SOAP_CMAC _timg__Stop
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__Stop (1061)
	virtual int soap_type(void) const { return 1061; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__Stop, default initialized and not managed by a soap context
	virtual _timg__Stop *soap_alloc(void) const { return SOAP_NEW(_timg__Stop); }
	         _timg__Stop() { _timg__Stop::soap_default(NULL); }
	virtual ~_timg__Stop() { }
	friend SOAP_FMAC1 _timg__Stop * SOAP_FMAC2 soap_instantiate__timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3150 */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (1062)
/* timg:StopResponse complex type: */
class SOAP_CMAC _timg__StopResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__StopResponse (1062)
	virtual int soap_type(void) const { return 1062; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__StopResponse, default initialized and not managed by a soap context
	virtual _timg__StopResponse *soap_alloc(void) const { return SOAP_NEW(_timg__StopResponse); }
	         _timg__StopResponse() { _timg__StopResponse::soap_default(NULL); }
	virtual ~_timg__StopResponse() { }
	friend SOAP_FMAC1 _timg__StopResponse * SOAP_FMAC2 soap_instantiate__timg__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3153 */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (1063)
/* timg:GetStatus complex type: */
class SOAP_CMAC _timg__GetStatus
{
public:
	char *VideoSourceToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetStatus (1063)
	virtual int soap_type(void) const { return 1063; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetStatus, default initialized and not managed by a soap context
	virtual _timg__GetStatus *soap_alloc(void) const { return SOAP_NEW(_timg__GetStatus); }
	         _timg__GetStatus() { _timg__GetStatus::soap_default(NULL); }
	virtual ~_timg__GetStatus() { }
	friend SOAP_FMAC1 _timg__GetStatus * SOAP_FMAC2 soap_instantiate__timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3156 */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (1064)
/* timg:GetStatusResponse complex type: */
class SOAP_CMAC _timg__GetStatusResponse
{
public:
	tt__ImagingStatus20 *Status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ImagingStatus20 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__timg__GetStatusResponse (1064)
	virtual int soap_type(void) const { return 1064; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _timg__GetStatusResponse, default initialized and not managed by a soap context
	virtual _timg__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_timg__GetStatusResponse); }
	         _timg__GetStatusResponse() { _timg__GetStatusResponse::soap_default(NULL); }
	virtual ~_timg__GetStatusResponse() { }
	friend SOAP_FMAC1 _timg__GetStatusResponse * SOAP_FMAC2 soap_instantiate__timg__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3159 */
#ifndef SOAP_TYPE_tptz__Capabilities
#define SOAP_TYPE_tptz__Capabilities (1065)
/* Type tptz__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tptz:Capabilities complex type: */
class SOAP_CMAC tptz__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *EFlip;	/* optional attribute of XSD type xsd:boolean */
	bool *Reverse;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tptz__Capabilities (1065)
	virtual int soap_type(void) const { return 1065; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tptz__Capabilities, default initialized and not managed by a soap context
	virtual tptz__Capabilities *soap_alloc(void) const { return SOAP_NEW(tptz__Capabilities); }
	         tptz__Capabilities() { tptz__Capabilities::soap_default(NULL); }
	virtual ~tptz__Capabilities() { }
	friend SOAP_FMAC1 tptz__Capabilities * SOAP_FMAC2 soap_instantiate_tptz__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3162 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilities
#define SOAP_TYPE__tptz__GetServiceCapabilities (1066)
/* tptz:GetServiceCapabilities complex type: */
class SOAP_CMAC _tptz__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetServiceCapabilities (1066)
	virtual int soap_type(void) const { return 1066; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tptz__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tptz__GetServiceCapabilities); }
	         _tptz__GetServiceCapabilities() { _tptz__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3165 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (1067)
/* tptz:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tptz__GetServiceCapabilitiesResponse
{
public:
	tptz__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tptz:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (1067)
	virtual int soap_type(void) const { return 1067; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tptz__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetServiceCapabilitiesResponse); }
	         _tptz__GetServiceCapabilitiesResponse() { _tptz__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3168 */
#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (1068)
/* tptz:GetNodes complex type: */
class SOAP_CMAC _tptz__GetNodes
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodes (1068)
	virtual int soap_type(void) const { return 1068; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodes, default initialized and not managed by a soap context
	virtual _tptz__GetNodes *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodes); }
	         _tptz__GetNodes() { _tptz__GetNodes::soap_default(NULL); }
	virtual ~_tptz__GetNodes() { }
	friend SOAP_FMAC1 _tptz__GetNodes * SOAP_FMAC2 soap_instantiate__tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3171 */
#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (1069)
/* tptz:GetNodesResponse complex type: */
class SOAP_CMAC _tptz__GetNodesResponse
{
public:
	int __sizePTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PTZNode> of XSD type tt:PTZNode */
	tt__PTZNode **PTZNode;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodesResponse (1069)
	virtual int soap_type(void) const { return 1069; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodesResponse, default initialized and not managed by a soap context
	virtual _tptz__GetNodesResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodesResponse); }
	         _tptz__GetNodesResponse() { _tptz__GetNodesResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodesResponse() { }
	friend SOAP_FMAC1 _tptz__GetNodesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3174 */
#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (1070)
/* tptz:GetNode complex type: */
class SOAP_CMAC _tptz__GetNode
{
public:
	char *NodeToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNode (1070)
	virtual int soap_type(void) const { return 1070; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNode, default initialized and not managed by a soap context
	virtual _tptz__GetNode *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNode); }
	         _tptz__GetNode() { _tptz__GetNode::soap_default(NULL); }
	virtual ~_tptz__GetNode() { }
	friend SOAP_FMAC1 _tptz__GetNode * SOAP_FMAC2 soap_instantiate__tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3177 */
#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (1071)
/* tptz:GetNodeResponse complex type: */
class SOAP_CMAC _tptz__GetNodeResponse
{
public:
	tt__PTZNode *PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZNode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetNodeResponse (1071)
	virtual int soap_type(void) const { return 1071; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetNodeResponse, default initialized and not managed by a soap context
	virtual _tptz__GetNodeResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetNodeResponse); }
	         _tptz__GetNodeResponse() { _tptz__GetNodeResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodeResponse() { }
	friend SOAP_FMAC1 _tptz__GetNodeResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3180 */
#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (1072)
/* tptz:GetConfigurations complex type: */
class SOAP_CMAC _tptz__GetConfigurations
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurations (1072)
	virtual int soap_type(void) const { return 1072; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurations, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurations *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurations); }
	         _tptz__GetConfigurations() { _tptz__GetConfigurations::soap_default(NULL); }
	virtual ~_tptz__GetConfigurations() { }
	friend SOAP_FMAC1 _tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3183 */
#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (1073)
/* tptz:GetConfigurationsResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationsResponse
{
public:
	int __sizePTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PTZConfiguration> of XSD type tt:PTZConfiguration */
	tt__PTZConfiguration **PTZConfiguration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationsResponse (1073)
	virtual int soap_type(void) const { return 1073; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationsResponse); }
	         _tptz__GetConfigurationsResponse() { _tptz__GetConfigurationsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationsResponse() { }
	friend SOAP_FMAC1 _tptz__GetConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3186 */
#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (1074)
/* tptz:GetConfiguration complex type: */
class SOAP_CMAC _tptz__GetConfiguration
{
public:
	char *PTZConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfiguration (1074)
	virtual int soap_type(void) const { return 1074; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfiguration, default initialized and not managed by a soap context
	virtual _tptz__GetConfiguration *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfiguration); }
	         _tptz__GetConfiguration() { _tptz__GetConfiguration::soap_default(NULL); }
	virtual ~_tptz__GetConfiguration() { }
	friend SOAP_FMAC1 _tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3189 */
#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (1075)
/* tptz:GetConfigurationResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationResponse
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationResponse (1075)
	virtual int soap_type(void) const { return 1075; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationResponse); }
	         _tptz__GetConfigurationResponse() { _tptz__GetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationResponse() { }
	friend SOAP_FMAC1 _tptz__GetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3192 */
#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (1076)
/* tptz:SetConfiguration complex type: */
class SOAP_CMAC _tptz__SetConfiguration
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* required element of XSD type tt:PTZConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetConfiguration (1076)
	virtual int soap_type(void) const { return 1076; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetConfiguration, default initialized and not managed by a soap context
	virtual _tptz__SetConfiguration *soap_alloc(void) const { return SOAP_NEW(_tptz__SetConfiguration); }
	         _tptz__SetConfiguration() { _tptz__SetConfiguration::soap_default(NULL); }
	virtual ~_tptz__SetConfiguration() { }
	friend SOAP_FMAC1 _tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:32698 */
#ifndef SOAP_TYPE___tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE___tptz__SetConfigurationResponse_sequence (2153)
/* Operation wrapper: */
class SOAP_CMAC __tptz__SetConfigurationResponse_sequence
{
public:
	/// Return the unique type ID value SOAP_TYPE___tptz__SetConfigurationResponse_sequence (2153)
	virtual int soap_type(void) const { return 2153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __tptz__SetConfigurationResponse_sequence, default initialized and not managed by a soap context
	virtual __tptz__SetConfigurationResponse_sequence *soap_alloc(void) const { return SOAP_NEW(__tptz__SetConfigurationResponse_sequence); }
	         __tptz__SetConfigurationResponse_sequence() { __tptz__SetConfigurationResponse_sequence::soap_default(NULL); }
	virtual ~__tptz__SetConfigurationResponse_sequence() { }
	friend SOAP_FMAC1 __tptz__SetConfigurationResponse_sequence * SOAP_FMAC2 soap_instantiate___tptz__SetConfigurationResponse_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3195 */
#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (1077)
/* tptz:SetConfigurationResponse complex type: */
class SOAP_CMAC _tptz__SetConfigurationResponse
{
public:
	__tptz__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetConfigurationResponse (1077)
	virtual int soap_type(void) const { return 1077; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetConfigurationResponse, default initialized and not managed by a soap context
	virtual _tptz__SetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetConfigurationResponse); }
	         _tptz__SetConfigurationResponse() { _tptz__SetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__SetConfigurationResponse() { }
	friend SOAP_FMAC1 _tptz__SetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__SetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3198 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (1078)
/* tptz:GetConfigurationOptions complex type: */
class SOAP_CMAC _tptz__GetConfigurationOptions
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationOptions (1078)
	virtual int soap_type(void) const { return 1078; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationOptions, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationOptions *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationOptions); }
	         _tptz__GetConfigurationOptions() { _tptz__GetConfigurationOptions::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptions() { }
	friend SOAP_FMAC1 _tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3201 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (1079)
/* tptz:GetConfigurationOptionsResponse complex type: */
class SOAP_CMAC _tptz__GetConfigurationOptionsResponse
{
public:
	tt__PTZConfigurationOptions *PTZConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZConfigurationOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetConfigurationOptionsResponse (1079)
	virtual int soap_type(void) const { return 1079; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetConfigurationOptionsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetConfigurationOptionsResponse); }
	         _tptz__GetConfigurationOptionsResponse() { _tptz__GetConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptionsResponse() { }
	friend SOAP_FMAC1 _tptz__GetConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3204 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (1080)
/* tptz:SendAuxiliaryCommand complex type: */
class SOAP_CMAC _tptz__SendAuxiliaryCommand
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *AuxiliaryData;	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SendAuxiliaryCommand (1080)
	virtual int soap_type(void) const { return 1080; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SendAuxiliaryCommand, default initialized and not managed by a soap context
	virtual _tptz__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW(_tptz__SendAuxiliaryCommand); }
	         _tptz__SendAuxiliaryCommand() { _tptz__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommand() { }
	friend SOAP_FMAC1 _tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3207 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (1081)
/* tptz:SendAuxiliaryCommandResponse complex type: */
class SOAP_CMAC _tptz__SendAuxiliaryCommandResponse
{
public:
	char *AuxiliaryResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AuxiliaryData */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (1081)
	virtual int soap_type(void) const { return 1081; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
	virtual _tptz__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SendAuxiliaryCommandResponse); }
	         _tptz__SendAuxiliaryCommandResponse() { _tptz__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommandResponse() { }
	friend SOAP_FMAC1 _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3210 */
#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (1082)
/* tptz:GetPresets complex type: */
class SOAP_CMAC _tptz__GetPresets
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresets (1082)
	virtual int soap_type(void) const { return 1082; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresets, default initialized and not managed by a soap context
	virtual _tptz__GetPresets *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresets); }
	         _tptz__GetPresets() { _tptz__GetPresets::soap_default(NULL); }
	virtual ~_tptz__GetPresets() { }
	friend SOAP_FMAC1 _tptz__GetPresets * SOAP_FMAC2 soap_instantiate__tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3213 */
#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (1083)
/* tptz:GetPresetsResponse complex type: */
class SOAP_CMAC _tptz__GetPresetsResponse
{
public:
	int __sizePreset;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Preset> of XSD type tt:PTZPreset */
	tt__PTZPreset **Preset;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetsResponse (1083)
	virtual int soap_type(void) const { return 1083; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetsResponse); }
	         _tptz__GetPresetsResponse() { _tptz__GetPresetsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetsResponse() { }
	friend SOAP_FMAC1 _tptz__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3216 */
#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (1084)
/* tptz:SetPreset complex type: */
class SOAP_CMAC _tptz__SetPreset
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetName;	/* optional element of XSD type xsd:string */
	char *PresetToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetPreset (1084)
	virtual int soap_type(void) const { return 1084; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetPreset, default initialized and not managed by a soap context
	virtual _tptz__SetPreset *soap_alloc(void) const { return SOAP_NEW(_tptz__SetPreset); }
	         _tptz__SetPreset() { _tptz__SetPreset::soap_default(NULL); }
	virtual ~_tptz__SetPreset() { }
	friend SOAP_FMAC1 _tptz__SetPreset * SOAP_FMAC2 soap_instantiate__tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3219 */
#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (1085)
/* tptz:SetPresetResponse complex type: */
class SOAP_CMAC _tptz__SetPresetResponse
{
public:
	char *PresetToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetPresetResponse (1085)
	virtual int soap_type(void) const { return 1085; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetPresetResponse, default initialized and not managed by a soap context
	virtual _tptz__SetPresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetPresetResponse); }
	         _tptz__SetPresetResponse() { _tptz__SetPresetResponse::soap_default(NULL); }
	virtual ~_tptz__SetPresetResponse() { }
	friend SOAP_FMAC1 _tptz__SetPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__SetPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3222 */
#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (1086)
/* tptz:RemovePreset complex type: */
class SOAP_CMAC _tptz__RemovePreset
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePreset (1086)
	virtual int soap_type(void) const { return 1086; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePreset, default initialized and not managed by a soap context
	virtual _tptz__RemovePreset *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePreset); }
	         _tptz__RemovePreset() { _tptz__RemovePreset::soap_default(NULL); }
	virtual ~_tptz__RemovePreset() { }
	friend SOAP_FMAC1 _tptz__RemovePreset * SOAP_FMAC2 soap_instantiate__tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3225 */
#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (1087)
/* tptz:RemovePresetResponse complex type: */
class SOAP_CMAC _tptz__RemovePresetResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetResponse (1087)
	virtual int soap_type(void) const { return 1087; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetResponse, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetResponse); }
	         _tptz__RemovePresetResponse() { _tptz__RemovePresetResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetResponse() { }
	friend SOAP_FMAC1 _tptz__RemovePresetResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3228 */
#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (1088)
/* tptz:GotoPreset complex type: */
class SOAP_CMAC _tptz__GotoPreset
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoPreset (1088)
	virtual int soap_type(void) const { return 1088; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoPreset, default initialized and not managed by a soap context
	virtual _tptz__GotoPreset *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoPreset); }
	         _tptz__GotoPreset() { _tptz__GotoPreset::soap_default(NULL); }
	virtual ~_tptz__GotoPreset() { }
	friend SOAP_FMAC1 _tptz__GotoPreset * SOAP_FMAC2 soap_instantiate__tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3231 */
#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (1089)
/* tptz:GotoPresetResponse complex type: */
class SOAP_CMAC _tptz__GotoPresetResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoPresetResponse (1089)
	virtual int soap_type(void) const { return 1089; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoPresetResponse, default initialized and not managed by a soap context
	virtual _tptz__GotoPresetResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoPresetResponse); }
	         _tptz__GotoPresetResponse() { _tptz__GotoPresetResponse::soap_default(NULL); }
	virtual ~_tptz__GotoPresetResponse() { }
	friend SOAP_FMAC1 _tptz__GotoPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3234 */
#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (1090)
/* tptz:GetStatus complex type: */
class SOAP_CMAC _tptz__GetStatus
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetStatus (1090)
	virtual int soap_type(void) const { return 1090; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetStatus, default initialized and not managed by a soap context
	virtual _tptz__GetStatus *soap_alloc(void) const { return SOAP_NEW(_tptz__GetStatus); }
	         _tptz__GetStatus() { _tptz__GetStatus::soap_default(NULL); }
	virtual ~_tptz__GetStatus() { }
	friend SOAP_FMAC1 _tptz__GetStatus * SOAP_FMAC2 soap_instantiate__tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3237 */
#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (1091)
/* tptz:GetStatusResponse complex type: */
class SOAP_CMAC _tptz__GetStatusResponse
{
public:
	tt__PTZStatus *PTZStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZStatus */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetStatusResponse (1091)
	virtual int soap_type(void) const { return 1091; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetStatusResponse, default initialized and not managed by a soap context
	virtual _tptz__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetStatusResponse); }
	         _tptz__GetStatusResponse() { _tptz__GetStatusResponse::soap_default(NULL); }
	virtual ~_tptz__GetStatusResponse() { }
	friend SOAP_FMAC1 _tptz__GetStatusResponse * SOAP_FMAC2 soap_instantiate__tptz__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3240 */
#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (1092)
/* tptz:GotoHomePosition complex type: */
class SOAP_CMAC _tptz__GotoHomePosition
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoHomePosition (1092)
	virtual int soap_type(void) const { return 1092; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoHomePosition, default initialized and not managed by a soap context
	virtual _tptz__GotoHomePosition *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoHomePosition); }
	         _tptz__GotoHomePosition() { _tptz__GotoHomePosition::soap_default(NULL); }
	virtual ~_tptz__GotoHomePosition() { }
	friend SOAP_FMAC1 _tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3243 */
#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (1093)
/* tptz:GotoHomePositionResponse complex type: */
class SOAP_CMAC _tptz__GotoHomePositionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GotoHomePositionResponse (1093)
	virtual int soap_type(void) const { return 1093; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GotoHomePositionResponse, default initialized and not managed by a soap context
	virtual _tptz__GotoHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GotoHomePositionResponse); }
	         _tptz__GotoHomePositionResponse() { _tptz__GotoHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__GotoHomePositionResponse() { }
	friend SOAP_FMAC1 _tptz__GotoHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3246 */
#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (1094)
/* tptz:SetHomePosition complex type: */
class SOAP_CMAC _tptz__SetHomePosition
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetHomePosition (1094)
	virtual int soap_type(void) const { return 1094; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetHomePosition, default initialized and not managed by a soap context
	virtual _tptz__SetHomePosition *soap_alloc(void) const { return SOAP_NEW(_tptz__SetHomePosition); }
	         _tptz__SetHomePosition() { _tptz__SetHomePosition::soap_default(NULL); }
	virtual ~_tptz__SetHomePosition() { }
	friend SOAP_FMAC1 _tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate__tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3249 */
#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (1095)
/* tptz:SetHomePositionResponse complex type: */
class SOAP_CMAC _tptz__SetHomePositionResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__SetHomePositionResponse (1095)
	virtual int soap_type(void) const { return 1095; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__SetHomePositionResponse, default initialized and not managed by a soap context
	virtual _tptz__SetHomePositionResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__SetHomePositionResponse); }
	         _tptz__SetHomePositionResponse() { _tptz__SetHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__SetHomePositionResponse() { }
	friend SOAP_FMAC1 _tptz__SetHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__SetHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3252 */
#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (1096)
/* tptz:ContinuousMove complex type: */
class SOAP_CMAC _tptz__ContinuousMove
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZSpeed *Velocity;	/* required element of XSD type tt:PTZSpeed */
	LONG64 *Timeout;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ContinuousMove (1096)
	virtual int soap_type(void) const { return 1096; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ContinuousMove, default initialized and not managed by a soap context
	virtual _tptz__ContinuousMove *soap_alloc(void) const { return SOAP_NEW(_tptz__ContinuousMove); }
	         _tptz__ContinuousMove() { _tptz__ContinuousMove::soap_default(NULL); }
	virtual ~_tptz__ContinuousMove() { }
	friend SOAP_FMAC1 _tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3255 */
#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (1097)
/* tptz:ContinuousMoveResponse complex type: */
class SOAP_CMAC _tptz__ContinuousMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ContinuousMoveResponse (1097)
	virtual int soap_type(void) const { return 1097; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ContinuousMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__ContinuousMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__ContinuousMoveResponse); }
	         _tptz__ContinuousMoveResponse() { _tptz__ContinuousMoveResponse::soap_default(NULL); }
	virtual ~_tptz__ContinuousMoveResponse() { }
	friend SOAP_FMAC1 _tptz__ContinuousMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3258 */
#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (1098)
/* tptz:RelativeMove complex type: */
class SOAP_CMAC _tptz__RelativeMove
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZVector *Translation;	/* required element of XSD type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RelativeMove (1098)
	virtual int soap_type(void) const { return 1098; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RelativeMove, default initialized and not managed by a soap context
	virtual _tptz__RelativeMove *soap_alloc(void) const { return SOAP_NEW(_tptz__RelativeMove); }
	         _tptz__RelativeMove() { _tptz__RelativeMove::soap_default(NULL); }
	virtual ~_tptz__RelativeMove() { }
	friend SOAP_FMAC1 _tptz__RelativeMove * SOAP_FMAC2 soap_instantiate__tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3261 */
#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (1099)
/* tptz:RelativeMoveResponse complex type: */
class SOAP_CMAC _tptz__RelativeMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RelativeMoveResponse (1099)
	virtual int soap_type(void) const { return 1099; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RelativeMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__RelativeMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RelativeMoveResponse); }
	         _tptz__RelativeMoveResponse() { _tptz__RelativeMoveResponse::soap_default(NULL); }
	virtual ~_tptz__RelativeMoveResponse() { }
	friend SOAP_FMAC1 _tptz__RelativeMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__RelativeMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3264 */
#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (1100)
/* tptz:AbsoluteMove complex type: */
class SOAP_CMAC _tptz__AbsoluteMove
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PTZVector *Position;	/* required element of XSD type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of XSD type tt:PTZSpeed */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__AbsoluteMove (1100)
	virtual int soap_type(void) const { return 1100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__AbsoluteMove, default initialized and not managed by a soap context
	virtual _tptz__AbsoluteMove *soap_alloc(void) const { return SOAP_NEW(_tptz__AbsoluteMove); }
	         _tptz__AbsoluteMove() { _tptz__AbsoluteMove::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMove() { }
	friend SOAP_FMAC1 _tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3267 */
#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (1101)
/* tptz:AbsoluteMoveResponse complex type: */
class SOAP_CMAC _tptz__AbsoluteMoveResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__AbsoluteMoveResponse (1101)
	virtual int soap_type(void) const { return 1101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__AbsoluteMoveResponse, default initialized and not managed by a soap context
	virtual _tptz__AbsoluteMoveResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__AbsoluteMoveResponse); }
	         _tptz__AbsoluteMoveResponse() { _tptz__AbsoluteMoveResponse::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMoveResponse() { }
	friend SOAP_FMAC1 _tptz__AbsoluteMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3270 */
#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (1102)
/* tptz:Stop complex type: */
class SOAP_CMAC _tptz__Stop
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	bool *PanTilt;	/* optional element of XSD type xsd:boolean */
	bool *Zoom;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__Stop (1102)
	virtual int soap_type(void) const { return 1102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__Stop, default initialized and not managed by a soap context
	virtual _tptz__Stop *soap_alloc(void) const { return SOAP_NEW(_tptz__Stop); }
	         _tptz__Stop() { _tptz__Stop::soap_default(NULL); }
	virtual ~_tptz__Stop() { }
	friend SOAP_FMAC1 _tptz__Stop * SOAP_FMAC2 soap_instantiate__tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3273 */
#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (1103)
/* tptz:StopResponse complex type: */
class SOAP_CMAC _tptz__StopResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__StopResponse (1103)
	virtual int soap_type(void) const { return 1103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__StopResponse, default initialized and not managed by a soap context
	virtual _tptz__StopResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__StopResponse); }
	         _tptz__StopResponse() { _tptz__StopResponse::soap_default(NULL); }
	virtual ~_tptz__StopResponse() { }
	friend SOAP_FMAC1 _tptz__StopResponse * SOAP_FMAC2 soap_instantiate__tptz__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3276 */
#ifndef SOAP_TYPE__tptz__GetPresetTours
#define SOAP_TYPE__tptz__GetPresetTours (1104)
/* tptz:GetPresetTours complex type: */
class SOAP_CMAC _tptz__GetPresetTours
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTours (1104)
	virtual int soap_type(void) const { return 1104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTours, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTours *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTours); }
	         _tptz__GetPresetTours() { _tptz__GetPresetTours::soap_default(NULL); }
	virtual ~_tptz__GetPresetTours() { }
	friend SOAP_FMAC1 _tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3279 */
#ifndef SOAP_TYPE__tptz__GetPresetToursResponse
#define SOAP_TYPE__tptz__GetPresetToursResponse (1105)
/* tptz:GetPresetToursResponse complex type: */
class SOAP_CMAC _tptz__GetPresetToursResponse
{
public:
	int __sizePresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PresetTour> of XSD type tt:PresetTour */
	tt__PresetTour **PresetTour;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetToursResponse (1105)
	virtual int soap_type(void) const { return 1105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetToursResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetToursResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetToursResponse); }
	         _tptz__GetPresetToursResponse() { _tptz__GetPresetToursResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetToursResponse() { }
	friend SOAP_FMAC1 _tptz__GetPresetToursResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetToursResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3282 */
#ifndef SOAP_TYPE__tptz__GetPresetTour
#define SOAP_TYPE__tptz__GetPresetTour (1106)
/* tptz:GetPresetTour complex type: */
class SOAP_CMAC _tptz__GetPresetTour
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTour (1106)
	virtual int soap_type(void) const { return 1106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTour, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTour); }
	         _tptz__GetPresetTour() { _tptz__GetPresetTour::soap_default(NULL); }
	virtual ~_tptz__GetPresetTour() { }
	friend SOAP_FMAC1 _tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3285 */
#ifndef SOAP_TYPE__tptz__GetPresetTourResponse
#define SOAP_TYPE__tptz__GetPresetTourResponse (1107)
/* tptz:GetPresetTourResponse complex type: */
class SOAP_CMAC _tptz__GetPresetTourResponse
{
public:
	tt__PresetTour *PresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PresetTour */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourResponse (1107)
	virtual int soap_type(void) const { return 1107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourResponse); }
	         _tptz__GetPresetTourResponse() { _tptz__GetPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourResponse() { }
	friend SOAP_FMAC1 _tptz__GetPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3288 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptions
#define SOAP_TYPE__tptz__GetPresetTourOptions (1108)
/* tptz:GetPresetTourOptions complex type: */
class SOAP_CMAC _tptz__GetPresetTourOptions
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetTourToken;	/* optional element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourOptions (1108)
	virtual int soap_type(void) const { return 1108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourOptions, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourOptions *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourOptions); }
	         _tptz__GetPresetTourOptions() { _tptz__GetPresetTourOptions::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptions() { }
	friend SOAP_FMAC1 _tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3291 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptionsResponse
#define SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1109)
/* tptz:GetPresetTourOptionsResponse complex type: */
class SOAP_CMAC _tptz__GetPresetTourOptionsResponse
{
public:
	tt__PTZPresetTourOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:PTZPresetTourOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1109)
	virtual int soap_type(void) const { return 1109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__GetPresetTourOptionsResponse, default initialized and not managed by a soap context
	virtual _tptz__GetPresetTourOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__GetPresetTourOptionsResponse); }
	         _tptz__GetPresetTourOptionsResponse() { _tptz__GetPresetTourOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptionsResponse() { }
	friend SOAP_FMAC1 _tptz__GetPresetTourOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3294 */
#ifndef SOAP_TYPE__tptz__CreatePresetTour
#define SOAP_TYPE__tptz__CreatePresetTour (1110)
/* tptz:CreatePresetTour complex type: */
class SOAP_CMAC _tptz__CreatePresetTour
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__CreatePresetTour (1110)
	virtual int soap_type(void) const { return 1110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__CreatePresetTour, default initialized and not managed by a soap context
	virtual _tptz__CreatePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__CreatePresetTour); }
	         _tptz__CreatePresetTour() { _tptz__CreatePresetTour::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTour() { }
	friend SOAP_FMAC1 _tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3297 */
#ifndef SOAP_TYPE__tptz__CreatePresetTourResponse
#define SOAP_TYPE__tptz__CreatePresetTourResponse (1111)
/* tptz:CreatePresetTourResponse complex type: */
class SOAP_CMAC _tptz__CreatePresetTourResponse
{
public:
	char *PresetTourToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__CreatePresetTourResponse (1111)
	virtual int soap_type(void) const { return 1111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__CreatePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__CreatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__CreatePresetTourResponse); }
	         _tptz__CreatePresetTourResponse() { _tptz__CreatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTourResponse() { }
	friend SOAP_FMAC1 _tptz__CreatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3300 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTour
#define SOAP_TYPE__tptz__ModifyPresetTour (1112)
/* tptz:ModifyPresetTour complex type: */
class SOAP_CMAC _tptz__ModifyPresetTour
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	tt__PresetTour *PresetTour;	/* required element of XSD type tt:PresetTour */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ModifyPresetTour (1112)
	virtual int soap_type(void) const { return 1112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ModifyPresetTour, default initialized and not managed by a soap context
	virtual _tptz__ModifyPresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__ModifyPresetTour); }
	         _tptz__ModifyPresetTour() { _tptz__ModifyPresetTour::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTour() { }
	friend SOAP_FMAC1 _tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3303 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTourResponse
#define SOAP_TYPE__tptz__ModifyPresetTourResponse (1113)
/* tptz:ModifyPresetTourResponse complex type: */
class SOAP_CMAC _tptz__ModifyPresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__ModifyPresetTourResponse (1113)
	virtual int soap_type(void) const { return 1113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__ModifyPresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__ModifyPresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__ModifyPresetTourResponse); }
	         _tptz__ModifyPresetTourResponse() { _tptz__ModifyPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTourResponse() { }
	friend SOAP_FMAC1 _tptz__ModifyPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3306 */
#ifndef SOAP_TYPE__tptz__OperatePresetTour
#define SOAP_TYPE__tptz__OperatePresetTour (1114)
/* tptz:OperatePresetTour complex type: */
class SOAP_CMAC _tptz__OperatePresetTour
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__PTZPresetTourOperation Operation;	/* required element of XSD type tt:PTZPresetTourOperation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__OperatePresetTour (1114)
	virtual int soap_type(void) const { return 1114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__OperatePresetTour, default initialized and not managed by a soap context
	virtual _tptz__OperatePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__OperatePresetTour); }
	         _tptz__OperatePresetTour() { _tptz__OperatePresetTour::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTour() { }
	friend SOAP_FMAC1 _tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3309 */
#ifndef SOAP_TYPE__tptz__OperatePresetTourResponse
#define SOAP_TYPE__tptz__OperatePresetTourResponse (1115)
/* tptz:OperatePresetTourResponse complex type: */
class SOAP_CMAC _tptz__OperatePresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__OperatePresetTourResponse (1115)
	virtual int soap_type(void) const { return 1115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__OperatePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__OperatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__OperatePresetTourResponse); }
	         _tptz__OperatePresetTourResponse() { _tptz__OperatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTourResponse() { }
	friend SOAP_FMAC1 _tptz__OperatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3312 */
#ifndef SOAP_TYPE__tptz__RemovePresetTour
#define SOAP_TYPE__tptz__RemovePresetTour (1116)
/* tptz:RemovePresetTour complex type: */
class SOAP_CMAC _tptz__RemovePresetTour
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetTour (1116)
	virtual int soap_type(void) const { return 1116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetTour, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetTour *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetTour); }
	         _tptz__RemovePresetTour() { _tptz__RemovePresetTour::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTour() { }
	friend SOAP_FMAC1 _tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3315 */
#ifndef SOAP_TYPE__tptz__RemovePresetTourResponse
#define SOAP_TYPE__tptz__RemovePresetTourResponse (1117)
/* tptz:RemovePresetTourResponse complex type: */
class SOAP_CMAC _tptz__RemovePresetTourResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tptz__RemovePresetTourResponse (1117)
	virtual int soap_type(void) const { return 1117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tptz__RemovePresetTourResponse, default initialized and not managed by a soap context
	virtual _tptz__RemovePresetTourResponse *soap_alloc(void) const { return SOAP_NEW(_tptz__RemovePresetTourResponse); }
	         _tptz__RemovePresetTourResponse() { _tptz__RemovePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTourResponse() { }
	friend SOAP_FMAC1 _tptz__RemovePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3318 */
#ifndef SOAP_TYPE_trv__Capabilities
#define SOAP_TYPE_trv__Capabilities (1118)
/* Type trv__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trv:Capabilities complex type: */
class SOAP_CMAC trv__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *RTP_USCOREMulticast;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	int SupportedReceivers;	/* required attribute of XSD type xsd:int */
	int *MaximumRTSPURILength;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trv__Capabilities (1118)
	virtual int soap_type(void) const { return 1118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trv__Capabilities, default initialized and not managed by a soap context
	virtual trv__Capabilities *soap_alloc(void) const { return SOAP_NEW(trv__Capabilities); }
	         trv__Capabilities() { trv__Capabilities::soap_default(NULL); }
	virtual ~trv__Capabilities() { }
	friend SOAP_FMAC1 trv__Capabilities * SOAP_FMAC2 soap_instantiate_trv__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3321 */
#ifndef SOAP_TYPE__trv__GetServiceCapabilities
#define SOAP_TYPE__trv__GetServiceCapabilities (1119)
/* trv:GetServiceCapabilities complex type: */
class SOAP_CMAC _trv__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetServiceCapabilities (1119)
	virtual int soap_type(void) const { return 1119; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trv__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trv__GetServiceCapabilities); }
	         _trv__GetServiceCapabilities() { _trv__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trv__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _trv__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trv__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3324 */
#ifndef SOAP_TYPE__trv__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trv__GetServiceCapabilitiesResponse (1120)
/* trv:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trv__GetServiceCapabilitiesResponse
{
public:
	trv__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trv:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetServiceCapabilitiesResponse (1120)
	virtual int soap_type(void) const { return 1120; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trv__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetServiceCapabilitiesResponse); }
	         _trv__GetServiceCapabilitiesResponse() { _trv__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trv__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _trv__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trv__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3327 */
#ifndef SOAP_TYPE__trv__GetReceivers
#define SOAP_TYPE__trv__GetReceivers (1121)
/* trv:GetReceivers complex type: */
class SOAP_CMAC _trv__GetReceivers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceivers (1121)
	virtual int soap_type(void) const { return 1121; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceivers, default initialized and not managed by a soap context
	virtual _trv__GetReceivers *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceivers); }
	         _trv__GetReceivers() { _trv__GetReceivers::soap_default(NULL); }
	virtual ~_trv__GetReceivers() { }
	friend SOAP_FMAC1 _trv__GetReceivers * SOAP_FMAC2 soap_instantiate__trv__GetReceivers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3330 */
#ifndef SOAP_TYPE__trv__GetReceiversResponse
#define SOAP_TYPE__trv__GetReceiversResponse (1122)
/* trv:GetReceiversResponse complex type: */
class SOAP_CMAC _trv__GetReceiversResponse
{
public:
	int __sizeReceivers;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Receivers> of XSD type tt:Receiver */
	tt__Receiver **Receivers;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiversResponse (1122)
	virtual int soap_type(void) const { return 1122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiversResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiversResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiversResponse); }
	         _trv__GetReceiversResponse() { _trv__GetReceiversResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiversResponse() { }
	friend SOAP_FMAC1 _trv__GetReceiversResponse * SOAP_FMAC2 soap_instantiate__trv__GetReceiversResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3333 */
#ifndef SOAP_TYPE__trv__GetReceiver
#define SOAP_TYPE__trv__GetReceiver (1123)
/* trv:GetReceiver complex type: */
class SOAP_CMAC _trv__GetReceiver
{
public:
	char *ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiver (1123)
	virtual int soap_type(void) const { return 1123; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiver, default initialized and not managed by a soap context
	virtual _trv__GetReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiver); }
	         _trv__GetReceiver() { _trv__GetReceiver::soap_default(NULL); }
	virtual ~_trv__GetReceiver() { }
	friend SOAP_FMAC1 _trv__GetReceiver * SOAP_FMAC2 soap_instantiate__trv__GetReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3336 */
#ifndef SOAP_TYPE__trv__GetReceiverResponse
#define SOAP_TYPE__trv__GetReceiverResponse (1124)
/* trv:GetReceiverResponse complex type: */
class SOAP_CMAC _trv__GetReceiverResponse
{
public:
	tt__Receiver *Receiver;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Receiver */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverResponse (1124)
	virtual int soap_type(void) const { return 1124; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverResponse); }
	         _trv__GetReceiverResponse() { _trv__GetReceiverResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiverResponse() { }
	friend SOAP_FMAC1 _trv__GetReceiverResponse * SOAP_FMAC2 soap_instantiate__trv__GetReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3339 */
#ifndef SOAP_TYPE__trv__CreateReceiver
#define SOAP_TYPE__trv__CreateReceiver (1125)
/* trv:CreateReceiver complex type: */
class SOAP_CMAC _trv__CreateReceiver
{
public:
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__CreateReceiver (1125)
	virtual int soap_type(void) const { return 1125; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__CreateReceiver, default initialized and not managed by a soap context
	virtual _trv__CreateReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__CreateReceiver); }
	         _trv__CreateReceiver() { _trv__CreateReceiver::soap_default(NULL); }
	virtual ~_trv__CreateReceiver() { }
	friend SOAP_FMAC1 _trv__CreateReceiver * SOAP_FMAC2 soap_instantiate__trv__CreateReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3342 */
#ifndef SOAP_TYPE__trv__CreateReceiverResponse
#define SOAP_TYPE__trv__CreateReceiverResponse (1126)
/* trv:CreateReceiverResponse complex type: */
class SOAP_CMAC _trv__CreateReceiverResponse
{
public:
	tt__Receiver *Receiver;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:Receiver */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__CreateReceiverResponse (1126)
	virtual int soap_type(void) const { return 1126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__CreateReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__CreateReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__CreateReceiverResponse); }
	         _trv__CreateReceiverResponse() { _trv__CreateReceiverResponse::soap_default(NULL); }
	virtual ~_trv__CreateReceiverResponse() { }
	friend SOAP_FMAC1 _trv__CreateReceiverResponse * SOAP_FMAC2 soap_instantiate__trv__CreateReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3345 */
#ifndef SOAP_TYPE__trv__DeleteReceiver
#define SOAP_TYPE__trv__DeleteReceiver (1127)
/* trv:DeleteReceiver complex type: */
class SOAP_CMAC _trv__DeleteReceiver
{
public:
	char *ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__DeleteReceiver (1127)
	virtual int soap_type(void) const { return 1127; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__DeleteReceiver, default initialized and not managed by a soap context
	virtual _trv__DeleteReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__DeleteReceiver); }
	         _trv__DeleteReceiver() { _trv__DeleteReceiver::soap_default(NULL); }
	virtual ~_trv__DeleteReceiver() { }
	friend SOAP_FMAC1 _trv__DeleteReceiver * SOAP_FMAC2 soap_instantiate__trv__DeleteReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3348 */
#ifndef SOAP_TYPE__trv__DeleteReceiverResponse
#define SOAP_TYPE__trv__DeleteReceiverResponse (1128)
/* trv:DeleteReceiverResponse complex type: */
class SOAP_CMAC _trv__DeleteReceiverResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__DeleteReceiverResponse (1128)
	virtual int soap_type(void) const { return 1128; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__DeleteReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__DeleteReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__DeleteReceiverResponse); }
	         _trv__DeleteReceiverResponse() { _trv__DeleteReceiverResponse::soap_default(NULL); }
	virtual ~_trv__DeleteReceiverResponse() { }
	friend SOAP_FMAC1 _trv__DeleteReceiverResponse * SOAP_FMAC2 soap_instantiate__trv__DeleteReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3351 */
#ifndef SOAP_TYPE__trv__ConfigureReceiver
#define SOAP_TYPE__trv__ConfigureReceiver (1129)
/* trv:ConfigureReceiver complex type: */
class SOAP_CMAC _trv__ConfigureReceiver
{
public:
	char *ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	tt__ReceiverConfiguration *Configuration;	/* required element of XSD type tt:ReceiverConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__ConfigureReceiver (1129)
	virtual int soap_type(void) const { return 1129; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__ConfigureReceiver, default initialized and not managed by a soap context
	virtual _trv__ConfigureReceiver *soap_alloc(void) const { return SOAP_NEW(_trv__ConfigureReceiver); }
	         _trv__ConfigureReceiver() { _trv__ConfigureReceiver::soap_default(NULL); }
	virtual ~_trv__ConfigureReceiver() { }
	friend SOAP_FMAC1 _trv__ConfigureReceiver * SOAP_FMAC2 soap_instantiate__trv__ConfigureReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3354 */
#ifndef SOAP_TYPE__trv__ConfigureReceiverResponse
#define SOAP_TYPE__trv__ConfigureReceiverResponse (1130)
/* trv:ConfigureReceiverResponse complex type: */
class SOAP_CMAC _trv__ConfigureReceiverResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__ConfigureReceiverResponse (1130)
	virtual int soap_type(void) const { return 1130; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__ConfigureReceiverResponse, default initialized and not managed by a soap context
	virtual _trv__ConfigureReceiverResponse *soap_alloc(void) const { return SOAP_NEW(_trv__ConfigureReceiverResponse); }
	         _trv__ConfigureReceiverResponse() { _trv__ConfigureReceiverResponse::soap_default(NULL); }
	virtual ~_trv__ConfigureReceiverResponse() { }
	friend SOAP_FMAC1 _trv__ConfigureReceiverResponse * SOAP_FMAC2 soap_instantiate__trv__ConfigureReceiverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3357 */
#ifndef SOAP_TYPE__trv__SetReceiverMode
#define SOAP_TYPE__trv__SetReceiverMode (1131)
/* trv:SetReceiverMode complex type: */
class SOAP_CMAC _trv__SetReceiverMode
{
public:
	char *ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	enum tt__ReceiverMode Mode;	/* required element of XSD type tt:ReceiverMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__SetReceiverMode (1131)
	virtual int soap_type(void) const { return 1131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__SetReceiverMode, default initialized and not managed by a soap context
	virtual _trv__SetReceiverMode *soap_alloc(void) const { return SOAP_NEW(_trv__SetReceiverMode); }
	         _trv__SetReceiverMode() { _trv__SetReceiverMode::soap_default(NULL); }
	virtual ~_trv__SetReceiverMode() { }
	friend SOAP_FMAC1 _trv__SetReceiverMode * SOAP_FMAC2 soap_instantiate__trv__SetReceiverMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3360 */
#ifndef SOAP_TYPE__trv__SetReceiverModeResponse
#define SOAP_TYPE__trv__SetReceiverModeResponse (1132)
/* trv:SetReceiverModeResponse complex type: */
class SOAP_CMAC _trv__SetReceiverModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__SetReceiverModeResponse (1132)
	virtual int soap_type(void) const { return 1132; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__SetReceiverModeResponse, default initialized and not managed by a soap context
	virtual _trv__SetReceiverModeResponse *soap_alloc(void) const { return SOAP_NEW(_trv__SetReceiverModeResponse); }
	         _trv__SetReceiverModeResponse() { _trv__SetReceiverModeResponse::soap_default(NULL); }
	virtual ~_trv__SetReceiverModeResponse() { }
	friend SOAP_FMAC1 _trv__SetReceiverModeResponse * SOAP_FMAC2 soap_instantiate__trv__SetReceiverModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3363 */
#ifndef SOAP_TYPE__trv__GetReceiverState
#define SOAP_TYPE__trv__GetReceiverState (1133)
/* trv:GetReceiverState complex type: */
class SOAP_CMAC _trv__GetReceiverState
{
public:
	char *ReceiverToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverState (1133)
	virtual int soap_type(void) const { return 1133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverState, default initialized and not managed by a soap context
	virtual _trv__GetReceiverState *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverState); }
	         _trv__GetReceiverState() { _trv__GetReceiverState::soap_default(NULL); }
	virtual ~_trv__GetReceiverState() { }
	friend SOAP_FMAC1 _trv__GetReceiverState * SOAP_FMAC2 soap_instantiate__trv__GetReceiverState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3366 */
#ifndef SOAP_TYPE__trv__GetReceiverStateResponse
#define SOAP_TYPE__trv__GetReceiverStateResponse (1134)
/* trv:GetReceiverStateResponse complex type: */
class SOAP_CMAC _trv__GetReceiverStateResponse
{
public:
	tt__ReceiverStateInformation *ReceiverState;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReceiverStateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trv__GetReceiverStateResponse (1134)
	virtual int soap_type(void) const { return 1134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trv__GetReceiverStateResponse, default initialized and not managed by a soap context
	virtual _trv__GetReceiverStateResponse *soap_alloc(void) const { return SOAP_NEW(_trv__GetReceiverStateResponse); }
	         _trv__GetReceiverStateResponse() { _trv__GetReceiverStateResponse::soap_default(NULL); }
	virtual ~_trv__GetReceiverStateResponse() { }
	friend SOAP_FMAC1 _trv__GetReceiverStateResponse * SOAP_FMAC2 soap_instantiate__trv__GetReceiverStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3369 */
#ifndef SOAP_TYPE_trc__Capabilities
#define SOAP_TYPE_trc__Capabilities (1135)
/* Type trc__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:Capabilities complex type: */
class SOAP_CMAC trc__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *DynamicRecordings;	/* optional attribute of XSD type xsd:boolean */
	bool *DynamicTracks;	/* optional attribute of XSD type xsd:boolean */
	char *Encoding;	/* optional attribute of XSD type trc:EncodingTypes */
	float *MaxRate;	/* optional attribute of XSD type xsd:float */
	float *MaxTotalRate;	/* optional attribute of XSD type xsd:float */
	float *MaxRecordings;	/* optional attribute of XSD type xsd:float */
	int *MaxRecordingJobs;	/* optional attribute of XSD type xsd:int */
	bool *Options;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__Capabilities (1135)
	virtual int soap_type(void) const { return 1135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__Capabilities, default initialized and not managed by a soap context
	virtual trc__Capabilities *soap_alloc(void) const { return SOAP_NEW(trc__Capabilities); }
	         trc__Capabilities() { trc__Capabilities::soap_default(NULL); }
	virtual ~trc__Capabilities() { }
	friend SOAP_FMAC1 trc__Capabilities * SOAP_FMAC2 soap_instantiate_trc__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3372 */
#ifndef SOAP_TYPE_trc__RecordingOptions
#define SOAP_TYPE_trc__RecordingOptions (1136)
/* Type trc__RecordingOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:RecordingOptions complex type: */
class SOAP_CMAC trc__RecordingOptions : public xsd__anyType
{
public:
	trc__JobOptions *Job;	/* required element of XSD type trc:JobOptions */
	trc__TrackOptions *Track;	/* required element of XSD type trc:TrackOptions */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_trc__RecordingOptions (1136)
	virtual int soap_type(void) const { return 1136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__RecordingOptions, default initialized and not managed by a soap context
	virtual trc__RecordingOptions *soap_alloc(void) const { return SOAP_NEW(trc__RecordingOptions); }
	         trc__RecordingOptions() { trc__RecordingOptions::soap_default(NULL); }
	virtual ~trc__RecordingOptions() { }
	friend SOAP_FMAC1 trc__RecordingOptions * SOAP_FMAC2 soap_instantiate_trc__RecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3375 */
#ifndef SOAP_TYPE_trc__JobOptions
#define SOAP_TYPE_trc__JobOptions (1137)
/* Type trc__JobOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:JobOptions simple type: */
class SOAP_CMAC trc__JobOptions : public xsd__anyType
{
public:
	int *Spare;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__JobOptions (1137)
	virtual int soap_type(void) const { return 1137; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__JobOptions, default initialized and not managed by a soap context
	virtual trc__JobOptions *soap_alloc(void) const { return SOAP_NEW(trc__JobOptions); }
	         trc__JobOptions() { trc__JobOptions::soap_default(NULL); }
	virtual ~trc__JobOptions() { }
	friend SOAP_FMAC1 trc__JobOptions * SOAP_FMAC2 soap_instantiate_trc__JobOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3378 */
#ifndef SOAP_TYPE_trc__TrackOptions
#define SOAP_TYPE_trc__TrackOptions (1138)
/* Type trc__TrackOptions is a recursive data type (in)directly referencing itself through its (base) class members */
/* trc:TrackOptions simple type: */
class SOAP_CMAC trc__TrackOptions : public xsd__anyType
{
public:
	int *SpareTotal;	/* optional attribute of XSD type xsd:int */
	int *SpareVideo;	/* optional attribute of XSD type xsd:int */
	int *SpareAudio;	/* optional attribute of XSD type xsd:int */
	int *SpareMetadata;	/* optional attribute of XSD type xsd:int */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trc__TrackOptions (1138)
	virtual int soap_type(void) const { return 1138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trc__TrackOptions, default initialized and not managed by a soap context
	virtual trc__TrackOptions *soap_alloc(void) const { return SOAP_NEW(trc__TrackOptions); }
	         trc__TrackOptions() { trc__TrackOptions::soap_default(NULL); }
	virtual ~trc__TrackOptions() { }
	friend SOAP_FMAC1 trc__TrackOptions * SOAP_FMAC2 soap_instantiate_trc__TrackOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3381 */
#ifndef SOAP_TYPE__trc__GetServiceCapabilities
#define SOAP_TYPE__trc__GetServiceCapabilities (1139)
/* trc:GetServiceCapabilities complex type: */
class SOAP_CMAC _trc__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetServiceCapabilities (1139)
	virtual int soap_type(void) const { return 1139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trc__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trc__GetServiceCapabilities); }
	         _trc__GetServiceCapabilities() { _trc__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trc__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _trc__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trc__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3384 */
#ifndef SOAP_TYPE__trc__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trc__GetServiceCapabilitiesResponse (1140)
/* trc:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trc__GetServiceCapabilitiesResponse
{
public:
	trc__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trc:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetServiceCapabilitiesResponse (1140)
	virtual int soap_type(void) const { return 1140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trc__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetServiceCapabilitiesResponse); }
	         _trc__GetServiceCapabilitiesResponse() { _trc__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trc__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _trc__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trc__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3387 */
#ifndef SOAP_TYPE__trc__CreateRecording
#define SOAP_TYPE__trc__CreateRecording (1141)
/* trc:CreateRecording complex type: */
class SOAP_CMAC _trc__CreateRecording
{
public:
	tt__RecordingConfiguration *RecordingConfiguration;	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecording (1141)
	virtual int soap_type(void) const { return 1141; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecording, default initialized and not managed by a soap context
	virtual _trc__CreateRecording *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecording); }
	         _trc__CreateRecording() { _trc__CreateRecording::soap_default(NULL); }
	virtual ~_trc__CreateRecording() { }
	friend SOAP_FMAC1 _trc__CreateRecording * SOAP_FMAC2 soap_instantiate__trc__CreateRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3390 */
#ifndef SOAP_TYPE__trc__CreateRecordingResponse
#define SOAP_TYPE__trc__CreateRecordingResponse (1142)
/* trc:CreateRecordingResponse complex type: */
class SOAP_CMAC _trc__CreateRecordingResponse
{
public:
	char *RecordingToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingResponse (1142)
	virtual int soap_type(void) const { return 1142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingResponse, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingResponse); }
	         _trc__CreateRecordingResponse() { _trc__CreateRecordingResponse::soap_default(NULL); }
	virtual ~_trc__CreateRecordingResponse() { }
	friend SOAP_FMAC1 _trc__CreateRecordingResponse * SOAP_FMAC2 soap_instantiate__trc__CreateRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3393 */
#ifndef SOAP_TYPE__trc__DeleteRecording
#define SOAP_TYPE__trc__DeleteRecording (1143)
/* trc:DeleteRecording complex type: */
class SOAP_CMAC _trc__DeleteRecording
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecording (1143)
	virtual int soap_type(void) const { return 1143; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecording, default initialized and not managed by a soap context
	virtual _trc__DeleteRecording *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecording); }
	         _trc__DeleteRecording() { _trc__DeleteRecording::soap_default(NULL); }
	virtual ~_trc__DeleteRecording() { }
	friend SOAP_FMAC1 _trc__DeleteRecording * SOAP_FMAC2 soap_instantiate__trc__DeleteRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3396 */
#ifndef SOAP_TYPE__trc__DeleteRecordingResponse
#define SOAP_TYPE__trc__DeleteRecordingResponse (1144)
/* trc:DeleteRecordingResponse complex type: */
class SOAP_CMAC _trc__DeleteRecordingResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingResponse (1144)
	virtual int soap_type(void) const { return 1144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingResponse); }
	         _trc__DeleteRecordingResponse() { _trc__DeleteRecordingResponse::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingResponse() { }
	friend SOAP_FMAC1 _trc__DeleteRecordingResponse * SOAP_FMAC2 soap_instantiate__trc__DeleteRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3399 */
#ifndef SOAP_TYPE__trc__GetRecordings
#define SOAP_TYPE__trc__GetRecordings (1145)
/* trc:GetRecordings complex type: */
class SOAP_CMAC _trc__GetRecordings
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordings (1145)
	virtual int soap_type(void) const { return 1145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordings, default initialized and not managed by a soap context
	virtual _trc__GetRecordings *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordings); }
	         _trc__GetRecordings() { _trc__GetRecordings::soap_default(NULL); }
	virtual ~_trc__GetRecordings() { }
	friend SOAP_FMAC1 _trc__GetRecordings * SOAP_FMAC2 soap_instantiate__trc__GetRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3402 */
#ifndef SOAP_TYPE__trc__GetRecordingsResponse
#define SOAP_TYPE__trc__GetRecordingsResponse (1146)
/* trc:GetRecordingsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingsResponse
{
public:
	int __sizeRecordingItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <RecordingItem> of XSD type tt:GetRecordingsResponseItem */
	tt__GetRecordingsResponseItem **RecordingItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingsResponse (1146)
	virtual int soap_type(void) const { return 1146; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingsResponse); }
	         _trc__GetRecordingsResponse() { _trc__GetRecordingsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingsResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingsResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3405 */
#ifndef SOAP_TYPE__trc__SetRecordingConfiguration
#define SOAP_TYPE__trc__SetRecordingConfiguration (1147)
/* trc:SetRecordingConfiguration complex type: */
class SOAP_CMAC _trc__SetRecordingConfiguration
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__RecordingConfiguration *RecordingConfiguration;	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingConfiguration (1147)
	virtual int soap_type(void) const { return 1147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetRecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingConfiguration); }
	         _trc__SetRecordingConfiguration() { _trc__SetRecordingConfiguration::soap_default(NULL); }
	virtual ~_trc__SetRecordingConfiguration() { }
	friend SOAP_FMAC1 _trc__SetRecordingConfiguration * SOAP_FMAC2 soap_instantiate__trc__SetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3408 */
#ifndef SOAP_TYPE__trc__SetRecordingConfigurationResponse
#define SOAP_TYPE__trc__SetRecordingConfigurationResponse (1148)
/* trc:SetRecordingConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetRecordingConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingConfigurationResponse (1148)
	virtual int soap_type(void) const { return 1148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingConfigurationResponse); }
	         _trc__SetRecordingConfigurationResponse() { _trc__SetRecordingConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__SetRecordingConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__SetRecordingConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3411 */
#ifndef SOAP_TYPE__trc__GetRecordingConfiguration
#define SOAP_TYPE__trc__GetRecordingConfiguration (1149)
/* trc:GetRecordingConfiguration complex type: */
class SOAP_CMAC _trc__GetRecordingConfiguration
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingConfiguration (1149)
	virtual int soap_type(void) const { return 1149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetRecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingConfiguration); }
	         _trc__GetRecordingConfiguration() { _trc__GetRecordingConfiguration::soap_default(NULL); }
	virtual ~_trc__GetRecordingConfiguration() { }
	friend SOAP_FMAC1 _trc__GetRecordingConfiguration * SOAP_FMAC2 soap_instantiate__trc__GetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3414 */
#ifndef SOAP_TYPE__trc__GetRecordingConfigurationResponse
#define SOAP_TYPE__trc__GetRecordingConfigurationResponse (1150)
/* trc:GetRecordingConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetRecordingConfigurationResponse
{
public:
	tt__RecordingConfiguration *RecordingConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingConfigurationResponse (1150)
	virtual int soap_type(void) const { return 1150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingConfigurationResponse); }
	         _trc__GetRecordingConfigurationResponse() { _trc__GetRecordingConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3417 */
#ifndef SOAP_TYPE__trc__CreateTrack
#define SOAP_TYPE__trc__CreateTrack (1151)
/* trc:CreateTrack complex type: */
class SOAP_CMAC _trc__CreateTrack
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	tt__TrackConfiguration *TrackConfiguration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateTrack (1151)
	virtual int soap_type(void) const { return 1151; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateTrack, default initialized and not managed by a soap context
	virtual _trc__CreateTrack *soap_alloc(void) const { return SOAP_NEW(_trc__CreateTrack); }
	         _trc__CreateTrack() { _trc__CreateTrack::soap_default(NULL); }
	virtual ~_trc__CreateTrack() { }
	friend SOAP_FMAC1 _trc__CreateTrack * SOAP_FMAC2 soap_instantiate__trc__CreateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3420 */
#ifndef SOAP_TYPE__trc__CreateTrackResponse
#define SOAP_TYPE__trc__CreateTrackResponse (1152)
/* trc:CreateTrackResponse complex type: */
class SOAP_CMAC _trc__CreateTrackResponse
{
public:
	char *TrackToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateTrackResponse (1152)
	virtual int soap_type(void) const { return 1152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateTrackResponse, default initialized and not managed by a soap context
	virtual _trc__CreateTrackResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateTrackResponse); }
	         _trc__CreateTrackResponse() { _trc__CreateTrackResponse::soap_default(NULL); }
	virtual ~_trc__CreateTrackResponse() { }
	friend SOAP_FMAC1 _trc__CreateTrackResponse * SOAP_FMAC2 soap_instantiate__trc__CreateTrackResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3423 */
#ifndef SOAP_TYPE__trc__DeleteTrack
#define SOAP_TYPE__trc__DeleteTrack (1153)
/* trc:DeleteTrack complex type: */
class SOAP_CMAC _trc__DeleteTrack
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteTrack (1153)
	virtual int soap_type(void) const { return 1153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteTrack, default initialized and not managed by a soap context
	virtual _trc__DeleteTrack *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteTrack); }
	         _trc__DeleteTrack() { _trc__DeleteTrack::soap_default(NULL); }
	virtual ~_trc__DeleteTrack() { }
	friend SOAP_FMAC1 _trc__DeleteTrack * SOAP_FMAC2 soap_instantiate__trc__DeleteTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3426 */
#ifndef SOAP_TYPE__trc__DeleteTrackResponse
#define SOAP_TYPE__trc__DeleteTrackResponse (1154)
/* trc:DeleteTrackResponse complex type: */
class SOAP_CMAC _trc__DeleteTrackResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteTrackResponse (1154)
	virtual int soap_type(void) const { return 1154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteTrackResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteTrackResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteTrackResponse); }
	         _trc__DeleteTrackResponse() { _trc__DeleteTrackResponse::soap_default(NULL); }
	virtual ~_trc__DeleteTrackResponse() { }
	friend SOAP_FMAC1 _trc__DeleteTrackResponse * SOAP_FMAC2 soap_instantiate__trc__DeleteTrackResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3429 */
#ifndef SOAP_TYPE__trc__GetTrackConfiguration
#define SOAP_TYPE__trc__GetTrackConfiguration (1155)
/* trc:GetTrackConfiguration complex type: */
class SOAP_CMAC _trc__GetTrackConfiguration
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetTrackConfiguration (1155)
	virtual int soap_type(void) const { return 1155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetTrackConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetTrackConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetTrackConfiguration); }
	         _trc__GetTrackConfiguration() { _trc__GetTrackConfiguration::soap_default(NULL); }
	virtual ~_trc__GetTrackConfiguration() { }
	friend SOAP_FMAC1 _trc__GetTrackConfiguration * SOAP_FMAC2 soap_instantiate__trc__GetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3432 */
#ifndef SOAP_TYPE__trc__GetTrackConfigurationResponse
#define SOAP_TYPE__trc__GetTrackConfigurationResponse (1156)
/* trc:GetTrackConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetTrackConfigurationResponse
{
public:
	tt__TrackConfiguration *TrackConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetTrackConfigurationResponse (1156)
	virtual int soap_type(void) const { return 1156; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetTrackConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetTrackConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetTrackConfigurationResponse); }
	         _trc__GetTrackConfigurationResponse() { _trc__GetTrackConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetTrackConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__GetTrackConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__GetTrackConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3435 */
#ifndef SOAP_TYPE__trc__SetTrackConfiguration
#define SOAP_TYPE__trc__SetTrackConfiguration (1157)
/* trc:SetTrackConfiguration complex type: */
class SOAP_CMAC _trc__SetTrackConfiguration
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	char *TrackToken;	/* required element of XSD type tt:TrackReference */
	tt__TrackConfiguration *TrackConfiguration;	/* required element of XSD type tt:TrackConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetTrackConfiguration (1157)
	virtual int soap_type(void) const { return 1157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetTrackConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetTrackConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetTrackConfiguration); }
	         _trc__SetTrackConfiguration() { _trc__SetTrackConfiguration::soap_default(NULL); }
	virtual ~_trc__SetTrackConfiguration() { }
	friend SOAP_FMAC1 _trc__SetTrackConfiguration * SOAP_FMAC2 soap_instantiate__trc__SetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3438 */
#ifndef SOAP_TYPE__trc__SetTrackConfigurationResponse
#define SOAP_TYPE__trc__SetTrackConfigurationResponse (1158)
/* trc:SetTrackConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetTrackConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetTrackConfigurationResponse (1158)
	virtual int soap_type(void) const { return 1158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetTrackConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetTrackConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetTrackConfigurationResponse); }
	         _trc__SetTrackConfigurationResponse() { _trc__SetTrackConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetTrackConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__SetTrackConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__SetTrackConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3441 */
#ifndef SOAP_TYPE__trc__CreateRecordingJob
#define SOAP_TYPE__trc__CreateRecordingJob (1159)
/* trc:CreateRecordingJob complex type: */
class SOAP_CMAC _trc__CreateRecordingJob
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingJob (1159)
	virtual int soap_type(void) const { return 1159; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingJob, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingJob *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingJob); }
	         _trc__CreateRecordingJob() { _trc__CreateRecordingJob::soap_default(NULL); }
	virtual ~_trc__CreateRecordingJob() { }
	friend SOAP_FMAC1 _trc__CreateRecordingJob * SOAP_FMAC2 soap_instantiate__trc__CreateRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3444 */
#ifndef SOAP_TYPE__trc__CreateRecordingJobResponse
#define SOAP_TYPE__trc__CreateRecordingJobResponse (1160)
/* trc:CreateRecordingJobResponse complex type: */
class SOAP_CMAC _trc__CreateRecordingJobResponse
{
public:
	char *JobToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__CreateRecordingJobResponse (1160)
	virtual int soap_type(void) const { return 1160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__CreateRecordingJobResponse, default initialized and not managed by a soap context
	virtual _trc__CreateRecordingJobResponse *soap_alloc(void) const { return SOAP_NEW(_trc__CreateRecordingJobResponse); }
	         _trc__CreateRecordingJobResponse() { _trc__CreateRecordingJobResponse::soap_default(NULL); }
	virtual ~_trc__CreateRecordingJobResponse() { }
	friend SOAP_FMAC1 _trc__CreateRecordingJobResponse * SOAP_FMAC2 soap_instantiate__trc__CreateRecordingJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3447 */
#ifndef SOAP_TYPE__trc__DeleteRecordingJob
#define SOAP_TYPE__trc__DeleteRecordingJob (1161)
/* trc:DeleteRecordingJob complex type: */
class SOAP_CMAC _trc__DeleteRecordingJob
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingJob (1161)
	virtual int soap_type(void) const { return 1161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingJob, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingJob *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingJob); }
	         _trc__DeleteRecordingJob() { _trc__DeleteRecordingJob::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingJob() { }
	friend SOAP_FMAC1 _trc__DeleteRecordingJob * SOAP_FMAC2 soap_instantiate__trc__DeleteRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3450 */
#ifndef SOAP_TYPE__trc__DeleteRecordingJobResponse
#define SOAP_TYPE__trc__DeleteRecordingJobResponse (1162)
/* trc:DeleteRecordingJobResponse complex type: */
class SOAP_CMAC _trc__DeleteRecordingJobResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__DeleteRecordingJobResponse (1162)
	virtual int soap_type(void) const { return 1162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__DeleteRecordingJobResponse, default initialized and not managed by a soap context
	virtual _trc__DeleteRecordingJobResponse *soap_alloc(void) const { return SOAP_NEW(_trc__DeleteRecordingJobResponse); }
	         _trc__DeleteRecordingJobResponse() { _trc__DeleteRecordingJobResponse::soap_default(NULL); }
	virtual ~_trc__DeleteRecordingJobResponse() { }
	friend SOAP_FMAC1 _trc__DeleteRecordingJobResponse * SOAP_FMAC2 soap_instantiate__trc__DeleteRecordingJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3453 */
#ifndef SOAP_TYPE__trc__GetRecordingJobs
#define SOAP_TYPE__trc__GetRecordingJobs (1163)
/* trc:GetRecordingJobs complex type: */
class SOAP_CMAC _trc__GetRecordingJobs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobs (1163)
	virtual int soap_type(void) const { return 1163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobs, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobs *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobs); }
	         _trc__GetRecordingJobs() { _trc__GetRecordingJobs::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobs() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobs * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3456 */
#ifndef SOAP_TYPE__trc__GetRecordingJobsResponse
#define SOAP_TYPE__trc__GetRecordingJobsResponse (1164)
/* trc:GetRecordingJobsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobsResponse
{
public:
	int __sizeJobItem;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <JobItem> of XSD type tt:GetRecordingJobsResponseItem */
	tt__GetRecordingJobsResponseItem **JobItem;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobsResponse (1164)
	virtual int soap_type(void) const { return 1164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobsResponse); }
	         _trc__GetRecordingJobsResponse() { _trc__GetRecordingJobsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobsResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobsResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3459 */
#ifndef SOAP_TYPE__trc__SetRecordingJobConfiguration
#define SOAP_TYPE__trc__SetRecordingJobConfiguration (1165)
/* trc:SetRecordingJobConfiguration complex type: */
class SOAP_CMAC _trc__SetRecordingJobConfiguration
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobConfiguration (1165)
	virtual int soap_type(void) const { return 1165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobConfiguration, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobConfiguration); }
	         _trc__SetRecordingJobConfiguration() { _trc__SetRecordingJobConfiguration::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobConfiguration() { }
	friend SOAP_FMAC1 _trc__SetRecordingJobConfiguration * SOAP_FMAC2 soap_instantiate__trc__SetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3462 */
#ifndef SOAP_TYPE__trc__SetRecordingJobConfigurationResponse
#define SOAP_TYPE__trc__SetRecordingJobConfigurationResponse (1166)
/* trc:SetRecordingJobConfigurationResponse complex type: */
class SOAP_CMAC _trc__SetRecordingJobConfigurationResponse
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobConfigurationResponse (1166)
	virtual int soap_type(void) const { return 1166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobConfigurationResponse); }
	         _trc__SetRecordingJobConfigurationResponse() { _trc__SetRecordingJobConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__SetRecordingJobConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3465 */
#ifndef SOAP_TYPE__trc__GetRecordingJobConfiguration
#define SOAP_TYPE__trc__GetRecordingJobConfiguration (1167)
/* trc:GetRecordingJobConfiguration complex type: */
class SOAP_CMAC _trc__GetRecordingJobConfiguration
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobConfiguration (1167)
	virtual int soap_type(void) const { return 1167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobConfiguration, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobConfiguration); }
	         _trc__GetRecordingJobConfiguration() { _trc__GetRecordingJobConfiguration::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobConfiguration() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobConfiguration * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3468 */
#ifndef SOAP_TYPE__trc__GetRecordingJobConfigurationResponse
#define SOAP_TYPE__trc__GetRecordingJobConfigurationResponse (1168)
/* trc:GetRecordingJobConfigurationResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobConfigurationResponse
{
public:
	tt__RecordingJobConfiguration *JobConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobConfigurationResponse (1168)
	virtual int soap_type(void) const { return 1168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobConfigurationResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobConfigurationResponse); }
	         _trc__GetRecordingJobConfigurationResponse() { _trc__GetRecordingJobConfigurationResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobConfigurationResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3471 */
#ifndef SOAP_TYPE__trc__SetRecordingJobMode
#define SOAP_TYPE__trc__SetRecordingJobMode (1169)
/* trc:SetRecordingJobMode complex type: */
class SOAP_CMAC _trc__SetRecordingJobMode
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	char *Mode;	/* required element of XSD type tt:RecordingJobMode */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobMode (1169)
	virtual int soap_type(void) const { return 1169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobMode, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobMode *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobMode); }
	         _trc__SetRecordingJobMode() { _trc__SetRecordingJobMode::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobMode() { }
	friend SOAP_FMAC1 _trc__SetRecordingJobMode * SOAP_FMAC2 soap_instantiate__trc__SetRecordingJobMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3474 */
#ifndef SOAP_TYPE__trc__SetRecordingJobModeResponse
#define SOAP_TYPE__trc__SetRecordingJobModeResponse (1170)
/* trc:SetRecordingJobModeResponse complex type: */
class SOAP_CMAC _trc__SetRecordingJobModeResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__SetRecordingJobModeResponse (1170)
	virtual int soap_type(void) const { return 1170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__SetRecordingJobModeResponse, default initialized and not managed by a soap context
	virtual _trc__SetRecordingJobModeResponse *soap_alloc(void) const { return SOAP_NEW(_trc__SetRecordingJobModeResponse); }
	         _trc__SetRecordingJobModeResponse() { _trc__SetRecordingJobModeResponse::soap_default(NULL); }
	virtual ~_trc__SetRecordingJobModeResponse() { }
	friend SOAP_FMAC1 _trc__SetRecordingJobModeResponse * SOAP_FMAC2 soap_instantiate__trc__SetRecordingJobModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3477 */
#ifndef SOAP_TYPE__trc__GetRecordingJobState
#define SOAP_TYPE__trc__GetRecordingJobState (1171)
/* trc:GetRecordingJobState complex type: */
class SOAP_CMAC _trc__GetRecordingJobState
{
public:
	char *JobToken;	/* required element of XSD type tt:RecordingJobReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobState (1171)
	virtual int soap_type(void) const { return 1171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobState, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobState *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobState); }
	         _trc__GetRecordingJobState() { _trc__GetRecordingJobState::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobState() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobState * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3480 */
#ifndef SOAP_TYPE__trc__GetRecordingJobStateResponse
#define SOAP_TYPE__trc__GetRecordingJobStateResponse (1172)
/* trc:GetRecordingJobStateResponse complex type: */
class SOAP_CMAC _trc__GetRecordingJobStateResponse
{
public:
	tt__RecordingJobStateInformation *State;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingJobStateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingJobStateResponse (1172)
	virtual int soap_type(void) const { return 1172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingJobStateResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingJobStateResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingJobStateResponse); }
	         _trc__GetRecordingJobStateResponse() { _trc__GetRecordingJobStateResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingJobStateResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingJobStateResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingJobStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3483 */
#ifndef SOAP_TYPE__trc__GetRecordingOptions
#define SOAP_TYPE__trc__GetRecordingOptions (1173)
/* trc:GetRecordingOptions complex type: */
class SOAP_CMAC _trc__GetRecordingOptions
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingOptions (1173)
	virtual int soap_type(void) const { return 1173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingOptions, default initialized and not managed by a soap context
	virtual _trc__GetRecordingOptions *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingOptions); }
	         _trc__GetRecordingOptions() { _trc__GetRecordingOptions::soap_default(NULL); }
	virtual ~_trc__GetRecordingOptions() { }
	friend SOAP_FMAC1 _trc__GetRecordingOptions * SOAP_FMAC2 soap_instantiate__trc__GetRecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3486 */
#ifndef SOAP_TYPE__trc__GetRecordingOptionsResponse
#define SOAP_TYPE__trc__GetRecordingOptionsResponse (1174)
/* trc:GetRecordingOptionsResponse complex type: */
class SOAP_CMAC _trc__GetRecordingOptionsResponse
{
public:
	trc__RecordingOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trc:RecordingOptions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trc__GetRecordingOptionsResponse (1174)
	virtual int soap_type(void) const { return 1174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trc__GetRecordingOptionsResponse, default initialized and not managed by a soap context
	virtual _trc__GetRecordingOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_trc__GetRecordingOptionsResponse); }
	         _trc__GetRecordingOptionsResponse() { _trc__GetRecordingOptionsResponse::soap_default(NULL); }
	virtual ~_trc__GetRecordingOptionsResponse() { }
	friend SOAP_FMAC1 _trc__GetRecordingOptionsResponse * SOAP_FMAC2 soap_instantiate__trc__GetRecordingOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3489 */
#ifndef SOAP_TYPE_tse__Capabilities
#define SOAP_TYPE_tse__Capabilities (1175)
/* Type tse__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tse:Capabilities complex type: */
class SOAP_CMAC tse__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *MetadataSearch;	/* optional attribute of XSD type xsd:boolean */
	bool *GeneralStartEvents;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tse__Capabilities (1175)
	virtual int soap_type(void) const { return 1175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tse__Capabilities, default initialized and not managed by a soap context
	virtual tse__Capabilities *soap_alloc(void) const { return SOAP_NEW(tse__Capabilities); }
	         tse__Capabilities() { tse__Capabilities::soap_default(NULL); }
	virtual ~tse__Capabilities() { }
	friend SOAP_FMAC1 tse__Capabilities * SOAP_FMAC2 soap_instantiate_tse__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3492 */
#ifndef SOAP_TYPE__tse__GetServiceCapabilities
#define SOAP_TYPE__tse__GetServiceCapabilities (1176)
/* tse:GetServiceCapabilities complex type: */
class SOAP_CMAC _tse__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetServiceCapabilities (1176)
	virtual int soap_type(void) const { return 1176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tse__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tse__GetServiceCapabilities); }
	         _tse__GetServiceCapabilities() { _tse__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tse__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tse__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tse__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3495 */
#ifndef SOAP_TYPE__tse__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tse__GetServiceCapabilitiesResponse (1177)
/* tse:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tse__GetServiceCapabilitiesResponse
{
public:
	tse__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tse:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetServiceCapabilitiesResponse (1177)
	virtual int soap_type(void) const { return 1177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tse__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetServiceCapabilitiesResponse); }
	         _tse__GetServiceCapabilitiesResponse() { _tse__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tse__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tse__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tse__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3498 */
#ifndef SOAP_TYPE__tse__GetRecordingSummary
#define SOAP_TYPE__tse__GetRecordingSummary (1178)
/* tse:GetRecordingSummary complex type: */
class SOAP_CMAC _tse__GetRecordingSummary
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSummary (1178)
	virtual int soap_type(void) const { return 1178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSummary, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSummary *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSummary); }
	         _tse__GetRecordingSummary() { _tse__GetRecordingSummary::soap_default(NULL); }
	virtual ~_tse__GetRecordingSummary() { }
	friend SOAP_FMAC1 _tse__GetRecordingSummary * SOAP_FMAC2 soap_instantiate__tse__GetRecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3501 */
#ifndef SOAP_TYPE__tse__GetRecordingSummaryResponse
#define SOAP_TYPE__tse__GetRecordingSummaryResponse (1179)
/* tse:GetRecordingSummaryResponse complex type: */
class SOAP_CMAC _tse__GetRecordingSummaryResponse
{
public:
	tt__RecordingSummary *Summary;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingSummary */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSummaryResponse (1179)
	virtual int soap_type(void) const { return 1179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSummaryResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSummaryResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSummaryResponse); }
	         _tse__GetRecordingSummaryResponse() { _tse__GetRecordingSummaryResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingSummaryResponse() { }
	friend SOAP_FMAC1 _tse__GetRecordingSummaryResponse * SOAP_FMAC2 soap_instantiate__tse__GetRecordingSummaryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3504 */
#ifndef SOAP_TYPE__tse__GetRecordingInformation
#define SOAP_TYPE__tse__GetRecordingInformation (1180)
/* tse:GetRecordingInformation complex type: */
class SOAP_CMAC _tse__GetRecordingInformation
{
public:
	char *RecordingToken;	/* required element of XSD type tt:RecordingReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingInformation (1180)
	virtual int soap_type(void) const { return 1180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingInformation, default initialized and not managed by a soap context
	virtual _tse__GetRecordingInformation *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingInformation); }
	         _tse__GetRecordingInformation() { _tse__GetRecordingInformation::soap_default(NULL); }
	virtual ~_tse__GetRecordingInformation() { }
	friend SOAP_FMAC1 _tse__GetRecordingInformation * SOAP_FMAC2 soap_instantiate__tse__GetRecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3507 */
#ifndef SOAP_TYPE__tse__GetRecordingInformationResponse
#define SOAP_TYPE__tse__GetRecordingInformationResponse (1181)
/* tse:GetRecordingInformationResponse complex type: */
class SOAP_CMAC _tse__GetRecordingInformationResponse
{
public:
	tt__RecordingInformation *RecordingInformation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:RecordingInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingInformationResponse (1181)
	virtual int soap_type(void) const { return 1181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingInformationResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingInformationResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingInformationResponse); }
	         _tse__GetRecordingInformationResponse() { _tse__GetRecordingInformationResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingInformationResponse() { }
	friend SOAP_FMAC1 _tse__GetRecordingInformationResponse * SOAP_FMAC2 soap_instantiate__tse__GetRecordingInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3510 */
#ifndef SOAP_TYPE__tse__GetMediaAttributes
#define SOAP_TYPE__tse__GetMediaAttributes (1182)
/* tse:GetMediaAttributes complex type: */
class SOAP_CMAC _tse__GetMediaAttributes
{
public:
	int __sizeRecordingTokens;	/* sequence of elements <RecordingTokens> of XSD type tt:RecordingReference */
	char **RecordingTokens;
	time_t Time;	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMediaAttributes (1182)
	virtual int soap_type(void) const { return 1182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMediaAttributes, default initialized and not managed by a soap context
	virtual _tse__GetMediaAttributes *soap_alloc(void) const { return SOAP_NEW(_tse__GetMediaAttributes); }
	         _tse__GetMediaAttributes() { _tse__GetMediaAttributes::soap_default(NULL); }
	virtual ~_tse__GetMediaAttributes() { }
	friend SOAP_FMAC1 _tse__GetMediaAttributes * SOAP_FMAC2 soap_instantiate__tse__GetMediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3513 */
#ifndef SOAP_TYPE__tse__GetMediaAttributesResponse
#define SOAP_TYPE__tse__GetMediaAttributesResponse (1183)
/* tse:GetMediaAttributesResponse complex type: */
class SOAP_CMAC _tse__GetMediaAttributesResponse
{
public:
	int __sizeMediaAttributes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <MediaAttributes> of XSD type tt:MediaAttributes */
	tt__MediaAttributes **MediaAttributes;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMediaAttributesResponse (1183)
	virtual int soap_type(void) const { return 1183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMediaAttributesResponse, default initialized and not managed by a soap context
	virtual _tse__GetMediaAttributesResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetMediaAttributesResponse); }
	         _tse__GetMediaAttributesResponse() { _tse__GetMediaAttributesResponse::soap_default(NULL); }
	virtual ~_tse__GetMediaAttributesResponse() { }
	friend SOAP_FMAC1 _tse__GetMediaAttributesResponse * SOAP_FMAC2 soap_instantiate__tse__GetMediaAttributesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3516 */
#ifndef SOAP_TYPE__tse__FindRecordings
#define SOAP_TYPE__tse__FindRecordings (1184)
/* tse:FindRecordings complex type: */
class SOAP_CMAC _tse__FindRecordings
{
public:
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindRecordings (1184)
	virtual int soap_type(void) const { return 1184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindRecordings, default initialized and not managed by a soap context
	virtual _tse__FindRecordings *soap_alloc(void) const { return SOAP_NEW(_tse__FindRecordings); }
	         _tse__FindRecordings() { _tse__FindRecordings::soap_default(NULL); }
	virtual ~_tse__FindRecordings() { }
	friend SOAP_FMAC1 _tse__FindRecordings * SOAP_FMAC2 soap_instantiate__tse__FindRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3519 */
#ifndef SOAP_TYPE__tse__FindRecordingsResponse
#define SOAP_TYPE__tse__FindRecordingsResponse (1185)
/* tse:FindRecordingsResponse complex type: */
class SOAP_CMAC _tse__FindRecordingsResponse
{
public:
	char *SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindRecordingsResponse (1185)
	virtual int soap_type(void) const { return 1185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindRecordingsResponse, default initialized and not managed by a soap context
	virtual _tse__FindRecordingsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindRecordingsResponse); }
	         _tse__FindRecordingsResponse() { _tse__FindRecordingsResponse::soap_default(NULL); }
	virtual ~_tse__FindRecordingsResponse() { }
	friend SOAP_FMAC1 _tse__FindRecordingsResponse * SOAP_FMAC2 soap_instantiate__tse__FindRecordingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3522 */
#ifndef SOAP_TYPE__tse__GetRecordingSearchResults
#define SOAP_TYPE__tse__GetRecordingSearchResults (1186)
/* tse:GetRecordingSearchResults complex type: */
class SOAP_CMAC _tse__GetRecordingSearchResults
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSearchResults (1186)
	virtual int soap_type(void) const { return 1186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSearchResults); }
	         _tse__GetRecordingSearchResults() { _tse__GetRecordingSearchResults::soap_default(NULL); }
	virtual ~_tse__GetRecordingSearchResults() { }
	friend SOAP_FMAC1 _tse__GetRecordingSearchResults * SOAP_FMAC2 soap_instantiate__tse__GetRecordingSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3525 */
#ifndef SOAP_TYPE__tse__GetRecordingSearchResultsResponse
#define SOAP_TYPE__tse__GetRecordingSearchResultsResponse (1187)
/* tse:GetRecordingSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetRecordingSearchResultsResponse
{
public:
	tt__FindRecordingResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindRecordingResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetRecordingSearchResultsResponse (1187)
	virtual int soap_type(void) const { return 1187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetRecordingSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetRecordingSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetRecordingSearchResultsResponse); }
	         _tse__GetRecordingSearchResultsResponse() { _tse__GetRecordingSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetRecordingSearchResultsResponse() { }
	friend SOAP_FMAC1 _tse__GetRecordingSearchResultsResponse * SOAP_FMAC2 soap_instantiate__tse__GetRecordingSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3528 */
#ifndef SOAP_TYPE__tse__FindEvents
#define SOAP_TYPE__tse__FindEvents (1188)
/* tse:FindEvents complex type: */
class SOAP_CMAC _tse__FindEvents
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__EventFilter *SearchFilter;	/* required element of XSD type tt:EventFilter */
	bool IncludeStartState;	/* required element of XSD type xsd:boolean */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindEvents (1188)
	virtual int soap_type(void) const { return 1188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindEvents, default initialized and not managed by a soap context
	virtual _tse__FindEvents *soap_alloc(void) const { return SOAP_NEW(_tse__FindEvents); }
	         _tse__FindEvents() { _tse__FindEvents::soap_default(NULL); }
	virtual ~_tse__FindEvents() { }
	friend SOAP_FMAC1 _tse__FindEvents * SOAP_FMAC2 soap_instantiate__tse__FindEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3531 */
#ifndef SOAP_TYPE__tse__FindEventsResponse
#define SOAP_TYPE__tse__FindEventsResponse (1189)
/* tse:FindEventsResponse complex type: */
class SOAP_CMAC _tse__FindEventsResponse
{
public:
	char *SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindEventsResponse (1189)
	virtual int soap_type(void) const { return 1189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindEventsResponse, default initialized and not managed by a soap context
	virtual _tse__FindEventsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindEventsResponse); }
	         _tse__FindEventsResponse() { _tse__FindEventsResponse::soap_default(NULL); }
	virtual ~_tse__FindEventsResponse() { }
	friend SOAP_FMAC1 _tse__FindEventsResponse * SOAP_FMAC2 soap_instantiate__tse__FindEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3534 */
#ifndef SOAP_TYPE__tse__GetEventSearchResults
#define SOAP_TYPE__tse__GetEventSearchResults (1190)
/* tse:GetEventSearchResults complex type: */
class SOAP_CMAC _tse__GetEventSearchResults
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetEventSearchResults (1190)
	virtual int soap_type(void) const { return 1190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetEventSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetEventSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetEventSearchResults); }
	         _tse__GetEventSearchResults() { _tse__GetEventSearchResults::soap_default(NULL); }
	virtual ~_tse__GetEventSearchResults() { }
	friend SOAP_FMAC1 _tse__GetEventSearchResults * SOAP_FMAC2 soap_instantiate__tse__GetEventSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3537 */
#ifndef SOAP_TYPE__tse__GetEventSearchResultsResponse
#define SOAP_TYPE__tse__GetEventSearchResultsResponse (1191)
/* tse:GetEventSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetEventSearchResultsResponse
{
public:
	tt__FindEventResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindEventResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetEventSearchResultsResponse (1191)
	virtual int soap_type(void) const { return 1191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetEventSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetEventSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetEventSearchResultsResponse); }
	         _tse__GetEventSearchResultsResponse() { _tse__GetEventSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetEventSearchResultsResponse() { }
	friend SOAP_FMAC1 _tse__GetEventSearchResultsResponse * SOAP_FMAC2 soap_instantiate__tse__GetEventSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3540 */
#ifndef SOAP_TYPE__tse__FindPTZPosition
#define SOAP_TYPE__tse__FindPTZPosition (1192)
/* tse:FindPTZPosition complex type: */
class SOAP_CMAC _tse__FindPTZPosition
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__PTZPositionFilter *SearchFilter;	/* required element of XSD type tt:PTZPositionFilter */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindPTZPosition (1192)
	virtual int soap_type(void) const { return 1192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindPTZPosition, default initialized and not managed by a soap context
	virtual _tse__FindPTZPosition *soap_alloc(void) const { return SOAP_NEW(_tse__FindPTZPosition); }
	         _tse__FindPTZPosition() { _tse__FindPTZPosition::soap_default(NULL); }
	virtual ~_tse__FindPTZPosition() { }
	friend SOAP_FMAC1 _tse__FindPTZPosition * SOAP_FMAC2 soap_instantiate__tse__FindPTZPosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3543 */
#ifndef SOAP_TYPE__tse__FindPTZPositionResponse
#define SOAP_TYPE__tse__FindPTZPositionResponse (1193)
/* tse:FindPTZPositionResponse complex type: */
class SOAP_CMAC _tse__FindPTZPositionResponse
{
public:
	char *SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindPTZPositionResponse (1193)
	virtual int soap_type(void) const { return 1193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindPTZPositionResponse, default initialized and not managed by a soap context
	virtual _tse__FindPTZPositionResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindPTZPositionResponse); }
	         _tse__FindPTZPositionResponse() { _tse__FindPTZPositionResponse::soap_default(NULL); }
	virtual ~_tse__FindPTZPositionResponse() { }
	friend SOAP_FMAC1 _tse__FindPTZPositionResponse * SOAP_FMAC2 soap_instantiate__tse__FindPTZPositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3546 */
#ifndef SOAP_TYPE__tse__GetPTZPositionSearchResults
#define SOAP_TYPE__tse__GetPTZPositionSearchResults (1194)
/* tse:GetPTZPositionSearchResults complex type: */
class SOAP_CMAC _tse__GetPTZPositionSearchResults
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetPTZPositionSearchResults (1194)
	virtual int soap_type(void) const { return 1194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetPTZPositionSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetPTZPositionSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetPTZPositionSearchResults); }
	         _tse__GetPTZPositionSearchResults() { _tse__GetPTZPositionSearchResults::soap_default(NULL); }
	virtual ~_tse__GetPTZPositionSearchResults() { }
	friend SOAP_FMAC1 _tse__GetPTZPositionSearchResults * SOAP_FMAC2 soap_instantiate__tse__GetPTZPositionSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3549 */
#ifndef SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse
#define SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse (1195)
/* tse:GetPTZPositionSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetPTZPositionSearchResultsResponse
{
public:
	tt__FindPTZPositionResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindPTZPositionResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse (1195)
	virtual int soap_type(void) const { return 1195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetPTZPositionSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetPTZPositionSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetPTZPositionSearchResultsResponse); }
	         _tse__GetPTZPositionSearchResultsResponse() { _tse__GetPTZPositionSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetPTZPositionSearchResultsResponse() { }
	friend SOAP_FMAC1 _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC2 soap_instantiate__tse__GetPTZPositionSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3552 */
#ifndef SOAP_TYPE__tse__FindMetadata
#define SOAP_TYPE__tse__FindMetadata (1196)
/* tse:FindMetadata complex type: */
class SOAP_CMAC _tse__FindMetadata
{
public:
	time_t StartPoint;	/* required element of XSD type xsd:dateTime */
	time_t *EndPoint;	/* optional element of XSD type xsd:dateTime */
	tt__SearchScope *Scope;	/* required element of XSD type tt:SearchScope */
	tt__MetadataFilter *MetadataFilter;	/* required element of XSD type tt:MetadataFilter */
	int *MaxMatches;	/* optional element of XSD type xsd:int */
	LONG64 KeepAliveTime;	/* external (custom serializer) */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindMetadata (1196)
	virtual int soap_type(void) const { return 1196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindMetadata, default initialized and not managed by a soap context
	virtual _tse__FindMetadata *soap_alloc(void) const { return SOAP_NEW(_tse__FindMetadata); }
	         _tse__FindMetadata() { _tse__FindMetadata::soap_default(NULL); }
	virtual ~_tse__FindMetadata() { }
	friend SOAP_FMAC1 _tse__FindMetadata * SOAP_FMAC2 soap_instantiate__tse__FindMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3555 */
#ifndef SOAP_TYPE__tse__FindMetadataResponse
#define SOAP_TYPE__tse__FindMetadataResponse (1197)
/* tse:FindMetadataResponse complex type: */
class SOAP_CMAC _tse__FindMetadataResponse
{
public:
	char *SearchToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__FindMetadataResponse (1197)
	virtual int soap_type(void) const { return 1197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__FindMetadataResponse, default initialized and not managed by a soap context
	virtual _tse__FindMetadataResponse *soap_alloc(void) const { return SOAP_NEW(_tse__FindMetadataResponse); }
	         _tse__FindMetadataResponse() { _tse__FindMetadataResponse::soap_default(NULL); }
	virtual ~_tse__FindMetadataResponse() { }
	friend SOAP_FMAC1 _tse__FindMetadataResponse * SOAP_FMAC2 soap_instantiate__tse__FindMetadataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3558 */
#ifndef SOAP_TYPE__tse__GetMetadataSearchResults
#define SOAP_TYPE__tse__GetMetadataSearchResults (1198)
/* tse:GetMetadataSearchResults complex type: */
class SOAP_CMAC _tse__GetMetadataSearchResults
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	int *MinResults;	/* optional element of XSD type xsd:int */
	int *MaxResults;	/* optional element of XSD type xsd:int */
	LONG64 *WaitTime;	/* optional element of XSD type xsd:duration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMetadataSearchResults (1198)
	virtual int soap_type(void) const { return 1198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMetadataSearchResults, default initialized and not managed by a soap context
	virtual _tse__GetMetadataSearchResults *soap_alloc(void) const { return SOAP_NEW(_tse__GetMetadataSearchResults); }
	         _tse__GetMetadataSearchResults() { _tse__GetMetadataSearchResults::soap_default(NULL); }
	virtual ~_tse__GetMetadataSearchResults() { }
	friend SOAP_FMAC1 _tse__GetMetadataSearchResults * SOAP_FMAC2 soap_instantiate__tse__GetMetadataSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3561 */
#ifndef SOAP_TYPE__tse__GetMetadataSearchResultsResponse
#define SOAP_TYPE__tse__GetMetadataSearchResultsResponse (1199)
/* tse:GetMetadataSearchResultsResponse complex type: */
class SOAP_CMAC _tse__GetMetadataSearchResultsResponse
{
public:
	tt__FindMetadataResultList *ResultList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:FindMetadataResultList */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetMetadataSearchResultsResponse (1199)
	virtual int soap_type(void) const { return 1199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetMetadataSearchResultsResponse, default initialized and not managed by a soap context
	virtual _tse__GetMetadataSearchResultsResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetMetadataSearchResultsResponse); }
	         _tse__GetMetadataSearchResultsResponse() { _tse__GetMetadataSearchResultsResponse::soap_default(NULL); }
	virtual ~_tse__GetMetadataSearchResultsResponse() { }
	friend SOAP_FMAC1 _tse__GetMetadataSearchResultsResponse * SOAP_FMAC2 soap_instantiate__tse__GetMetadataSearchResultsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3564 */
#ifndef SOAP_TYPE__tse__GetSearchState
#define SOAP_TYPE__tse__GetSearchState (1200)
/* tse:GetSearchState complex type: */
class SOAP_CMAC _tse__GetSearchState
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetSearchState (1200)
	virtual int soap_type(void) const { return 1200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetSearchState, default initialized and not managed by a soap context
	virtual _tse__GetSearchState *soap_alloc(void) const { return SOAP_NEW(_tse__GetSearchState); }
	         _tse__GetSearchState() { _tse__GetSearchState::soap_default(NULL); }
	virtual ~_tse__GetSearchState() { }
	friend SOAP_FMAC1 _tse__GetSearchState * SOAP_FMAC2 soap_instantiate__tse__GetSearchState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3567 */
#ifndef SOAP_TYPE__tse__GetSearchStateResponse
#define SOAP_TYPE__tse__GetSearchStateResponse (1201)
/* tse:GetSearchStateResponse complex type: */
class SOAP_CMAC _tse__GetSearchStateResponse
{
public:
	enum tt__SearchState State;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SearchState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__GetSearchStateResponse (1201)
	virtual int soap_type(void) const { return 1201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__GetSearchStateResponse, default initialized and not managed by a soap context
	virtual _tse__GetSearchStateResponse *soap_alloc(void) const { return SOAP_NEW(_tse__GetSearchStateResponse); }
	         _tse__GetSearchStateResponse() { _tse__GetSearchStateResponse::soap_default(NULL); }
	virtual ~_tse__GetSearchStateResponse() { }
	friend SOAP_FMAC1 _tse__GetSearchStateResponse * SOAP_FMAC2 soap_instantiate__tse__GetSearchStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3570 */
#ifndef SOAP_TYPE__tse__EndSearch
#define SOAP_TYPE__tse__EndSearch (1202)
/* tse:EndSearch complex type: */
class SOAP_CMAC _tse__EndSearch
{
public:
	char *SearchToken;	/* required element of XSD type tt:JobToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__EndSearch (1202)
	virtual int soap_type(void) const { return 1202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__EndSearch, default initialized and not managed by a soap context
	virtual _tse__EndSearch *soap_alloc(void) const { return SOAP_NEW(_tse__EndSearch); }
	         _tse__EndSearch() { _tse__EndSearch::soap_default(NULL); }
	virtual ~_tse__EndSearch() { }
	friend SOAP_FMAC1 _tse__EndSearch * SOAP_FMAC2 soap_instantiate__tse__EndSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3573 */
#ifndef SOAP_TYPE__tse__EndSearchResponse
#define SOAP_TYPE__tse__EndSearchResponse (1203)
/* tse:EndSearchResponse complex type: */
class SOAP_CMAC _tse__EndSearchResponse
{
public:
	time_t Endpoint;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tse__EndSearchResponse (1203)
	virtual int soap_type(void) const { return 1203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tse__EndSearchResponse, default initialized and not managed by a soap context
	virtual _tse__EndSearchResponse *soap_alloc(void) const { return SOAP_NEW(_tse__EndSearchResponse); }
	         _tse__EndSearchResponse() { _tse__EndSearchResponse::soap_default(NULL); }
	virtual ~_tse__EndSearchResponse() { }
	friend SOAP_FMAC1 _tse__EndSearchResponse * SOAP_FMAC2 soap_instantiate__tse__EndSearchResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3576 */
#ifndef SOAP_TYPE_trp__Capabilities
#define SOAP_TYPE_trp__Capabilities (1204)
/* Type trp__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* trp:Capabilities complex type: */
class SOAP_CMAC trp__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool ReversePlayback;	/* optional attribute of XSD type xsd:boolean */
	char *SessionTimeoutRange;	/* optional attribute of XSD type tt:FloatAttrList */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_trp__Capabilities (1204)
	virtual int soap_type(void) const { return 1204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type trp__Capabilities, default initialized and not managed by a soap context
	virtual trp__Capabilities *soap_alloc(void) const { return SOAP_NEW(trp__Capabilities); }
	         trp__Capabilities() { trp__Capabilities::soap_default(NULL); }
	virtual ~trp__Capabilities() { }
	friend SOAP_FMAC1 trp__Capabilities * SOAP_FMAC2 soap_instantiate_trp__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3579 */
#ifndef SOAP_TYPE__trp__GetServiceCapabilities
#define SOAP_TYPE__trp__GetServiceCapabilities (1205)
/* trp:GetServiceCapabilities complex type: */
class SOAP_CMAC _trp__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetServiceCapabilities (1205)
	virtual int soap_type(void) const { return 1205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _trp__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_trp__GetServiceCapabilities); }
	         _trp__GetServiceCapabilities() { _trp__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_trp__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _trp__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trp__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3582 */
#ifndef SOAP_TYPE__trp__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trp__GetServiceCapabilitiesResponse (1206)
/* trp:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _trp__GetServiceCapabilitiesResponse
{
public:
	trp__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type trp:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetServiceCapabilitiesResponse (1206)
	virtual int soap_type(void) const { return 1206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _trp__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetServiceCapabilitiesResponse); }
	         _trp__GetServiceCapabilitiesResponse() { _trp__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_trp__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _trp__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trp__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3585 */
#ifndef SOAP_TYPE__trp__GetReplayUri
#define SOAP_TYPE__trp__GetReplayUri (1207)
/* trp:GetReplayUri complex type: */
class SOAP_CMAC _trp__GetReplayUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	char *RecordingToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayUri (1207)
	virtual int soap_type(void) const { return 1207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayUri, default initialized and not managed by a soap context
	virtual _trp__GetReplayUri *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayUri); }
	         _trp__GetReplayUri() { _trp__GetReplayUri::soap_default(NULL); }
	virtual ~_trp__GetReplayUri() { }
	friend SOAP_FMAC1 _trp__GetReplayUri * SOAP_FMAC2 soap_instantiate__trp__GetReplayUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3588 */
#ifndef SOAP_TYPE__trp__GetReplayUriResponse
#define SOAP_TYPE__trp__GetReplayUriResponse (1208)
/* trp:GetReplayUriResponse complex type: */
class SOAP_CMAC _trp__GetReplayUriResponse
{
public:
	char *Uri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayUriResponse (1208)
	virtual int soap_type(void) const { return 1208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayUriResponse, default initialized and not managed by a soap context
	virtual _trp__GetReplayUriResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayUriResponse); }
	         _trp__GetReplayUriResponse() { _trp__GetReplayUriResponse::soap_default(NULL); }
	virtual ~_trp__GetReplayUriResponse() { }
	friend SOAP_FMAC1 _trp__GetReplayUriResponse * SOAP_FMAC2 soap_instantiate__trp__GetReplayUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3591 */
#ifndef SOAP_TYPE__trp__SetReplayConfiguration
#define SOAP_TYPE__trp__SetReplayConfiguration (1209)
/* trp:SetReplayConfiguration complex type: */
class SOAP_CMAC _trp__SetReplayConfiguration
{
public:
	tt__ReplayConfiguration *Configuration;	/* required element of XSD type tt:ReplayConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__SetReplayConfiguration (1209)
	virtual int soap_type(void) const { return 1209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__SetReplayConfiguration, default initialized and not managed by a soap context
	virtual _trp__SetReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(_trp__SetReplayConfiguration); }
	         _trp__SetReplayConfiguration() { _trp__SetReplayConfiguration::soap_default(NULL); }
	virtual ~_trp__SetReplayConfiguration() { }
	friend SOAP_FMAC1 _trp__SetReplayConfiguration * SOAP_FMAC2 soap_instantiate__trp__SetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3594 */
#ifndef SOAP_TYPE__trp__SetReplayConfigurationResponse
#define SOAP_TYPE__trp__SetReplayConfigurationResponse (1210)
/* trp:SetReplayConfigurationResponse complex type: */
class SOAP_CMAC _trp__SetReplayConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__SetReplayConfigurationResponse (1210)
	virtual int soap_type(void) const { return 1210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__SetReplayConfigurationResponse, default initialized and not managed by a soap context
	virtual _trp__SetReplayConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trp__SetReplayConfigurationResponse); }
	         _trp__SetReplayConfigurationResponse() { _trp__SetReplayConfigurationResponse::soap_default(NULL); }
	virtual ~_trp__SetReplayConfigurationResponse() { }
	friend SOAP_FMAC1 _trp__SetReplayConfigurationResponse * SOAP_FMAC2 soap_instantiate__trp__SetReplayConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3597 */
#ifndef SOAP_TYPE__trp__GetReplayConfiguration
#define SOAP_TYPE__trp__GetReplayConfiguration (1211)
/* trp:GetReplayConfiguration complex type: */
class SOAP_CMAC _trp__GetReplayConfiguration
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayConfiguration (1211)
	virtual int soap_type(void) const { return 1211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayConfiguration, default initialized and not managed by a soap context
	virtual _trp__GetReplayConfiguration *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayConfiguration); }
	         _trp__GetReplayConfiguration() { _trp__GetReplayConfiguration::soap_default(NULL); }
	virtual ~_trp__GetReplayConfiguration() { }
	friend SOAP_FMAC1 _trp__GetReplayConfiguration * SOAP_FMAC2 soap_instantiate__trp__GetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3600 */
#ifndef SOAP_TYPE__trp__GetReplayConfigurationResponse
#define SOAP_TYPE__trp__GetReplayConfigurationResponse (1212)
/* trp:GetReplayConfigurationResponse complex type: */
class SOAP_CMAC _trp__GetReplayConfigurationResponse
{
public:
	tt__ReplayConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:ReplayConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__trp__GetReplayConfigurationResponse (1212)
	virtual int soap_type(void) const { return 1212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _trp__GetReplayConfigurationResponse, default initialized and not managed by a soap context
	virtual _trp__GetReplayConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_trp__GetReplayConfigurationResponse); }
	         _trp__GetReplayConfigurationResponse() { _trp__GetReplayConfigurationResponse::soap_default(NULL); }
	virtual ~_trp__GetReplayConfigurationResponse() { }
	friend SOAP_FMAC1 _trp__GetReplayConfigurationResponse * SOAP_FMAC2 soap_instantiate__trp__GetReplayConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3603 */
#ifndef SOAP_TYPE_tan__Capabilities
#define SOAP_TYPE_tan__Capabilities (1213)
/* Type tan__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tan:Capabilities complex type: */
class SOAP_CMAC tan__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *RuleSupport;	/* optional attribute of XSD type xsd:boolean */
	bool *AnalyticsModuleSupport;	/* optional attribute of XSD type xsd:boolean */
	bool *CellBasedSceneDescriptionSupported;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tan__Capabilities (1213)
	virtual int soap_type(void) const { return 1213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tan__Capabilities, default initialized and not managed by a soap context
	virtual tan__Capabilities *soap_alloc(void) const { return SOAP_NEW(tan__Capabilities); }
	         tan__Capabilities() { tan__Capabilities::soap_default(NULL); }
	virtual ~tan__Capabilities() { }
	friend SOAP_FMAC1 tan__Capabilities * SOAP_FMAC2 soap_instantiate_tan__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3606 */
#ifndef SOAP_TYPE__tan__GetServiceCapabilities
#define SOAP_TYPE__tan__GetServiceCapabilities (1214)
/* tan:GetServiceCapabilities complex type: */
class SOAP_CMAC _tan__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetServiceCapabilities (1214)
	virtual int soap_type(void) const { return 1214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tan__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tan__GetServiceCapabilities); }
	         _tan__GetServiceCapabilities() { _tan__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tan__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tan__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tan__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3609 */
#ifndef SOAP_TYPE__tan__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tan__GetServiceCapabilitiesResponse (1215)
/* tan:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tan__GetServiceCapabilitiesResponse
{
public:
	tan__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tan:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetServiceCapabilitiesResponse (1215)
	virtual int soap_type(void) const { return 1215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tan__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__GetServiceCapabilitiesResponse); }
	         _tan__GetServiceCapabilitiesResponse() { _tan__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tan__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tan__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tan__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3612 */
#ifndef SOAP_TYPE__tan__GetSupportedRules
#define SOAP_TYPE__tan__GetSupportedRules (1216)
/* tan:GetSupportedRules complex type: */
class SOAP_CMAC _tan__GetSupportedRules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetSupportedRules (1216)
	virtual int soap_type(void) const { return 1216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetSupportedRules, default initialized and not managed by a soap context
	virtual _tan__GetSupportedRules *soap_alloc(void) const { return SOAP_NEW(_tan__GetSupportedRules); }
	         _tan__GetSupportedRules() { _tan__GetSupportedRules::soap_default(NULL); }
	virtual ~_tan__GetSupportedRules() { }
	friend SOAP_FMAC1 _tan__GetSupportedRules * SOAP_FMAC2 soap_instantiate__tan__GetSupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3615 */
#ifndef SOAP_TYPE__tan__GetSupportedRulesResponse
#define SOAP_TYPE__tan__GetSupportedRulesResponse (1217)
/* tan:GetSupportedRulesResponse complex type: */
class SOAP_CMAC _tan__GetSupportedRulesResponse
{
public:
	tt__SupportedRules *SupportedRules;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportedRules */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetSupportedRulesResponse (1217)
	virtual int soap_type(void) const { return 1217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetSupportedRulesResponse, default initialized and not managed by a soap context
	virtual _tan__GetSupportedRulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__GetSupportedRulesResponse); }
	         _tan__GetSupportedRulesResponse() { _tan__GetSupportedRulesResponse::soap_default(NULL); }
	virtual ~_tan__GetSupportedRulesResponse() { }
	friend SOAP_FMAC1 _tan__GetSupportedRulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetSupportedRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3618 */
#ifndef SOAP_TYPE__tan__CreateRules
#define SOAP_TYPE__tan__CreateRules (1218)
/* tan:CreateRules complex type: */
class SOAP_CMAC _tan__CreateRules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeRule;	/* sequence of elements <Rule> of XSD type tt:Config */
	tt__Config **Rule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__CreateRules (1218)
	virtual int soap_type(void) const { return 1218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__CreateRules, default initialized and not managed by a soap context
	virtual _tan__CreateRules *soap_alloc(void) const { return SOAP_NEW(_tan__CreateRules); }
	         _tan__CreateRules() { _tan__CreateRules::soap_default(NULL); }
	virtual ~_tan__CreateRules() { }
	friend SOAP_FMAC1 _tan__CreateRules * SOAP_FMAC2 soap_instantiate__tan__CreateRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3621 */
#ifndef SOAP_TYPE__tan__CreateRulesResponse
#define SOAP_TYPE__tan__CreateRulesResponse (1219)
/* tan:CreateRulesResponse complex type: */
class SOAP_CMAC _tan__CreateRulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__CreateRulesResponse (1219)
	virtual int soap_type(void) const { return 1219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__CreateRulesResponse, default initialized and not managed by a soap context
	virtual _tan__CreateRulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__CreateRulesResponse); }
	         _tan__CreateRulesResponse() { _tan__CreateRulesResponse::soap_default(NULL); }
	virtual ~_tan__CreateRulesResponse() { }
	friend SOAP_FMAC1 _tan__CreateRulesResponse * SOAP_FMAC2 soap_instantiate__tan__CreateRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3624 */
#ifndef SOAP_TYPE__tan__DeleteRules
#define SOAP_TYPE__tan__DeleteRules (1220)
/* tan:DeleteRules complex type: */
class SOAP_CMAC _tan__DeleteRules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeRuleName;	/* sequence of elements <RuleName> of XSD type xsd:string */
	char **RuleName;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__DeleteRules (1220)
	virtual int soap_type(void) const { return 1220; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__DeleteRules, default initialized and not managed by a soap context
	virtual _tan__DeleteRules *soap_alloc(void) const { return SOAP_NEW(_tan__DeleteRules); }
	         _tan__DeleteRules() { _tan__DeleteRules::soap_default(NULL); }
	virtual ~_tan__DeleteRules() { }
	friend SOAP_FMAC1 _tan__DeleteRules * SOAP_FMAC2 soap_instantiate__tan__DeleteRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3627 */
#ifndef SOAP_TYPE__tan__DeleteRulesResponse
#define SOAP_TYPE__tan__DeleteRulesResponse (1221)
/* tan:DeleteRulesResponse complex type: */
class SOAP_CMAC _tan__DeleteRulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__DeleteRulesResponse (1221)
	virtual int soap_type(void) const { return 1221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__DeleteRulesResponse, default initialized and not managed by a soap context
	virtual _tan__DeleteRulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__DeleteRulesResponse); }
	         _tan__DeleteRulesResponse() { _tan__DeleteRulesResponse::soap_default(NULL); }
	virtual ~_tan__DeleteRulesResponse() { }
	friend SOAP_FMAC1 _tan__DeleteRulesResponse * SOAP_FMAC2 soap_instantiate__tan__DeleteRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3630 */
#ifndef SOAP_TYPE__tan__ModifyRules
#define SOAP_TYPE__tan__ModifyRules (1222)
/* tan:ModifyRules complex type: */
class SOAP_CMAC _tan__ModifyRules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeRule;	/* sequence of elements <Rule> of XSD type tt:Config */
	tt__Config **Rule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__ModifyRules (1222)
	virtual int soap_type(void) const { return 1222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__ModifyRules, default initialized and not managed by a soap context
	virtual _tan__ModifyRules *soap_alloc(void) const { return SOAP_NEW(_tan__ModifyRules); }
	         _tan__ModifyRules() { _tan__ModifyRules::soap_default(NULL); }
	virtual ~_tan__ModifyRules() { }
	friend SOAP_FMAC1 _tan__ModifyRules * SOAP_FMAC2 soap_instantiate__tan__ModifyRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3633 */
#ifndef SOAP_TYPE__tan__ModifyRulesResponse
#define SOAP_TYPE__tan__ModifyRulesResponse (1223)
/* tan:ModifyRulesResponse complex type: */
class SOAP_CMAC _tan__ModifyRulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__ModifyRulesResponse (1223)
	virtual int soap_type(void) const { return 1223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__ModifyRulesResponse, default initialized and not managed by a soap context
	virtual _tan__ModifyRulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__ModifyRulesResponse); }
	         _tan__ModifyRulesResponse() { _tan__ModifyRulesResponse::soap_default(NULL); }
	virtual ~_tan__ModifyRulesResponse() { }
	friend SOAP_FMAC1 _tan__ModifyRulesResponse * SOAP_FMAC2 soap_instantiate__tan__ModifyRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3636 */
#ifndef SOAP_TYPE__tan__GetRules
#define SOAP_TYPE__tan__GetRules (1224)
/* tan:GetRules complex type: */
class SOAP_CMAC _tan__GetRules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetRules (1224)
	virtual int soap_type(void) const { return 1224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetRules, default initialized and not managed by a soap context
	virtual _tan__GetRules *soap_alloc(void) const { return SOAP_NEW(_tan__GetRules); }
	         _tan__GetRules() { _tan__GetRules::soap_default(NULL); }
	virtual ~_tan__GetRules() { }
	friend SOAP_FMAC1 _tan__GetRules * SOAP_FMAC2 soap_instantiate__tan__GetRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3639 */
#ifndef SOAP_TYPE__tan__GetRulesResponse
#define SOAP_TYPE__tan__GetRulesResponse (1225)
/* tan:GetRulesResponse complex type: */
class SOAP_CMAC _tan__GetRulesResponse
{
public:
	int __sizeRule;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Rule> of XSD type tt:Config */
	tt__Config **Rule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetRulesResponse (1225)
	virtual int soap_type(void) const { return 1225; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetRulesResponse, default initialized and not managed by a soap context
	virtual _tan__GetRulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__GetRulesResponse); }
	         _tan__GetRulesResponse() { _tan__GetRulesResponse::soap_default(NULL); }
	virtual ~_tan__GetRulesResponse() { }
	friend SOAP_FMAC1 _tan__GetRulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3642 */
#ifndef SOAP_TYPE__tan__GetSupportedAnalyticsModules
#define SOAP_TYPE__tan__GetSupportedAnalyticsModules (1226)
/* tan:GetSupportedAnalyticsModules complex type: */
class SOAP_CMAC _tan__GetSupportedAnalyticsModules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetSupportedAnalyticsModules (1226)
	virtual int soap_type(void) const { return 1226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetSupportedAnalyticsModules, default initialized and not managed by a soap context
	virtual _tan__GetSupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(_tan__GetSupportedAnalyticsModules); }
	         _tan__GetSupportedAnalyticsModules() { _tan__GetSupportedAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__GetSupportedAnalyticsModules() { }
	friend SOAP_FMAC1 _tan__GetSupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__GetSupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3645 */
#ifndef SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse
#define SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse (1227)
/* tan:GetSupportedAnalyticsModulesResponse complex type: */
class SOAP_CMAC _tan__GetSupportedAnalyticsModulesResponse
{
public:
	tt__SupportedAnalyticsModules *SupportedAnalyticsModules;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:SupportedAnalyticsModules */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse (1227)
	virtual int soap_type(void) const { return 1227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetSupportedAnalyticsModulesResponse, default initialized and not managed by a soap context
	virtual _tan__GetSupportedAnalyticsModulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__GetSupportedAnalyticsModulesResponse); }
	         _tan__GetSupportedAnalyticsModulesResponse() { _tan__GetSupportedAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__GetSupportedAnalyticsModulesResponse() { }
	friend SOAP_FMAC1 _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetSupportedAnalyticsModulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3648 */
#ifndef SOAP_TYPE__tan__CreateAnalyticsModules
#define SOAP_TYPE__tan__CreateAnalyticsModules (1228)
/* tan:CreateAnalyticsModules complex type: */
class SOAP_CMAC _tan__CreateAnalyticsModules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeAnalyticsModule;	/* sequence of elements <AnalyticsModule> of XSD type tt:Config */
	tt__Config **AnalyticsModule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__CreateAnalyticsModules (1228)
	virtual int soap_type(void) const { return 1228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__CreateAnalyticsModules, default initialized and not managed by a soap context
	virtual _tan__CreateAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(_tan__CreateAnalyticsModules); }
	         _tan__CreateAnalyticsModules() { _tan__CreateAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__CreateAnalyticsModules() { }
	friend SOAP_FMAC1 _tan__CreateAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__CreateAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3651 */
#ifndef SOAP_TYPE__tan__CreateAnalyticsModulesResponse
#define SOAP_TYPE__tan__CreateAnalyticsModulesResponse (1229)
/* tan:CreateAnalyticsModulesResponse complex type: */
class SOAP_CMAC _tan__CreateAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__CreateAnalyticsModulesResponse (1229)
	virtual int soap_type(void) const { return 1229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__CreateAnalyticsModulesResponse, default initialized and not managed by a soap context
	virtual _tan__CreateAnalyticsModulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__CreateAnalyticsModulesResponse); }
	         _tan__CreateAnalyticsModulesResponse() { _tan__CreateAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__CreateAnalyticsModulesResponse() { }
	friend SOAP_FMAC1 _tan__CreateAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__CreateAnalyticsModulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3654 */
#ifndef SOAP_TYPE__tan__DeleteAnalyticsModules
#define SOAP_TYPE__tan__DeleteAnalyticsModules (1230)
/* tan:DeleteAnalyticsModules complex type: */
class SOAP_CMAC _tan__DeleteAnalyticsModules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeAnalyticsModuleName;	/* sequence of elements <AnalyticsModuleName> of XSD type xsd:string */
	char **AnalyticsModuleName;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__DeleteAnalyticsModules (1230)
	virtual int soap_type(void) const { return 1230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__DeleteAnalyticsModules, default initialized and not managed by a soap context
	virtual _tan__DeleteAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(_tan__DeleteAnalyticsModules); }
	         _tan__DeleteAnalyticsModules() { _tan__DeleteAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__DeleteAnalyticsModules() { }
	friend SOAP_FMAC1 _tan__DeleteAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__DeleteAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3657 */
#ifndef SOAP_TYPE__tan__DeleteAnalyticsModulesResponse
#define SOAP_TYPE__tan__DeleteAnalyticsModulesResponse (1231)
/* tan:DeleteAnalyticsModulesResponse complex type: */
class SOAP_CMAC _tan__DeleteAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__DeleteAnalyticsModulesResponse (1231)
	virtual int soap_type(void) const { return 1231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__DeleteAnalyticsModulesResponse, default initialized and not managed by a soap context
	virtual _tan__DeleteAnalyticsModulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__DeleteAnalyticsModulesResponse); }
	         _tan__DeleteAnalyticsModulesResponse() { _tan__DeleteAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__DeleteAnalyticsModulesResponse() { }
	friend SOAP_FMAC1 _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__DeleteAnalyticsModulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3660 */
#ifndef SOAP_TYPE__tan__ModifyAnalyticsModules
#define SOAP_TYPE__tan__ModifyAnalyticsModules (1232)
/* tan:ModifyAnalyticsModules complex type: */
class SOAP_CMAC _tan__ModifyAnalyticsModules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeAnalyticsModule;	/* sequence of elements <AnalyticsModule> of XSD type tt:Config */
	tt__Config **AnalyticsModule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__ModifyAnalyticsModules (1232)
	virtual int soap_type(void) const { return 1232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__ModifyAnalyticsModules, default initialized and not managed by a soap context
	virtual _tan__ModifyAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(_tan__ModifyAnalyticsModules); }
	         _tan__ModifyAnalyticsModules() { _tan__ModifyAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__ModifyAnalyticsModules() { }
	friend SOAP_FMAC1 _tan__ModifyAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__ModifyAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3663 */
#ifndef SOAP_TYPE__tan__ModifyAnalyticsModulesResponse
#define SOAP_TYPE__tan__ModifyAnalyticsModulesResponse (1233)
/* tan:ModifyAnalyticsModulesResponse complex type: */
class SOAP_CMAC _tan__ModifyAnalyticsModulesResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__ModifyAnalyticsModulesResponse (1233)
	virtual int soap_type(void) const { return 1233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__ModifyAnalyticsModulesResponse, default initialized and not managed by a soap context
	virtual _tan__ModifyAnalyticsModulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__ModifyAnalyticsModulesResponse); }
	         _tan__ModifyAnalyticsModulesResponse() { _tan__ModifyAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__ModifyAnalyticsModulesResponse() { }
	friend SOAP_FMAC1 _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__ModifyAnalyticsModulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3666 */
#ifndef SOAP_TYPE__tan__GetAnalyticsModules
#define SOAP_TYPE__tan__GetAnalyticsModules (1234)
/* tan:GetAnalyticsModules complex type: */
class SOAP_CMAC _tan__GetAnalyticsModules
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetAnalyticsModules (1234)
	virtual int soap_type(void) const { return 1234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetAnalyticsModules, default initialized and not managed by a soap context
	virtual _tan__GetAnalyticsModules *soap_alloc(void) const { return SOAP_NEW(_tan__GetAnalyticsModules); }
	         _tan__GetAnalyticsModules() { _tan__GetAnalyticsModules::soap_default(NULL); }
	virtual ~_tan__GetAnalyticsModules() { }
	friend SOAP_FMAC1 _tan__GetAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__GetAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3669 */
#ifndef SOAP_TYPE__tan__GetAnalyticsModulesResponse
#define SOAP_TYPE__tan__GetAnalyticsModulesResponse (1235)
/* tan:GetAnalyticsModulesResponse complex type: */
class SOAP_CMAC _tan__GetAnalyticsModulesResponse
{
public:
	int __sizeAnalyticsModule;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AnalyticsModule> of XSD type tt:Config */
	tt__Config **AnalyticsModule;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tan__GetAnalyticsModulesResponse (1235)
	virtual int soap_type(void) const { return 1235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tan__GetAnalyticsModulesResponse, default initialized and not managed by a soap context
	virtual _tan__GetAnalyticsModulesResponse *soap_alloc(void) const { return SOAP_NEW(_tan__GetAnalyticsModulesResponse); }
	         _tan__GetAnalyticsModulesResponse() { _tan__GetAnalyticsModulesResponse::soap_default(NULL); }
	virtual ~_tan__GetAnalyticsModulesResponse() { }
	friend SOAP_FMAC1 _tan__GetAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetAnalyticsModulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3672 */
#ifndef SOAP_TYPE_tad__Capabilities
#define SOAP_TYPE_tad__Capabilities (1236)
/* Type tad__Capabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* tad:Capabilities complex type: */
class SOAP_CMAC tad__Capabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tad__Capabilities (1236)
	virtual int soap_type(void) const { return 1236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tad__Capabilities, default initialized and not managed by a soap context
	virtual tad__Capabilities *soap_alloc(void) const { return SOAP_NEW(tad__Capabilities); }
	         tad__Capabilities() { tad__Capabilities::soap_default(NULL); }
	virtual ~tad__Capabilities() { }
	friend SOAP_FMAC1 tad__Capabilities * SOAP_FMAC2 soap_instantiate_tad__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3675 */
#ifndef SOAP_TYPE__tad__GetServiceCapabilities
#define SOAP_TYPE__tad__GetServiceCapabilities (1237)
/* tad:GetServiceCapabilities complex type: */
class SOAP_CMAC _tad__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetServiceCapabilities (1237)
	virtual int soap_type(void) const { return 1237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _tad__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_tad__GetServiceCapabilities); }
	         _tad__GetServiceCapabilities() { _tad__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tad__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _tad__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tad__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3678 */
#ifndef SOAP_TYPE__tad__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tad__GetServiceCapabilitiesResponse (1238)
/* tad:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _tad__GetServiceCapabilitiesResponse
{
public:
	tad__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tad:Capabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetServiceCapabilitiesResponse (1238)
	virtual int soap_type(void) const { return 1238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _tad__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetServiceCapabilitiesResponse); }
	         _tad__GetServiceCapabilitiesResponse() { _tad__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tad__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _tad__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tad__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3681 */
#ifndef SOAP_TYPE__tad__DeleteAnalyticsEngineControl
#define SOAP_TYPE__tad__DeleteAnalyticsEngineControl (1239)
/* tad:DeleteAnalyticsEngineControl complex type: */
class SOAP_CMAC _tad__DeleteAnalyticsEngineControl
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__DeleteAnalyticsEngineControl (1239)
	virtual int soap_type(void) const { return 1239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__DeleteAnalyticsEngineControl, default initialized and not managed by a soap context
	virtual _tad__DeleteAnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(_tad__DeleteAnalyticsEngineControl); }
	         _tad__DeleteAnalyticsEngineControl() { _tad__DeleteAnalyticsEngineControl::soap_default(NULL); }
	virtual ~_tad__DeleteAnalyticsEngineControl() { }
	friend SOAP_FMAC1 _tad__DeleteAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate__tad__DeleteAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3684 */
#ifndef SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse
#define SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse (1240)
/* tad:DeleteAnalyticsEngineControlResponse complex type: */
class SOAP_CMAC _tad__DeleteAnalyticsEngineControlResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse (1240)
	virtual int soap_type(void) const { return 1240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__DeleteAnalyticsEngineControlResponse, default initialized and not managed by a soap context
	virtual _tad__DeleteAnalyticsEngineControlResponse *soap_alloc(void) const { return SOAP_NEW(_tad__DeleteAnalyticsEngineControlResponse); }
	         _tad__DeleteAnalyticsEngineControlResponse() { _tad__DeleteAnalyticsEngineControlResponse::soap_default(NULL); }
	virtual ~_tad__DeleteAnalyticsEngineControlResponse() { }
	friend SOAP_FMAC1 _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC2 soap_instantiate__tad__DeleteAnalyticsEngineControlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3687 */
#ifndef SOAP_TYPE__tad__CreateAnalyticsEngineInputs
#define SOAP_TYPE__tad__CreateAnalyticsEngineInputs (1241)
/* tad:CreateAnalyticsEngineInputs complex type: */
class SOAP_CMAC _tad__CreateAnalyticsEngineInputs
{
public:
	int __sizeConfiguration;	/* sequence of elements <Configuration> of XSD type tt:AnalyticsEngineInput */
	tt__AnalyticsEngineInput **Configuration;
	int __sizeForcePersistence;	/* sequence of elements <ForcePersistence> of XSD type xsd:boolean */
	bool *ForcePersistence;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__CreateAnalyticsEngineInputs (1241)
	virtual int soap_type(void) const { return 1241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__CreateAnalyticsEngineInputs, default initialized and not managed by a soap context
	virtual _tad__CreateAnalyticsEngineInputs *soap_alloc(void) const { return SOAP_NEW(_tad__CreateAnalyticsEngineInputs); }
	         _tad__CreateAnalyticsEngineInputs() { _tad__CreateAnalyticsEngineInputs::soap_default(NULL); }
	virtual ~_tad__CreateAnalyticsEngineInputs() { }
	friend SOAP_FMAC1 _tad__CreateAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate__tad__CreateAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3690 */
#ifndef SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse
#define SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse (1242)
/* tad:CreateAnalyticsEngineInputsResponse complex type: */
class SOAP_CMAC _tad__CreateAnalyticsEngineInputsResponse
{
public:
	int __sizeConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configuration> of XSD type tt:AnalyticsEngineInput */
	tt__AnalyticsEngineInput **Configuration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse (1242)
	virtual int soap_type(void) const { return 1242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__CreateAnalyticsEngineInputsResponse, default initialized and not managed by a soap context
	virtual _tad__CreateAnalyticsEngineInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tad__CreateAnalyticsEngineInputsResponse); }
	         _tad__CreateAnalyticsEngineInputsResponse() { _tad__CreateAnalyticsEngineInputsResponse::soap_default(NULL); }
	virtual ~_tad__CreateAnalyticsEngineInputsResponse() { }
	friend SOAP_FMAC1 _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC2 soap_instantiate__tad__CreateAnalyticsEngineInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3693 */
#ifndef SOAP_TYPE__tad__CreateAnalyticsEngineControl
#define SOAP_TYPE__tad__CreateAnalyticsEngineControl (1243)
/* tad:CreateAnalyticsEngineControl complex type: */
class SOAP_CMAC _tad__CreateAnalyticsEngineControl
{
public:
	tt__AnalyticsEngineControl *Configuration;	/* required element of XSD type tt:AnalyticsEngineControl */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__CreateAnalyticsEngineControl (1243)
	virtual int soap_type(void) const { return 1243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__CreateAnalyticsEngineControl, default initialized and not managed by a soap context
	virtual _tad__CreateAnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(_tad__CreateAnalyticsEngineControl); }
	         _tad__CreateAnalyticsEngineControl() { _tad__CreateAnalyticsEngineControl::soap_default(NULL); }
	virtual ~_tad__CreateAnalyticsEngineControl() { }
	friend SOAP_FMAC1 _tad__CreateAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate__tad__CreateAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3696 */
#ifndef SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse
#define SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse (1244)
/* tad:CreateAnalyticsEngineControlResponse complex type: */
class SOAP_CMAC _tad__CreateAnalyticsEngineControlResponse
{
public:
	int __sizeConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configuration> of XSD type tt:AnalyticsEngineInput */
	tt__AnalyticsEngineInput **Configuration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse (1244)
	virtual int soap_type(void) const { return 1244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__CreateAnalyticsEngineControlResponse, default initialized and not managed by a soap context
	virtual _tad__CreateAnalyticsEngineControlResponse *soap_alloc(void) const { return SOAP_NEW(_tad__CreateAnalyticsEngineControlResponse); }
	         _tad__CreateAnalyticsEngineControlResponse() { _tad__CreateAnalyticsEngineControlResponse::soap_default(NULL); }
	virtual ~_tad__CreateAnalyticsEngineControlResponse() { }
	friend SOAP_FMAC1 _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC2 soap_instantiate__tad__CreateAnalyticsEngineControlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3699 */
#ifndef SOAP_TYPE__tad__SetAnalyticsEngineControl
#define SOAP_TYPE__tad__SetAnalyticsEngineControl (1245)
/* tad:SetAnalyticsEngineControl complex type: */
class SOAP_CMAC _tad__SetAnalyticsEngineControl
{
public:
	tt__AnalyticsEngineControl *Configuration;	/* required element of XSD type tt:AnalyticsEngineControl */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetAnalyticsEngineControl (1245)
	virtual int soap_type(void) const { return 1245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetAnalyticsEngineControl, default initialized and not managed by a soap context
	virtual _tad__SetAnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(_tad__SetAnalyticsEngineControl); }
	         _tad__SetAnalyticsEngineControl() { _tad__SetAnalyticsEngineControl::soap_default(NULL); }
	virtual ~_tad__SetAnalyticsEngineControl() { }
	friend SOAP_FMAC1 _tad__SetAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate__tad__SetAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3702 */
#ifndef SOAP_TYPE__tad__SetAnalyticsEngineControlResponse
#define SOAP_TYPE__tad__SetAnalyticsEngineControlResponse (1246)
/* tad:SetAnalyticsEngineControlResponse complex type: */
class SOAP_CMAC _tad__SetAnalyticsEngineControlResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetAnalyticsEngineControlResponse (1246)
	virtual int soap_type(void) const { return 1246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetAnalyticsEngineControlResponse, default initialized and not managed by a soap context
	virtual _tad__SetAnalyticsEngineControlResponse *soap_alloc(void) const { return SOAP_NEW(_tad__SetAnalyticsEngineControlResponse); }
	         _tad__SetAnalyticsEngineControlResponse() { _tad__SetAnalyticsEngineControlResponse::soap_default(NULL); }
	virtual ~_tad__SetAnalyticsEngineControlResponse() { }
	friend SOAP_FMAC1 _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC2 soap_instantiate__tad__SetAnalyticsEngineControlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3705 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineControl
#define SOAP_TYPE__tad__GetAnalyticsEngineControl (1247)
/* tad:GetAnalyticsEngineControl complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineControl
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineControl (1247)
	virtual int soap_type(void) const { return 1247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineControl, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineControl); }
	         _tad__GetAnalyticsEngineControl() { _tad__GetAnalyticsEngineControl::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineControl() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3708 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineControlResponse
#define SOAP_TYPE__tad__GetAnalyticsEngineControlResponse (1248)
/* tad:GetAnalyticsEngineControlResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineControlResponse
{
public:
	tt__AnalyticsEngineControl *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AnalyticsEngineControl */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineControlResponse (1248)
	virtual int soap_type(void) const { return 1248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineControlResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineControlResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineControlResponse); }
	         _tad__GetAnalyticsEngineControlResponse() { _tad__GetAnalyticsEngineControlResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineControlResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineControlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3711 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineControls
#define SOAP_TYPE__tad__GetAnalyticsEngineControls (1249)
/* tad:GetAnalyticsEngineControls complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineControls
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineControls (1249)
	virtual int soap_type(void) const { return 1249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineControls, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineControls *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineControls); }
	         _tad__GetAnalyticsEngineControls() { _tad__GetAnalyticsEngineControls::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineControls() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineControls * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineControls(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3714 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse
#define SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse (1250)
/* tad:GetAnalyticsEngineControlsResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineControlsResponse
{
public:
	int __sizeAnalyticsEngineControls;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AnalyticsEngineControls> of XSD type tt:AnalyticsEngineControl */
	tt__AnalyticsEngineControl **AnalyticsEngineControls;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse (1250)
	virtual int soap_type(void) const { return 1250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineControlsResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineControlsResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineControlsResponse); }
	         _tad__GetAnalyticsEngineControlsResponse() { _tad__GetAnalyticsEngineControlsResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineControlsResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineControlsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3717 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngine
#define SOAP_TYPE__tad__GetAnalyticsEngine (1251)
/* tad:GetAnalyticsEngine complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngine
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngine (1251)
	virtual int soap_type(void) const { return 1251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngine, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngine); }
	         _tad__GetAnalyticsEngine() { _tad__GetAnalyticsEngine::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngine() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngine * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3720 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineResponse
#define SOAP_TYPE__tad__GetAnalyticsEngineResponse (1252)
/* tad:GetAnalyticsEngineResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineResponse
{
public:
	tt__AnalyticsEngine *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AnalyticsEngine */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineResponse (1252)
	virtual int soap_type(void) const { return 1252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineResponse); }
	         _tad__GetAnalyticsEngineResponse() { _tad__GetAnalyticsEngineResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3723 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngines
#define SOAP_TYPE__tad__GetAnalyticsEngines (1253)
/* tad:GetAnalyticsEngines complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngines
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngines (1253)
	virtual int soap_type(void) const { return 1253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngines, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngines *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngines); }
	         _tad__GetAnalyticsEngines() { _tad__GetAnalyticsEngines::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngines() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngines * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngines(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3726 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEnginesResponse
#define SOAP_TYPE__tad__GetAnalyticsEnginesResponse (1254)
/* tad:GetAnalyticsEnginesResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEnginesResponse
{
public:
	int __sizeConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configuration> of XSD type tt:AnalyticsEngine */
	tt__AnalyticsEngine **Configuration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEnginesResponse (1254)
	virtual int soap_type(void) const { return 1254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEnginesResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEnginesResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEnginesResponse); }
	         _tad__GetAnalyticsEnginesResponse() { _tad__GetAnalyticsEnginesResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEnginesResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEnginesResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEnginesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3729 */
#ifndef SOAP_TYPE__tad__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__tad__SetVideoAnalyticsConfiguration (1255)
/* tad:SetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _tad__SetVideoAnalyticsConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetVideoAnalyticsConfiguration (1255)
	virtual int soap_type(void) const { return 1255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _tad__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_tad__SetVideoAnalyticsConfiguration); }
	         _tad__SetVideoAnalyticsConfiguration() { _tad__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_tad__SetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__tad__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3732 */
#ifndef SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse (1256)
/* tad:SetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _tad__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse (1256)
	virtual int soap_type(void) const { return 1256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _tad__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tad__SetVideoAnalyticsConfigurationResponse); }
	         _tad__SetVideoAnalyticsConfigurationResponse() { _tad__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_tad__SetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__tad__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3735 */
#ifndef SOAP_TYPE__tad__SetAnalyticsEngineInput
#define SOAP_TYPE__tad__SetAnalyticsEngineInput (1257)
/* tad:SetAnalyticsEngineInput complex type: */
class SOAP_CMAC _tad__SetAnalyticsEngineInput
{
public:
	tt__AnalyticsEngineInput *Configuration;	/* required element of XSD type tt:AnalyticsEngineInput */
	bool ForcePersistence;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetAnalyticsEngineInput (1257)
	virtual int soap_type(void) const { return 1257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetAnalyticsEngineInput, default initialized and not managed by a soap context
	virtual _tad__SetAnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(_tad__SetAnalyticsEngineInput); }
	         _tad__SetAnalyticsEngineInput() { _tad__SetAnalyticsEngineInput::soap_default(NULL); }
	virtual ~_tad__SetAnalyticsEngineInput() { }
	friend SOAP_FMAC1 _tad__SetAnalyticsEngineInput * SOAP_FMAC2 soap_instantiate__tad__SetAnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3738 */
#ifndef SOAP_TYPE__tad__SetAnalyticsEngineInputResponse
#define SOAP_TYPE__tad__SetAnalyticsEngineInputResponse (1258)
/* tad:SetAnalyticsEngineInputResponse complex type: */
class SOAP_CMAC _tad__SetAnalyticsEngineInputResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__SetAnalyticsEngineInputResponse (1258)
	virtual int soap_type(void) const { return 1258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__SetAnalyticsEngineInputResponse, default initialized and not managed by a soap context
	virtual _tad__SetAnalyticsEngineInputResponse *soap_alloc(void) const { return SOAP_NEW(_tad__SetAnalyticsEngineInputResponse); }
	         _tad__SetAnalyticsEngineInputResponse() { _tad__SetAnalyticsEngineInputResponse::soap_default(NULL); }
	virtual ~_tad__SetAnalyticsEngineInputResponse() { }
	friend SOAP_FMAC1 _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC2 soap_instantiate__tad__SetAnalyticsEngineInputResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3741 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineInput
#define SOAP_TYPE__tad__GetAnalyticsEngineInput (1259)
/* tad:GetAnalyticsEngineInput complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineInput
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineInput (1259)
	virtual int soap_type(void) const { return 1259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineInput, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineInput); }
	         _tad__GetAnalyticsEngineInput() { _tad__GetAnalyticsEngineInput::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineInput() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineInput * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3744 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineInputResponse
#define SOAP_TYPE__tad__GetAnalyticsEngineInputResponse (1260)
/* tad:GetAnalyticsEngineInputResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineInputResponse
{
public:
	tt__AnalyticsEngineInput *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AnalyticsEngineInput */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineInputResponse (1260)
	virtual int soap_type(void) const { return 1260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineInputResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineInputResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineInputResponse); }
	         _tad__GetAnalyticsEngineInputResponse() { _tad__GetAnalyticsEngineInputResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineInputResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineInputResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3747 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineInputs
#define SOAP_TYPE__tad__GetAnalyticsEngineInputs (1261)
/* tad:GetAnalyticsEngineInputs complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineInputs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineInputs (1261)
	virtual int soap_type(void) const { return 1261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineInputs, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineInputs *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineInputs); }
	         _tad__GetAnalyticsEngineInputs() { _tad__GetAnalyticsEngineInputs::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineInputs() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3750 */
#ifndef SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse
#define SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse (1262)
/* tad:GetAnalyticsEngineInputsResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsEngineInputsResponse
{
public:
	int __sizeConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Configuration> of XSD type tt:AnalyticsEngineInput */
	tt__AnalyticsEngineInput **Configuration;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse (1262)
	virtual int soap_type(void) const { return 1262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsEngineInputsResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsEngineInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsEngineInputsResponse); }
	         _tad__GetAnalyticsEngineInputsResponse() { _tad__GetAnalyticsEngineInputsResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsEngineInputsResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsEngineInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3753 */
#ifndef SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri
#define SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri (1263)
/* tad:GetAnalyticsDeviceStreamUri complex type: */
class SOAP_CMAC _tad__GetAnalyticsDeviceStreamUri
{
public:
	tt__StreamSetup *StreamSetup;	/* required element of XSD type tt:StreamSetup */
	char *AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri (1263)
	virtual int soap_type(void) const { return 1263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsDeviceStreamUri, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsDeviceStreamUri *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsDeviceStreamUri); }
	         _tad__GetAnalyticsDeviceStreamUri() { _tad__GetAnalyticsDeviceStreamUri::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsDeviceStreamUri() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsDeviceStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3756 */
#ifndef SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse
#define SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse (1264)
/* tad:GetAnalyticsDeviceStreamUriResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsDeviceStreamUriResponse
{
public:
	char *Uri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse (1264)
	virtual int soap_type(void) const { return 1264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsDeviceStreamUriResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsDeviceStreamUriResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsDeviceStreamUriResponse); }
	         _tad__GetAnalyticsDeviceStreamUriResponse() { _tad__GetAnalyticsDeviceStreamUriResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsDeviceStreamUriResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsDeviceStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3759 */
#ifndef SOAP_TYPE__tad__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__tad__GetVideoAnalyticsConfiguration (1265)
/* tad:GetVideoAnalyticsConfiguration complex type: */
class SOAP_CMAC _tad__GetVideoAnalyticsConfiguration
{
public:
	char *ConfigurationToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetVideoAnalyticsConfiguration (1265)
	virtual int soap_type(void) const { return 1265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual _tad__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(_tad__GetVideoAnalyticsConfiguration); }
	         _tad__GetVideoAnalyticsConfiguration() { _tad__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_tad__GetVideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__tad__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3762 */
#ifndef SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse (1266)
/* tad:GetVideoAnalyticsConfigurationResponse complex type: */
class SOAP_CMAC _tad__GetVideoAnalyticsConfigurationResponse
{
public:
	tt__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse (1266)
	virtual int soap_type(void) const { return 1266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
	virtual _tad__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetVideoAnalyticsConfigurationResponse); }
	         _tad__GetVideoAnalyticsConfigurationResponse() { _tad__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_tad__GetVideoAnalyticsConfigurationResponse() { }
	friend SOAP_FMAC1 _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__tad__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3765 */
#ifndef SOAP_TYPE__tad__DeleteAnalyticsEngineInputs
#define SOAP_TYPE__tad__DeleteAnalyticsEngineInputs (1267)
/* tad:DeleteAnalyticsEngineInputs complex type: */
class SOAP_CMAC _tad__DeleteAnalyticsEngineInputs
{
public:
	int __sizeConfigurationToken;	/* sequence of elements <ConfigurationToken> of XSD type tt:ReferenceToken */
	char **ConfigurationToken;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__DeleteAnalyticsEngineInputs (1267)
	virtual int soap_type(void) const { return 1267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__DeleteAnalyticsEngineInputs, default initialized and not managed by a soap context
	virtual _tad__DeleteAnalyticsEngineInputs *soap_alloc(void) const { return SOAP_NEW(_tad__DeleteAnalyticsEngineInputs); }
	         _tad__DeleteAnalyticsEngineInputs() { _tad__DeleteAnalyticsEngineInputs::soap_default(NULL); }
	virtual ~_tad__DeleteAnalyticsEngineInputs() { }
	friend SOAP_FMAC1 _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate__tad__DeleteAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3768 */
#ifndef SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse
#define SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse (1268)
/* tad:DeleteAnalyticsEngineInputsResponse complex type: */
class SOAP_CMAC _tad__DeleteAnalyticsEngineInputsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse (1268)
	virtual int soap_type(void) const { return 1268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__DeleteAnalyticsEngineInputsResponse, default initialized and not managed by a soap context
	virtual _tad__DeleteAnalyticsEngineInputsResponse *soap_alloc(void) const { return SOAP_NEW(_tad__DeleteAnalyticsEngineInputsResponse); }
	         _tad__DeleteAnalyticsEngineInputsResponse() { _tad__DeleteAnalyticsEngineInputsResponse::soap_default(NULL); }
	virtual ~_tad__DeleteAnalyticsEngineInputsResponse() { }
	friend SOAP_FMAC1 _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC2 soap_instantiate__tad__DeleteAnalyticsEngineInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3771 */
#ifndef SOAP_TYPE__tad__GetAnalyticsState
#define SOAP_TYPE__tad__GetAnalyticsState (1269)
/* tad:GetAnalyticsState complex type: */
class SOAP_CMAC _tad__GetAnalyticsState
{
public:
	char *AnalyticsEngineControlToken;	/* required element of XSD type tt:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsState (1269)
	virtual int soap_type(void) const { return 1269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsState, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsState *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsState); }
	         _tad__GetAnalyticsState() { _tad__GetAnalyticsState::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsState() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsState * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3774 */
#ifndef SOAP_TYPE__tad__GetAnalyticsStateResponse
#define SOAP_TYPE__tad__GetAnalyticsStateResponse (1270)
/* tad:GetAnalyticsStateResponse complex type: */
class SOAP_CMAC _tad__GetAnalyticsStateResponse
{
public:
	tt__AnalyticsStateInformation *State;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type tt:AnalyticsStateInformation */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__tad__GetAnalyticsStateResponse (1270)
	virtual int soap_type(void) const { return 1270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _tad__GetAnalyticsStateResponse, default initialized and not managed by a soap context
	virtual _tad__GetAnalyticsStateResponse *soap_alloc(void) const { return SOAP_NEW(_tad__GetAnalyticsStateResponse); }
	         _tad__GetAnalyticsStateResponse() { _tad__GetAnalyticsStateResponse::soap_default(NULL); }
	virtual ~_tad__GetAnalyticsStateResponse() { }
	friend SOAP_FMAC1 _tad__GetAnalyticsStateResponse * SOAP_FMAC2 soap_instantiate__tad__GetAnalyticsStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3777 */
#ifndef SOAP_TYPE_ns1__ActionConfigDescription
#define SOAP_TYPE_ns1__ActionConfigDescription (1271)
/* Type ns1__ActionConfigDescription is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionConfigDescription complex type: */
class SOAP_CMAC ns1__ActionConfigDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *ParameterDescription;	/* required element of XSD type tt:ItemListDescription */
	char *Name;	/* required attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionConfigDescription (1271)
	virtual int soap_type(void) const { return 1271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionConfigDescription, default initialized and not managed by a soap context
	virtual ns1__ActionConfigDescription *soap_alloc(void) const { return SOAP_NEW(ns1__ActionConfigDescription); }
	         ns1__ActionConfigDescription() { ns1__ActionConfigDescription::soap_default(NULL); }
	virtual ~ns1__ActionConfigDescription() { }
	friend SOAP_FMAC1 ns1__ActionConfigDescription * SOAP_FMAC2 soap_instantiate_ns1__ActionConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3780 */
#ifndef SOAP_TYPE_ns1__SupportedActions
#define SOAP_TYPE_ns1__SupportedActions (1272)
/* Type ns1__SupportedActions is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SupportedActions complex type: */
class SOAP_CMAC ns1__SupportedActions : public xsd__anyType
{
public:
	int __sizeActionContentSchemaLocation;	/* sequence of elements <ActionContentSchemaLocation> of XSD type xsd:anyURI */
	char **ActionContentSchemaLocation;
	int __sizeActionDescription;	/* sequence of elements <ActionDescription> of XSD type ns1:ActionConfigDescription */
	ns1__ActionConfigDescription **ActionDescription;
	ns1__SupportedActionsExtension *Extension;	/* optional element of XSD type ns1:SupportedActionsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SupportedActions (1272)
	virtual int soap_type(void) const { return 1272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SupportedActions, default initialized and not managed by a soap context
	virtual ns1__SupportedActions *soap_alloc(void) const { return SOAP_NEW(ns1__SupportedActions); }
	         ns1__SupportedActions() { ns1__SupportedActions::soap_default(NULL); }
	virtual ~ns1__SupportedActions() { }
	friend SOAP_FMAC1 ns1__SupportedActions * SOAP_FMAC2 soap_instantiate_ns1__SupportedActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3783 */
#ifndef SOAP_TYPE_ns1__SupportedActionsExtension
#define SOAP_TYPE_ns1__SupportedActionsExtension (1273)
/* Type ns1__SupportedActionsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SupportedActionsExtension complex type: */
class SOAP_CMAC ns1__SupportedActionsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SupportedActionsExtension (1273)
	virtual int soap_type(void) const { return 1273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SupportedActionsExtension, default initialized and not managed by a soap context
	virtual ns1__SupportedActionsExtension *soap_alloc(void) const { return SOAP_NEW(ns1__SupportedActionsExtension); }
	         ns1__SupportedActionsExtension() { ns1__SupportedActionsExtension::soap_default(NULL); }
	virtual ~ns1__SupportedActionsExtension() { }
	friend SOAP_FMAC1 ns1__SupportedActionsExtension * SOAP_FMAC2 soap_instantiate_ns1__SupportedActionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3786 */
#ifndef SOAP_TYPE_ns1__ActionEngineCapabilities
#define SOAP_TYPE_ns1__ActionEngineCapabilities (1274)
/* Type ns1__ActionEngineCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionEngineCapabilities complex type: */
class SOAP_CMAC ns1__ActionEngineCapabilities : public xsd__anyType
{
public:
	int __sizeActionCapabilities;	/* sequence of elements <ActionCapabilities> of XSD type ns1:ActionTypeLimits */
	ns1__ActionTypeLimits **ActionCapabilities;
	ns1__ActionEngineCapabilitiesExtension *Extension;	/* optional element of XSD type ns1:ActionEngineCapabilitiesExtension */
	char *MaximumTriggers;	/* optional attribute of XSD type xsd:positiveInteger */
	char *MaximumActions;	/* optional attribute of XSD type xsd:positiveInteger */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionEngineCapabilities (1274)
	virtual int soap_type(void) const { return 1274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionEngineCapabilities, default initialized and not managed by a soap context
	virtual ns1__ActionEngineCapabilities *soap_alloc(void) const { return SOAP_NEW(ns1__ActionEngineCapabilities); }
	         ns1__ActionEngineCapabilities() { ns1__ActionEngineCapabilities::soap_default(NULL); }
	virtual ~ns1__ActionEngineCapabilities() { }
	friend SOAP_FMAC1 ns1__ActionEngineCapabilities * SOAP_FMAC2 soap_instantiate_ns1__ActionEngineCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3789 */
#ifndef SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension
#define SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension (1275)
/* Type ns1__ActionEngineCapabilitiesExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionEngineCapabilitiesExtension complex type: */
class SOAP_CMAC ns1__ActionEngineCapabilitiesExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension (1275)
	virtual int soap_type(void) const { return 1275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionEngineCapabilitiesExtension, default initialized and not managed by a soap context
	virtual ns1__ActionEngineCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW(ns1__ActionEngineCapabilitiesExtension); }
	         ns1__ActionEngineCapabilitiesExtension() { ns1__ActionEngineCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns1__ActionEngineCapabilitiesExtension() { }
	friend SOAP_FMAC1 ns1__ActionEngineCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_ns1__ActionEngineCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3792 */
#ifndef SOAP_TYPE_ns1__ActionTypeLimits
#define SOAP_TYPE_ns1__ActionTypeLimits (1276)
/* Type ns1__ActionTypeLimits is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionTypeLimits complex type: */
class SOAP_CMAC ns1__ActionTypeLimits : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Type;	/* required attribute of XSD type xsd:QName */
	char *Maximum;	/* required attribute of XSD type xsd:positiveInteger */
	char *InUse;	/* optional attribute of XSD type xsd:nonNegativeInteger */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionTypeLimits (1276)
	virtual int soap_type(void) const { return 1276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionTypeLimits, default initialized and not managed by a soap context
	virtual ns1__ActionTypeLimits *soap_alloc(void) const { return SOAP_NEW(ns1__ActionTypeLimits); }
	         ns1__ActionTypeLimits() { ns1__ActionTypeLimits::soap_default(NULL); }
	virtual ~ns1__ActionTypeLimits() { }
	friend SOAP_FMAC1 ns1__ActionTypeLimits * SOAP_FMAC2 soap_instantiate_ns1__ActionTypeLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3795 */
#ifndef SOAP_TYPE_ns1__ActionConfiguration
#define SOAP_TYPE_ns1__ActionConfiguration (1277)
/* Type ns1__ActionConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionConfiguration complex type: */
class SOAP_CMAC ns1__ActionConfiguration : public xsd__anyType
{
public:
	tt__ItemList *Parameters;	/* required element of XSD type tt:ItemList */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Name;	/* required attribute of XSD type xsd:string */
	char *Type;	/* required attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionConfiguration (1277)
	virtual int soap_type(void) const { return 1277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionConfiguration, default initialized and not managed by a soap context
	virtual ns1__ActionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__ActionConfiguration); }
	         ns1__ActionConfiguration() { ns1__ActionConfiguration::soap_default(NULL); }
	virtual ~ns1__ActionConfiguration() { }
	friend SOAP_FMAC1 ns1__ActionConfiguration * SOAP_FMAC2 soap_instantiate_ns1__ActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3798 */
#ifndef SOAP_TYPE_ns1__Action
#define SOAP_TYPE_ns1__Action (1278)
/* Type ns1__Action is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:Action complex type: */
class SOAP_CMAC ns1__Action : public xsd__anyType
{
public:
	ns1__ActionConfiguration *Configuration;	/* required element of XSD type ns1:ActionConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__Action (1278)
	virtual int soap_type(void) const { return 1278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__Action, default initialized and not managed by a soap context
	virtual ns1__Action *soap_alloc(void) const { return SOAP_NEW(ns1__Action); }
	         ns1__Action() { ns1__Action::soap_default(NULL); }
	virtual ~ns1__Action() { }
	friend SOAP_FMAC1 ns1__Action * SOAP_FMAC2 soap_instantiate_ns1__Action(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3801 */
#ifndef SOAP_TYPE_ns1__ActionTriggerConfiguration
#define SOAP_TYPE_ns1__ActionTriggerConfiguration (1279)
/* Type ns1__ActionTriggerConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionTriggerConfiguration complex type: */
class SOAP_CMAC ns1__ActionTriggerConfiguration : public xsd__anyType
{
public:
	wsnt__TopicExpressionType *TopicExpression;	/* required element of XSD type wsnt:TopicExpressionType */
	wsnt__QueryExpressionType *ContentExpression;	/* optional element of XSD type wsnt:QueryExpressionType */
	int __sizeActionToken;	/* sequence of elements <ActionToken> of XSD type tt:ReferenceToken */
	char **ActionToken;
	ns1__ActionTriggerConfigurationExtension *Extension;	/* optional element of XSD type ns1:ActionTriggerConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionTriggerConfiguration (1279)
	virtual int soap_type(void) const { return 1279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionTriggerConfiguration, default initialized and not managed by a soap context
	virtual ns1__ActionTriggerConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__ActionTriggerConfiguration); }
	         ns1__ActionTriggerConfiguration() { ns1__ActionTriggerConfiguration::soap_default(NULL); }
	virtual ~ns1__ActionTriggerConfiguration() { }
	friend SOAP_FMAC1 ns1__ActionTriggerConfiguration * SOAP_FMAC2 soap_instantiate_ns1__ActionTriggerConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3804 */
#ifndef SOAP_TYPE_ns1__ActionTriggerConfigurationExtension
#define SOAP_TYPE_ns1__ActionTriggerConfigurationExtension (1280)
/* Type ns1__ActionTriggerConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionTriggerConfigurationExtension complex type: */
class SOAP_CMAC ns1__ActionTriggerConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionTriggerConfigurationExtension (1280)
	virtual int soap_type(void) const { return 1280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionTriggerConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__ActionTriggerConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__ActionTriggerConfigurationExtension); }
	         ns1__ActionTriggerConfigurationExtension() { ns1__ActionTriggerConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__ActionTriggerConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__ActionTriggerConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__ActionTriggerConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3807 */
#ifndef SOAP_TYPE_ns1__ActionTrigger
#define SOAP_TYPE_ns1__ActionTrigger (1281)
/* Type ns1__ActionTrigger is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:ActionTrigger complex type: */
class SOAP_CMAC ns1__ActionTrigger : public xsd__anyType
{
public:
	ns1__ActionTriggerConfiguration *Configuration;	/* required element of XSD type ns1:ActionTriggerConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Token;	/* required attribute of XSD type tt:ReferenceToken */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ActionTrigger (1281)
	virtual int soap_type(void) const { return 1281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ActionTrigger, default initialized and not managed by a soap context
	virtual ns1__ActionTrigger *soap_alloc(void) const { return SOAP_NEW(ns1__ActionTrigger); }
	         ns1__ActionTrigger() { ns1__ActionTrigger::soap_default(NULL); }
	virtual ~ns1__ActionTrigger() { }
	friend SOAP_FMAC1 ns1__ActionTrigger * SOAP_FMAC2 soap_instantiate_ns1__ActionTrigger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3810 */
#ifndef SOAP_TYPE_ns1__onvif_USCOREaction
#define SOAP_TYPE_ns1__onvif_USCOREaction (1282)
/* Type ns1__onvif_USCOREaction is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:onvif_action complex type: */
class SOAP_CMAC ns1__onvif_USCOREaction : public xsd__anyType
{
public:
	int __sizeActionDescription;	/* sequence of elements <ActionDescription> of XSD type ns1:ActionConfigDescription */
	ns1__ActionConfigDescription **ActionDescription;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__onvif_USCOREaction (1282)
	virtual int soap_type(void) const { return 1282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__onvif_USCOREaction, default initialized and not managed by a soap context
	virtual ns1__onvif_USCOREaction *soap_alloc(void) const { return SOAP_NEW(ns1__onvif_USCOREaction); }
	         ns1__onvif_USCOREaction() { ns1__onvif_USCOREaction::soap_default(NULL); }
	virtual ~ns1__onvif_USCOREaction() { }
	friend SOAP_FMAC1 ns1__onvif_USCOREaction * SOAP_FMAC2 soap_instantiate_ns1__onvif_USCOREaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3813 */
#ifndef SOAP_TYPE_ns1__EMailServerConfiguration
#define SOAP_TYPE_ns1__EMailServerConfiguration (1283)
/* Type ns1__EMailServerConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailServerConfiguration complex type: */
class SOAP_CMAC ns1__EMailServerConfiguration : public xsd__anyType
{
public:
	ns1__SMTPConfig *SMTPConfig;	/* required element of XSD type ns1:SMTPConfig */
	ns1__POPConfig *POPConfig;	/* required element of XSD type ns1:POPConfig */
	ns1__AuthenticationConfig *AuthenticationConfig;	/* required element of XSD type ns1:AuthenticationConfig */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailServerConfiguration (1283)
	virtual int soap_type(void) const { return 1283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailServerConfiguration, default initialized and not managed by a soap context
	virtual ns1__EMailServerConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__EMailServerConfiguration); }
	         ns1__EMailServerConfiguration() { ns1__EMailServerConfiguration::soap_default(NULL); }
	virtual ~ns1__EMailServerConfiguration() { }
	friend SOAP_FMAC1 ns1__EMailServerConfiguration * SOAP_FMAC2 soap_instantiate_ns1__EMailServerConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3816 */
#ifndef SOAP_TYPE_ns1__SMTPConfig
#define SOAP_TYPE_ns1__SMTPConfig (1284)
/* Type ns1__SMTPConfig is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SMTPConfig complex type: */
class SOAP_CMAC ns1__SMTPConfig : public xsd__anyType
{
public:
	ns1__HostAddress *HostAddress;	/* required element of XSD type ns1:HostAddress */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *portNo;	/* optional attribute of XSD type xsd:positiveInteger */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SMTPConfig (1284)
	virtual int soap_type(void) const { return 1284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SMTPConfig, default initialized and not managed by a soap context
	virtual ns1__SMTPConfig *soap_alloc(void) const { return SOAP_NEW(ns1__SMTPConfig); }
	         ns1__SMTPConfig() { ns1__SMTPConfig::soap_default(NULL); }
	virtual ~ns1__SMTPConfig() { }
	friend SOAP_FMAC1 ns1__SMTPConfig * SOAP_FMAC2 soap_instantiate_ns1__SMTPConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3819 */
#ifndef SOAP_TYPE_ns1__POPConfig
#define SOAP_TYPE_ns1__POPConfig (1285)
/* Type ns1__POPConfig is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:POPConfig complex type: */
class SOAP_CMAC ns1__POPConfig : public xsd__anyType
{
public:
	ns1__HostAddress *HostAddress;	/* required element of XSD type ns1:HostAddress */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__POPConfig (1285)
	virtual int soap_type(void) const { return 1285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__POPConfig, default initialized and not managed by a soap context
	virtual ns1__POPConfig *soap_alloc(void) const { return SOAP_NEW(ns1__POPConfig); }
	         ns1__POPConfig() { ns1__POPConfig::soap_default(NULL); }
	virtual ~ns1__POPConfig() { }
	friend SOAP_FMAC1 ns1__POPConfig * SOAP_FMAC2 soap_instantiate_ns1__POPConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3822 */
#ifndef SOAP_TYPE_ns1__HostAddress
#define SOAP_TYPE_ns1__HostAddress (1286)
/* Type ns1__HostAddress is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HostAddress complex type: */
class SOAP_CMAC ns1__HostAddress : public xsd__anyType
{
public:
	char *Value;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	enum ns1__AddressFormatType formatType;	/* required attribute of XSD type ns1:AddressFormatType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HostAddress (1286)
	virtual int soap_type(void) const { return 1286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HostAddress, default initialized and not managed by a soap context
	virtual ns1__HostAddress *soap_alloc(void) const { return SOAP_NEW(ns1__HostAddress); }
	         ns1__HostAddress() { ns1__HostAddress::soap_default(NULL); }
	virtual ~ns1__HostAddress() { }
	friend SOAP_FMAC1 ns1__HostAddress * SOAP_FMAC2 soap_instantiate_ns1__HostAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3825 */
#ifndef SOAP_TYPE_ns1__UserCredentials
#define SOAP_TYPE_ns1__UserCredentials (1287)
/* Type ns1__UserCredentials is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:UserCredentials complex type: */
class SOAP_CMAC ns1__UserCredentials : public xsd__anyType
{
public:
	char *username;	/* required element of XSD type xsd:string */
	xsd__base64Binary *password;	/* optional element of XSD type xsd:base64Binary */
	ns1__UserCredentialsExtension *Extension;	/* optional element of XSD type ns1:UserCredentialsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__UserCredentials (1287)
	virtual int soap_type(void) const { return 1287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__UserCredentials, default initialized and not managed by a soap context
	virtual ns1__UserCredentials *soap_alloc(void) const { return SOAP_NEW(ns1__UserCredentials); }
	         ns1__UserCredentials() { ns1__UserCredentials::soap_default(NULL); }
	virtual ~ns1__UserCredentials() { }
	friend SOAP_FMAC1 ns1__UserCredentials * SOAP_FMAC2 soap_instantiate_ns1__UserCredentials(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3828 */
#ifndef SOAP_TYPE_ns1__UserCredentialsExtension
#define SOAP_TYPE_ns1__UserCredentialsExtension (1288)
/* Type ns1__UserCredentialsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:UserCredentialsExtension complex type: */
class SOAP_CMAC ns1__UserCredentialsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__UserCredentialsExtension (1288)
	virtual int soap_type(void) const { return 1288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__UserCredentialsExtension, default initialized and not managed by a soap context
	virtual ns1__UserCredentialsExtension *soap_alloc(void) const { return SOAP_NEW(ns1__UserCredentialsExtension); }
	         ns1__UserCredentialsExtension() { ns1__UserCredentialsExtension::soap_default(NULL); }
	virtual ~ns1__UserCredentialsExtension() { }
	friend SOAP_FMAC1 ns1__UserCredentialsExtension * SOAP_FMAC2 soap_instantiate_ns1__UserCredentialsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3831 */
#ifndef SOAP_TYPE_ns1__AuthenticationConfig
#define SOAP_TYPE_ns1__AuthenticationConfig (1289)
/* Type ns1__AuthenticationConfig is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:AuthenticationConfig complex type: */
class SOAP_CMAC ns1__AuthenticationConfig : public xsd__anyType
{
public:
	ns1__UserCredentials *User;	/* required element of XSD type ns1:UserCredentials */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	enum ns1__EMailAuthenticationMode mode;	/* required attribute of XSD type ns1:EMailAuthenticationMode */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__AuthenticationConfig (1289)
	virtual int soap_type(void) const { return 1289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__AuthenticationConfig, default initialized and not managed by a soap context
	virtual ns1__AuthenticationConfig *soap_alloc(void) const { return SOAP_NEW(ns1__AuthenticationConfig); }
	         ns1__AuthenticationConfig() { ns1__AuthenticationConfig::soap_default(NULL); }
	virtual ~ns1__AuthenticationConfig() { }
	friend SOAP_FMAC1 ns1__AuthenticationConfig * SOAP_FMAC2 soap_instantiate_ns1__AuthenticationConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3834 */
#ifndef SOAP_TYPE_ns1__EMailReceiverConfiguration
#define SOAP_TYPE_ns1__EMailReceiverConfiguration (1290)
/* Type ns1__EMailReceiverConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailReceiverConfiguration complex type: */
class SOAP_CMAC ns1__EMailReceiverConfiguration : public xsd__anyType
{
public:
	int __sizeTO;	/* sequence of elements <TO> of XSD type xsd:string */
	char **TO;
	int __sizeCC;	/* sequence of elements <CC> of XSD type xsd:string */
	char **CC;
	ns1__EMailReceiverConfigurationExtension *Extension;	/* optional element of XSD type ns1:EMailReceiverConfigurationExtension */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailReceiverConfiguration (1290)
	virtual int soap_type(void) const { return 1290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailReceiverConfiguration, default initialized and not managed by a soap context
	virtual ns1__EMailReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__EMailReceiverConfiguration); }
	         ns1__EMailReceiverConfiguration() { ns1__EMailReceiverConfiguration::soap_default(NULL); }
	virtual ~ns1__EMailReceiverConfiguration() { }
	friend SOAP_FMAC1 ns1__EMailReceiverConfiguration * SOAP_FMAC2 soap_instantiate_ns1__EMailReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3837 */
#ifndef SOAP_TYPE_ns1__EMailReceiverConfigurationExtension
#define SOAP_TYPE_ns1__EMailReceiverConfigurationExtension (1291)
/* Type ns1__EMailReceiverConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailReceiverConfigurationExtension complex type: */
class SOAP_CMAC ns1__EMailReceiverConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailReceiverConfigurationExtension (1291)
	virtual int soap_type(void) const { return 1291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailReceiverConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__EMailReceiverConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__EMailReceiverConfigurationExtension); }
	         ns1__EMailReceiverConfigurationExtension() { ns1__EMailReceiverConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__EMailReceiverConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__EMailReceiverConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__EMailReceiverConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3840 */
#ifndef SOAP_TYPE_ns1__EMailAttachmentConfiguration
#define SOAP_TYPE_ns1__EMailAttachmentConfiguration (1292)
/* Type ns1__EMailAttachmentConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailAttachmentConfiguration complex type: */
class SOAP_CMAC ns1__EMailAttachmentConfiguration : public xsd__anyType
{
public:
	char *FileName;	/* optional element of XSD type xsd:string */
	enum ns1__FileSuffixType *doSuffix;	/* optional element of XSD type ns1:FileSuffixType */
	ns1__EMailAttachmentConfigurationExtension *Extension;	/* optional element of XSD type ns1:EMailAttachmentConfigurationExtension */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailAttachmentConfiguration (1292)
	virtual int soap_type(void) const { return 1292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailAttachmentConfiguration, default initialized and not managed by a soap context
	virtual ns1__EMailAttachmentConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__EMailAttachmentConfiguration); }
	         ns1__EMailAttachmentConfiguration() { ns1__EMailAttachmentConfiguration::soap_default(NULL); }
	virtual ~ns1__EMailAttachmentConfiguration() { }
	friend SOAP_FMAC1 ns1__EMailAttachmentConfiguration * SOAP_FMAC2 soap_instantiate_ns1__EMailAttachmentConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3843 */
#ifndef SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension
#define SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension (1293)
/* Type ns1__EMailAttachmentConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailAttachmentConfigurationExtension complex type: */
class SOAP_CMAC ns1__EMailAttachmentConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension (1293)
	virtual int soap_type(void) const { return 1293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailAttachmentConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__EMailAttachmentConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__EMailAttachmentConfigurationExtension); }
	         ns1__EMailAttachmentConfigurationExtension() { ns1__EMailAttachmentConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__EMailAttachmentConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__EMailAttachmentConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__EMailAttachmentConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3846 */
#ifndef SOAP_TYPE_ns1__EMailBodyTextConfiguration
#define SOAP_TYPE_ns1__EMailBodyTextConfiguration (1294)
/* Type ns1__EMailBodyTextConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:EMailBodyTextConfiguration complex type: */
class SOAP_CMAC ns1__EMailBodyTextConfiguration : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *includeEvent;	/* optional attribute of XSD type xsd:boolean */
	char *type;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EMailBodyTextConfiguration (1294)
	virtual int soap_type(void) const { return 1294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EMailBodyTextConfiguration, default initialized and not managed by a soap context
	virtual ns1__EMailBodyTextConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__EMailBodyTextConfiguration); }
	         ns1__EMailBodyTextConfiguration() { ns1__EMailBodyTextConfiguration::soap_default(NULL); }
	virtual ~ns1__EMailBodyTextConfiguration() { }
	friend SOAP_FMAC1 ns1__EMailBodyTextConfiguration * SOAP_FMAC2 soap_instantiate_ns1__EMailBodyTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3849 */
#ifndef SOAP_TYPE_ns1__MediaSource
#define SOAP_TYPE_ns1__MediaSource (1295)
/* Type ns1__MediaSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:MediaSource complex type: */
class SOAP_CMAC ns1__MediaSource : public xsd__anyType
{
public:
	char *ProfileToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__MediaSource (1295)
	virtual int soap_type(void) const { return 1295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__MediaSource, default initialized and not managed by a soap context
	virtual ns1__MediaSource *soap_alloc(void) const { return SOAP_NEW(ns1__MediaSource); }
	         ns1__MediaSource() { ns1__MediaSource::soap_default(NULL); }
	virtual ~ns1__MediaSource() { }
	friend SOAP_FMAC1 ns1__MediaSource * SOAP_FMAC2 soap_instantiate_ns1__MediaSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3852 */
#ifndef SOAP_TYPE_ns1__HttpHostConfigurations
#define SOAP_TYPE_ns1__HttpHostConfigurations (1296)
/* Type ns1__HttpHostConfigurations is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpHostConfigurations complex type: */
class SOAP_CMAC ns1__HttpHostConfigurations : public xsd__anyType
{
public:
	int __sizeHttpDestination;	/* sequence of elements <HttpDestination> of XSD type ns1:HttpDestinationConfiguration */
	ns1__HttpDestinationConfiguration **HttpDestination;
	ns1__HttpHostConfigurationsExtension *Extension;	/* optional element of XSD type ns1:HttpHostConfigurationsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpHostConfigurations (1296)
	virtual int soap_type(void) const { return 1296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpHostConfigurations, default initialized and not managed by a soap context
	virtual ns1__HttpHostConfigurations *soap_alloc(void) const { return SOAP_NEW(ns1__HttpHostConfigurations); }
	         ns1__HttpHostConfigurations() { ns1__HttpHostConfigurations::soap_default(NULL); }
	virtual ~ns1__HttpHostConfigurations() { }
	friend SOAP_FMAC1 ns1__HttpHostConfigurations * SOAP_FMAC2 soap_instantiate_ns1__HttpHostConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3855 */
#ifndef SOAP_TYPE_ns1__HttpHostConfigurationsExtension
#define SOAP_TYPE_ns1__HttpHostConfigurationsExtension (1297)
/* Type ns1__HttpHostConfigurationsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpHostConfigurationsExtension complex type: */
class SOAP_CMAC ns1__HttpHostConfigurationsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpHostConfigurationsExtension (1297)
	virtual int soap_type(void) const { return 1297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpHostConfigurationsExtension, default initialized and not managed by a soap context
	virtual ns1__HttpHostConfigurationsExtension *soap_alloc(void) const { return SOAP_NEW(ns1__HttpHostConfigurationsExtension); }
	         ns1__HttpHostConfigurationsExtension() { ns1__HttpHostConfigurationsExtension::soap_default(NULL); }
	virtual ~ns1__HttpHostConfigurationsExtension() { }
	friend SOAP_FMAC1 ns1__HttpHostConfigurationsExtension * SOAP_FMAC2 soap_instantiate_ns1__HttpHostConfigurationsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3858 */
#ifndef SOAP_TYPE_ns1__HttpDestinationConfiguration
#define SOAP_TYPE_ns1__HttpDestinationConfiguration (1298)
/* Type ns1__HttpDestinationConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpDestinationConfiguration complex type: */
class SOAP_CMAC ns1__HttpDestinationConfiguration : public xsd__anyType
{
public:
	ns1__HttpHostAddress *HostAddress;	/* required element of XSD type ns1:HttpHostAddress */
	ns1__HttpAuthenticationConfiguration *HttpAuthentication;	/* optional element of XSD type ns1:HttpAuthenticationConfiguration */
	ns1__HttpDestinationConfigurationExtension *Extension;	/* optional element of XSD type ns1:HttpDestinationConfigurationExtension */
	char *uri;	/* optional attribute of XSD type xsd:string */
	enum ns1__HttpProtocolType protocol;	/* optional attribute of XSD type ns1:HttpProtocolType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpDestinationConfiguration (1298)
	virtual int soap_type(void) const { return 1298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpDestinationConfiguration, default initialized and not managed by a soap context
	virtual ns1__HttpDestinationConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__HttpDestinationConfiguration); }
	         ns1__HttpDestinationConfiguration() { ns1__HttpDestinationConfiguration::soap_default(NULL); }
	virtual ~ns1__HttpDestinationConfiguration() { }
	friend SOAP_FMAC1 ns1__HttpDestinationConfiguration * SOAP_FMAC2 soap_instantiate_ns1__HttpDestinationConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3861 */
#ifndef SOAP_TYPE_ns1__HttpDestinationConfigurationExtension
#define SOAP_TYPE_ns1__HttpDestinationConfigurationExtension (1299)
/* Type ns1__HttpDestinationConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpDestinationConfigurationExtension complex type: */
class SOAP_CMAC ns1__HttpDestinationConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpDestinationConfigurationExtension (1299)
	virtual int soap_type(void) const { return 1299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpDestinationConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__HttpDestinationConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__HttpDestinationConfigurationExtension); }
	         ns1__HttpDestinationConfigurationExtension() { ns1__HttpDestinationConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__HttpDestinationConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__HttpDestinationConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__HttpDestinationConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3864 */
#ifndef SOAP_TYPE_ns1__HttpAuthenticationConfiguration
#define SOAP_TYPE_ns1__HttpAuthenticationConfiguration (1300)
/* Type ns1__HttpAuthenticationConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpAuthenticationConfiguration complex type: */
class SOAP_CMAC ns1__HttpAuthenticationConfiguration : public xsd__anyType
{
public:
	ns1__UserCredentials *User;	/* optional element of XSD type ns1:UserCredentials */
	ns1__HttpAuthenticationConfigurationExtension *Extension;	/* optional element of XSD type ns1:HttpAuthenticationConfigurationExtension */
	enum ns1__HttpAuthenticationMethodType method;	/* optional attribute of XSD type ns1:HttpAuthenticationMethodType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpAuthenticationConfiguration (1300)
	virtual int soap_type(void) const { return 1300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpAuthenticationConfiguration, default initialized and not managed by a soap context
	virtual ns1__HttpAuthenticationConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__HttpAuthenticationConfiguration); }
	         ns1__HttpAuthenticationConfiguration() { ns1__HttpAuthenticationConfiguration::soap_default(NULL); }
	virtual ~ns1__HttpAuthenticationConfiguration() { }
	friend SOAP_FMAC1 ns1__HttpAuthenticationConfiguration * SOAP_FMAC2 soap_instantiate_ns1__HttpAuthenticationConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3867 */
#ifndef SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension
#define SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension (1301)
/* Type ns1__HttpAuthenticationConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpAuthenticationConfigurationExtension complex type: */
class SOAP_CMAC ns1__HttpAuthenticationConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension (1301)
	virtual int soap_type(void) const { return 1301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpAuthenticationConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__HttpAuthenticationConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__HttpAuthenticationConfigurationExtension); }
	         ns1__HttpAuthenticationConfigurationExtension() { ns1__HttpAuthenticationConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__HttpAuthenticationConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__HttpAuthenticationConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__HttpAuthenticationConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3870 */
#ifndef SOAP_TYPE_ns1__HttpHostAddress
#define SOAP_TYPE_ns1__HttpHostAddress (1302)
/* Type ns1__HttpHostAddress is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:HttpHostAddress complex type: */
class SOAP_CMAC ns1__HttpHostAddress : public xsd__anyType
{
public:
	char *Value;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	enum ns1__AddressFormatType formatType;	/* required attribute of XSD type ns1:AddressFormatType */
	char *portNo;	/* optional attribute of XSD type xsd:integer */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__HttpHostAddress (1302)
	virtual int soap_type(void) const { return 1302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__HttpHostAddress, default initialized and not managed by a soap context
	virtual ns1__HttpHostAddress *soap_alloc(void) const { return SOAP_NEW(ns1__HttpHostAddress); }
	         ns1__HttpHostAddress() { ns1__HttpHostAddress::soap_default(NULL); }
	virtual ~ns1__HttpHostAddress() { }
	friend SOAP_FMAC1 ns1__HttpHostAddress * SOAP_FMAC2 soap_instantiate_ns1__HttpHostAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3873 */
#ifndef SOAP_TYPE_ns1__PostContentConfiguration
#define SOAP_TYPE_ns1__PostContentConfiguration (1303)
/* Type ns1__PostContentConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:PostContentConfiguration complex type: */
class SOAP_CMAC ns1__PostContentConfiguration : public xsd__anyType
{
public:
	ns1__MediaSource *MediaReference;	/* optional element of XSD type ns1:MediaSource */
	ns1__PostBodyConfiguration *PostBody;	/* required element of XSD type ns1:PostBodyConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__PostContentConfiguration (1303)
	virtual int soap_type(void) const { return 1303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__PostContentConfiguration, default initialized and not managed by a soap context
	virtual ns1__PostContentConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__PostContentConfiguration); }
	         ns1__PostContentConfiguration() { ns1__PostContentConfiguration::soap_default(NULL); }
	virtual ~ns1__PostContentConfiguration() { }
	friend SOAP_FMAC1 ns1__PostContentConfiguration * SOAP_FMAC2 soap_instantiate_ns1__PostContentConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3876 */
#ifndef SOAP_TYPE_ns1__PostBodyConfiguration
#define SOAP_TYPE_ns1__PostBodyConfiguration (1304)
/* Type ns1__PostBodyConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:PostBodyConfiguration complex type: */
class SOAP_CMAC ns1__PostBodyConfiguration : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *formData;	/* optional attribute of XSD type xsd:string */
	bool *includeEvent;	/* optional attribute of XSD type xsd:boolean */
	bool *includeMedia;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__PostBodyConfiguration (1304)
	virtual int soap_type(void) const { return 1304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__PostBodyConfiguration, default initialized and not managed by a soap context
	virtual ns1__PostBodyConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__PostBodyConfiguration); }
	         ns1__PostBodyConfiguration() { ns1__PostBodyConfiguration::soap_default(NULL); }
	virtual ~ns1__PostBodyConfiguration() { }
	friend SOAP_FMAC1 ns1__PostBodyConfiguration * SOAP_FMAC2 soap_instantiate_ns1__PostBodyConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3879 */
#ifndef SOAP_TYPE_ns1__FtpHostConfigurations
#define SOAP_TYPE_ns1__FtpHostConfigurations (1305)
/* Type ns1__FtpHostConfigurations is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpHostConfigurations complex type: */
class SOAP_CMAC ns1__FtpHostConfigurations : public xsd__anyType
{
public:
	int __sizeFtpDestination;	/* sequence of elements <FtpDestination> of XSD type ns1:FtpDestinationConfiguration */
	ns1__FtpDestinationConfiguration **FtpDestination;
	ns1__FtpHostConfigurationsExtension *Extension;	/* optional element of XSD type ns1:FtpHostConfigurationsExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpHostConfigurations (1305)
	virtual int soap_type(void) const { return 1305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpHostConfigurations, default initialized and not managed by a soap context
	virtual ns1__FtpHostConfigurations *soap_alloc(void) const { return SOAP_NEW(ns1__FtpHostConfigurations); }
	         ns1__FtpHostConfigurations() { ns1__FtpHostConfigurations::soap_default(NULL); }
	virtual ~ns1__FtpHostConfigurations() { }
	friend SOAP_FMAC1 ns1__FtpHostConfigurations * SOAP_FMAC2 soap_instantiate_ns1__FtpHostConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3882 */
#ifndef SOAP_TYPE_ns1__FtpHostConfigurationsExtension
#define SOAP_TYPE_ns1__FtpHostConfigurationsExtension (1306)
/* Type ns1__FtpHostConfigurationsExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpHostConfigurationsExtension complex type: */
class SOAP_CMAC ns1__FtpHostConfigurationsExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpHostConfigurationsExtension (1306)
	virtual int soap_type(void) const { return 1306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpHostConfigurationsExtension, default initialized and not managed by a soap context
	virtual ns1__FtpHostConfigurationsExtension *soap_alloc(void) const { return SOAP_NEW(ns1__FtpHostConfigurationsExtension); }
	         ns1__FtpHostConfigurationsExtension() { ns1__FtpHostConfigurationsExtension::soap_default(NULL); }
	virtual ~ns1__FtpHostConfigurationsExtension() { }
	friend SOAP_FMAC1 ns1__FtpHostConfigurationsExtension * SOAP_FMAC2 soap_instantiate_ns1__FtpHostConfigurationsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3885 */
#ifndef SOAP_TYPE_ns1__FtpDestinationConfiguration
#define SOAP_TYPE_ns1__FtpDestinationConfiguration (1307)
/* Type ns1__FtpDestinationConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpDestinationConfiguration complex type: */
class SOAP_CMAC ns1__FtpDestinationConfiguration : public xsd__anyType
{
public:
	ns1__FtpHostAddress *HostAddress;	/* required element of XSD type ns1:FtpHostAddress */
	char *UploadPath;	/* required element of XSD type xsd:string */
	ns1__FtpAuthenticationConfiguration *FtpAuthentication;	/* required element of XSD type ns1:FtpAuthenticationConfiguration */
	ns1__FtpDestinationConfigurationExtension *Extension;	/* optional element of XSD type ns1:FtpDestinationConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpDestinationConfiguration (1307)
	virtual int soap_type(void) const { return 1307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpDestinationConfiguration, default initialized and not managed by a soap context
	virtual ns1__FtpDestinationConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__FtpDestinationConfiguration); }
	         ns1__FtpDestinationConfiguration() { ns1__FtpDestinationConfiguration::soap_default(NULL); }
	virtual ~ns1__FtpDestinationConfiguration() { }
	friend SOAP_FMAC1 ns1__FtpDestinationConfiguration * SOAP_FMAC2 soap_instantiate_ns1__FtpDestinationConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3888 */
#ifndef SOAP_TYPE_ns1__FtpDestinationConfigurationExtension
#define SOAP_TYPE_ns1__FtpDestinationConfigurationExtension (1308)
/* Type ns1__FtpDestinationConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpDestinationConfigurationExtension complex type: */
class SOAP_CMAC ns1__FtpDestinationConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpDestinationConfigurationExtension (1308)
	virtual int soap_type(void) const { return 1308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpDestinationConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__FtpDestinationConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__FtpDestinationConfigurationExtension); }
	         ns1__FtpDestinationConfigurationExtension() { ns1__FtpDestinationConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__FtpDestinationConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__FtpDestinationConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__FtpDestinationConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3891 */
#ifndef SOAP_TYPE_ns1__FtpAuthenticationConfiguration
#define SOAP_TYPE_ns1__FtpAuthenticationConfiguration (1309)
/* Type ns1__FtpAuthenticationConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpAuthenticationConfiguration complex type: */
class SOAP_CMAC ns1__FtpAuthenticationConfiguration : public xsd__anyType
{
public:
	ns1__UserCredentials *User;	/* optional element of XSD type ns1:UserCredentials */
	ns1__FtpAuthenticationConfigurationExtension *Extension;	/* optional element of XSD type ns1:FtpAuthenticationConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpAuthenticationConfiguration (1309)
	virtual int soap_type(void) const { return 1309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpAuthenticationConfiguration, default initialized and not managed by a soap context
	virtual ns1__FtpAuthenticationConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__FtpAuthenticationConfiguration); }
	         ns1__FtpAuthenticationConfiguration() { ns1__FtpAuthenticationConfiguration::soap_default(NULL); }
	virtual ~ns1__FtpAuthenticationConfiguration() { }
	friend SOAP_FMAC1 ns1__FtpAuthenticationConfiguration * SOAP_FMAC2 soap_instantiate_ns1__FtpAuthenticationConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3894 */
#ifndef SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension
#define SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension (1310)
/* Type ns1__FtpAuthenticationConfigurationExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpAuthenticationConfigurationExtension complex type: */
class SOAP_CMAC ns1__FtpAuthenticationConfigurationExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension (1310)
	virtual int soap_type(void) const { return 1310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpAuthenticationConfigurationExtension, default initialized and not managed by a soap context
	virtual ns1__FtpAuthenticationConfigurationExtension *soap_alloc(void) const { return SOAP_NEW(ns1__FtpAuthenticationConfigurationExtension); }
	         ns1__FtpAuthenticationConfigurationExtension() { ns1__FtpAuthenticationConfigurationExtension::soap_default(NULL); }
	virtual ~ns1__FtpAuthenticationConfigurationExtension() { }
	friend SOAP_FMAC1 ns1__FtpAuthenticationConfigurationExtension * SOAP_FMAC2 soap_instantiate_ns1__FtpAuthenticationConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3897 */
#ifndef SOAP_TYPE_ns1__FtpHostAddress
#define SOAP_TYPE_ns1__FtpHostAddress (1311)
/* Type ns1__FtpHostAddress is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpHostAddress complex type: */
class SOAP_CMAC ns1__FtpHostAddress : public xsd__anyType
{
public:
	char *Value;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	enum ns1__AddressFormatType formatType;	/* required attribute of XSD type ns1:AddressFormatType */
	char *portNo;	/* optional attribute of XSD type xsd:integer */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpHostAddress (1311)
	virtual int soap_type(void) const { return 1311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpHostAddress, default initialized and not managed by a soap context
	virtual ns1__FtpHostAddress *soap_alloc(void) const { return SOAP_NEW(ns1__FtpHostAddress); }
	         ns1__FtpHostAddress() { ns1__FtpHostAddress::soap_default(NULL); }
	virtual ~ns1__FtpHostAddress() { }
	friend SOAP_FMAC1 ns1__FtpHostAddress * SOAP_FMAC2 soap_instantiate_ns1__FtpHostAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3900 */
#ifndef SOAP_TYPE_ns1__FtpContent
#define SOAP_TYPE_ns1__FtpContent (1312)
/* Type ns1__FtpContent is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpContent complex type: */
class SOAP_CMAC ns1__FtpContent : public xsd__anyType
{
public:
	ns1__FtpContentConfiguration *FtpContentConfig;	/* required element of XSD type ns1:FtpContentConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpContent (1312)
	virtual int soap_type(void) const { return 1312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpContent, default initialized and not managed by a soap context
	virtual ns1__FtpContent *soap_alloc(void) const { return SOAP_NEW(ns1__FtpContent); }
	         ns1__FtpContent() { ns1__FtpContent::soap_default(NULL); }
	virtual ~ns1__FtpContent() { }
	friend SOAP_FMAC1 ns1__FtpContent * SOAP_FMAC2 soap_instantiate_ns1__FtpContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3903 */
#ifndef SOAP_TYPE_ns1__FtpFileNameConfigurations
#define SOAP_TYPE_ns1__FtpFileNameConfigurations (1313)
/* Type ns1__FtpFileNameConfigurations is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpFileNameConfigurations complex type: */
class SOAP_CMAC ns1__FtpFileNameConfigurations : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *file_USCOREname;	/* optional attribute of XSD type xsd:string */
	enum ns1__FileSuffixType suffix;	/* optional attribute of XSD type ns1:FileSuffixType */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpFileNameConfigurations (1313)
	virtual int soap_type(void) const { return 1313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpFileNameConfigurations, default initialized and not managed by a soap context
	virtual ns1__FtpFileNameConfigurations *soap_alloc(void) const { return SOAP_NEW(ns1__FtpFileNameConfigurations); }
	         ns1__FtpFileNameConfigurations() { ns1__FtpFileNameConfigurations::soap_default(NULL); }
	virtual ~ns1__FtpFileNameConfigurations() { }
	friend SOAP_FMAC1 ns1__FtpFileNameConfigurations * SOAP_FMAC2 soap_instantiate_ns1__FtpFileNameConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:39300 */
#ifndef SOAP_TYPE__ns1__union_FtpContentConfiguration
#define SOAP_TYPE__ns1__union_FtpContentConfiguration (2237)
/* xsd:choice complex type: */
union _ns1__union_FtpContentConfiguration
{
#define SOAP_UNION__ns1__union_FtpContentConfiguration_UploadImages	(1)
	ns1__FtpContentConfigurationUploadImages *UploadImages;
#define SOAP_UNION__ns1__union_FtpContentConfiguration_UploadFile	(2)
	ns1__FtpContentConfigurationUploadFile *UploadFile;
};
#endif

/* ../../wsdl/onvif.h:3906 */
#ifndef SOAP_TYPE_ns1__FtpContentConfiguration
#define SOAP_TYPE_ns1__FtpContentConfiguration (1314)
/* Type ns1__FtpContentConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpContentConfiguration complex type: */
class SOAP_CMAC ns1__FtpContentConfiguration : public xsd__anyType
{
public:
	int __union_FtpContentConfiguration;	/* union discriminant (of union defined below) */
	union _ns1__union_FtpContentConfiguration union_FtpContentConfiguration;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *Type;	/* required attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpContentConfiguration (1314)
	virtual int soap_type(void) const { return 1314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpContentConfiguration, default initialized and not managed by a soap context
	virtual ns1__FtpContentConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__FtpContentConfiguration); }
	         ns1__FtpContentConfiguration() { ns1__FtpContentConfiguration::soap_default(NULL); }
	virtual ~ns1__FtpContentConfiguration() { }
	friend SOAP_FMAC1 ns1__FtpContentConfiguration * SOAP_FMAC2 soap_instantiate_ns1__FtpContentConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3909 */
#ifndef SOAP_TYPE_ns1__FtpContentConfigurationUploadImages
#define SOAP_TYPE_ns1__FtpContentConfigurationUploadImages (1315)
/* Type ns1__FtpContentConfigurationUploadImages is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpContentConfigurationUploadImages complex type: */
class SOAP_CMAC ns1__FtpContentConfigurationUploadImages : public xsd__anyType
{
public:
	LONG64 HowLong;	/* external (custom serializer) */
	LONG64 SampleInterval;	/* external (custom serializer) */
	ns1__FtpFileNameConfigurations *FileName;	/* required element of XSD type ns1:FtpFileNameConfigurations */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpContentConfigurationUploadImages (1315)
	virtual int soap_type(void) const { return 1315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpContentConfigurationUploadImages, default initialized and not managed by a soap context
	virtual ns1__FtpContentConfigurationUploadImages *soap_alloc(void) const { return SOAP_NEW(ns1__FtpContentConfigurationUploadImages); }
	         ns1__FtpContentConfigurationUploadImages() { ns1__FtpContentConfigurationUploadImages::soap_default(NULL); }
	virtual ~ns1__FtpContentConfigurationUploadImages() { }
	friend SOAP_FMAC1 ns1__FtpContentConfigurationUploadImages * SOAP_FMAC2 soap_instantiate_ns1__FtpContentConfigurationUploadImages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3912 */
#ifndef SOAP_TYPE_ns1__FtpContentConfigurationUploadFile
#define SOAP_TYPE_ns1__FtpContentConfigurationUploadFile (1316)
/* Type ns1__FtpContentConfigurationUploadFile is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:FtpContentConfigurationUploadFile complex type: */
class SOAP_CMAC ns1__FtpContentConfigurationUploadFile : public xsd__anyType
{
public:
	char *sourceFileName;	/* required element of XSD type xsd:string */
	char *destinationFileName;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__FtpContentConfigurationUploadFile (1316)
	virtual int soap_type(void) const { return 1316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FtpContentConfigurationUploadFile, default initialized and not managed by a soap context
	virtual ns1__FtpContentConfigurationUploadFile *soap_alloc(void) const { return SOAP_NEW(ns1__FtpContentConfigurationUploadFile); }
	         ns1__FtpContentConfigurationUploadFile() { ns1__FtpContentConfigurationUploadFile::soap_default(NULL); }
	virtual ~ns1__FtpContentConfigurationUploadFile() { }
	friend SOAP_FMAC1 ns1__FtpContentConfigurationUploadFile * SOAP_FMAC2 soap_instantiate_ns1__FtpContentConfigurationUploadFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3915 */
#ifndef SOAP_TYPE_ns1__SMSProviderConfiguration
#define SOAP_TYPE_ns1__SMSProviderConfiguration (1317)
/* Type ns1__SMSProviderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SMSProviderConfiguration complex type: */
class SOAP_CMAC ns1__SMSProviderConfiguration : public xsd__anyType
{
public:
	char *ProviderURL;	/* required element of XSD type xsd:anyURI */
	ns1__UserCredentials *User;	/* required element of XSD type ns1:UserCredentials */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SMSProviderConfiguration (1317)
	virtual int soap_type(void) const { return 1317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SMSProviderConfiguration, default initialized and not managed by a soap context
	virtual ns1__SMSProviderConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__SMSProviderConfiguration); }
	         ns1__SMSProviderConfiguration() { ns1__SMSProviderConfiguration::soap_default(NULL); }
	virtual ~ns1__SMSProviderConfiguration() { }
	friend SOAP_FMAC1 ns1__SMSProviderConfiguration * SOAP_FMAC2 soap_instantiate_ns1__SMSProviderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3918 */
#ifndef SOAP_TYPE_ns1__SMSSenderConfiguration
#define SOAP_TYPE_ns1__SMSSenderConfiguration (1318)
/* Type ns1__SMSSenderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SMSSenderConfiguration complex type: */
class SOAP_CMAC ns1__SMSSenderConfiguration : public xsd__anyType
{
public:
	char *EMail;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SMSSenderConfiguration (1318)
	virtual int soap_type(void) const { return 1318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SMSSenderConfiguration, default initialized and not managed by a soap context
	virtual ns1__SMSSenderConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__SMSSenderConfiguration); }
	         ns1__SMSSenderConfiguration() { ns1__SMSSenderConfiguration::soap_default(NULL); }
	virtual ~ns1__SMSSenderConfiguration() { }
	friend SOAP_FMAC1 ns1__SMSSenderConfiguration * SOAP_FMAC2 soap_instantiate_ns1__SMSSenderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3921 */
#ifndef SOAP_TYPE_ns1__SMSMessage
#define SOAP_TYPE_ns1__SMSMessage (1319)
/* Type ns1__SMSMessage is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:SMSMessage complex type: */
class SOAP_CMAC ns1__SMSMessage : public xsd__anyType
{
public:
	char *Text;	/* required element of XSD type xsd:string */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SMSMessage (1319)
	virtual int soap_type(void) const { return 1319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SMSMessage, default initialized and not managed by a soap context
	virtual ns1__SMSMessage *soap_alloc(void) const { return SOAP_NEW(ns1__SMSMessage); }
	         ns1__SMSMessage() { ns1__SMSMessage::soap_default(NULL); }
	virtual ~ns1__SMSMessage() { }
	friend SOAP_FMAC1 ns1__SMSMessage * SOAP_FMAC2 soap_instantiate_ns1__SMSMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3924 */
#ifndef SOAP_TYPE_ns1__TriggeredRecordingConfiguration
#define SOAP_TYPE_ns1__TriggeredRecordingConfiguration (1320)
/* Type ns1__TriggeredRecordingConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:TriggeredRecordingConfiguration complex type: */
class SOAP_CMAC ns1__TriggeredRecordingConfiguration : public xsd__anyType
{
public:
	LONG64 PreRecordDuration;	/* external (custom serializer) */
	LONG64 PostRecordDuration;	/* external (custom serializer) */
	LONG64 RecordDuration;	/* external (custom serializer) */
	char *RecordFrameRate;	/* optional element of XSD type xsd:positiveInteger */
	bool DoRecordAudio;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__TriggeredRecordingConfiguration (1320)
	virtual int soap_type(void) const { return 1320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__TriggeredRecordingConfiguration, default initialized and not managed by a soap context
	virtual ns1__TriggeredRecordingConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__TriggeredRecordingConfiguration); }
	         ns1__TriggeredRecordingConfiguration() { ns1__TriggeredRecordingConfiguration::soap_default(NULL); }
	virtual ~ns1__TriggeredRecordingConfiguration() { }
	friend SOAP_FMAC1 ns1__TriggeredRecordingConfiguration * SOAP_FMAC2 soap_instantiate_ns1__TriggeredRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3927 */
#ifndef SOAP_TYPE_ns1__RecordingActionConfiguration
#define SOAP_TYPE_ns1__RecordingActionConfiguration (1321)
/* Type ns1__RecordingActionConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns1:RecordingActionConfiguration complex type: */
class SOAP_CMAC ns1__RecordingActionConfiguration : public xsd__anyType
{
public:
	ns1__TriggeredRecordingConfiguration *RecordConfig;	/* required element of XSD type ns1:TriggeredRecordingConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__RecordingActionConfiguration (1321)
	virtual int soap_type(void) const { return 1321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__RecordingActionConfiguration, default initialized and not managed by a soap context
	virtual ns1__RecordingActionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns1__RecordingActionConfiguration); }
	         ns1__RecordingActionConfiguration() { ns1__RecordingActionConfiguration::soap_default(NULL); }
	virtual ~ns1__RecordingActionConfiguration() { }
	friend SOAP_FMAC1 ns1__RecordingActionConfiguration * SOAP_FMAC2 soap_instantiate_ns1__RecordingActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3930 */
#ifndef SOAP_TYPE__ns1__GetSupportedActions
#define SOAP_TYPE__ns1__GetSupportedActions (1322)
/* ns1:GetSupportedActions complex type: */
class SOAP_CMAC _ns1__GetSupportedActions
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetSupportedActions (1322)
	virtual int soap_type(void) const { return 1322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetSupportedActions, default initialized and not managed by a soap context
	virtual _ns1__GetSupportedActions *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSupportedActions); }
	         _ns1__GetSupportedActions() { _ns1__GetSupportedActions::soap_default(NULL); }
	virtual ~_ns1__GetSupportedActions() { }
	friend SOAP_FMAC1 _ns1__GetSupportedActions * SOAP_FMAC2 soap_instantiate__ns1__GetSupportedActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3933 */
#ifndef SOAP_TYPE__ns1__GetSupportedActionsResponse
#define SOAP_TYPE__ns1__GetSupportedActionsResponse (1323)
/* ns1:GetSupportedActionsResponse complex type: */
class SOAP_CMAC _ns1__GetSupportedActionsResponse
{
public:
	ns1__SupportedActions *SupportedActions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns1:SupportedActions */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetSupportedActionsResponse (1323)
	virtual int soap_type(void) const { return 1323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetSupportedActionsResponse, default initialized and not managed by a soap context
	virtual _ns1__GetSupportedActionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSupportedActionsResponse); }
	         _ns1__GetSupportedActionsResponse() { _ns1__GetSupportedActionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetSupportedActionsResponse() { }
	friend SOAP_FMAC1 _ns1__GetSupportedActionsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSupportedActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3936 */
#ifndef SOAP_TYPE__ns1__GetActions
#define SOAP_TYPE__ns1__GetActions (1324)
/* ns1:GetActions complex type: */
class SOAP_CMAC _ns1__GetActions
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetActions (1324)
	virtual int soap_type(void) const { return 1324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetActions, default initialized and not managed by a soap context
	virtual _ns1__GetActions *soap_alloc(void) const { return SOAP_NEW(_ns1__GetActions); }
	         _ns1__GetActions() { _ns1__GetActions::soap_default(NULL); }
	virtual ~_ns1__GetActions() { }
	friend SOAP_FMAC1 _ns1__GetActions * SOAP_FMAC2 soap_instantiate__ns1__GetActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3939 */
#ifndef SOAP_TYPE__ns1__GetActionsResponse
#define SOAP_TYPE__ns1__GetActionsResponse (1325)
/* ns1:GetActionsResponse complex type: */
class SOAP_CMAC _ns1__GetActionsResponse
{
public:
	int __sizeAction;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Action> of XSD type ns1:Action */
	ns1__Action **Action;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetActionsResponse (1325)
	virtual int soap_type(void) const { return 1325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetActionsResponse, default initialized and not managed by a soap context
	virtual _ns1__GetActionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetActionsResponse); }
	         _ns1__GetActionsResponse() { _ns1__GetActionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetActionsResponse() { }
	friend SOAP_FMAC1 _ns1__GetActionsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3942 */
#ifndef SOAP_TYPE__ns1__CreateActions
#define SOAP_TYPE__ns1__CreateActions (1326)
/* ns1:CreateActions complex type: */
class SOAP_CMAC _ns1__CreateActions
{
public:
	int __sizeAction;	/* sequence of elements <Action> of XSD type ns1:ActionConfiguration */
	ns1__ActionConfiguration **Action;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__CreateActions (1326)
	virtual int soap_type(void) const { return 1326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CreateActions, default initialized and not managed by a soap context
	virtual _ns1__CreateActions *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateActions); }
	         _ns1__CreateActions() { _ns1__CreateActions::soap_default(NULL); }
	virtual ~_ns1__CreateActions() { }
	friend SOAP_FMAC1 _ns1__CreateActions * SOAP_FMAC2 soap_instantiate__ns1__CreateActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3945 */
#ifndef SOAP_TYPE__ns1__CreateActionsResponse
#define SOAP_TYPE__ns1__CreateActionsResponse (1327)
/* ns1:CreateActionsResponse complex type: */
class SOAP_CMAC _ns1__CreateActionsResponse
{
public:
	int __sizeAction;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Action> of XSD type ns1:Action */
	ns1__Action **Action;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__CreateActionsResponse (1327)
	virtual int soap_type(void) const { return 1327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CreateActionsResponse, default initialized and not managed by a soap context
	virtual _ns1__CreateActionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateActionsResponse); }
	         _ns1__CreateActionsResponse() { _ns1__CreateActionsResponse::soap_default(NULL); }
	virtual ~_ns1__CreateActionsResponse() { }
	friend SOAP_FMAC1 _ns1__CreateActionsResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3948 */
#ifndef SOAP_TYPE__ns1__DeleteActions
#define SOAP_TYPE__ns1__DeleteActions (1328)
/* ns1:DeleteActions complex type: */
class SOAP_CMAC _ns1__DeleteActions
{
public:
	int __sizeToken;	/* sequence of elements <Token> of XSD type tt:ReferenceToken */
	char **Token;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__DeleteActions (1328)
	virtual int soap_type(void) const { return 1328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DeleteActions, default initialized and not managed by a soap context
	virtual _ns1__DeleteActions *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteActions); }
	         _ns1__DeleteActions() { _ns1__DeleteActions::soap_default(NULL); }
	virtual ~_ns1__DeleteActions() { }
	friend SOAP_FMAC1 _ns1__DeleteActions * SOAP_FMAC2 soap_instantiate__ns1__DeleteActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3951 */
#ifndef SOAP_TYPE__ns1__DeleteActionsResponse
#define SOAP_TYPE__ns1__DeleteActionsResponse (1329)
/* ns1:DeleteActionsResponse complex type: */
class SOAP_CMAC _ns1__DeleteActionsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__DeleteActionsResponse (1329)
	virtual int soap_type(void) const { return 1329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DeleteActionsResponse, default initialized and not managed by a soap context
	virtual _ns1__DeleteActionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteActionsResponse); }
	         _ns1__DeleteActionsResponse() { _ns1__DeleteActionsResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteActionsResponse() { }
	friend SOAP_FMAC1 _ns1__DeleteActionsResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3954 */
#ifndef SOAP_TYPE__ns1__ModifyActions
#define SOAP_TYPE__ns1__ModifyActions (1330)
/* ns1:ModifyActions complex type: */
class SOAP_CMAC _ns1__ModifyActions
{
public:
	int __sizeAction;	/* sequence of elements <Action> of XSD type ns1:Action */
	ns1__Action **Action;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__ModifyActions (1330)
	virtual int soap_type(void) const { return 1330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ModifyActions, default initialized and not managed by a soap context
	virtual _ns1__ModifyActions *soap_alloc(void) const { return SOAP_NEW(_ns1__ModifyActions); }
	         _ns1__ModifyActions() { _ns1__ModifyActions::soap_default(NULL); }
	virtual ~_ns1__ModifyActions() { }
	friend SOAP_FMAC1 _ns1__ModifyActions * SOAP_FMAC2 soap_instantiate__ns1__ModifyActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3957 */
#ifndef SOAP_TYPE__ns1__ModifyActionsResponse
#define SOAP_TYPE__ns1__ModifyActionsResponse (1331)
/* ns1:ModifyActionsResponse complex type: */
class SOAP_CMAC _ns1__ModifyActionsResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__ModifyActionsResponse (1331)
	virtual int soap_type(void) const { return 1331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ModifyActionsResponse, default initialized and not managed by a soap context
	virtual _ns1__ModifyActionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ModifyActionsResponse); }
	         _ns1__ModifyActionsResponse() { _ns1__ModifyActionsResponse::soap_default(NULL); }
	virtual ~_ns1__ModifyActionsResponse() { }
	friend SOAP_FMAC1 _ns1__ModifyActionsResponse * SOAP_FMAC2 soap_instantiate__ns1__ModifyActionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3960 */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilities
#define SOAP_TYPE__ns1__GetServiceCapabilities (1332)
/* ns1:GetServiceCapabilities complex type: */
class SOAP_CMAC _ns1__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetServiceCapabilities (1332)
	virtual int soap_type(void) const { return 1332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _ns1__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServiceCapabilities); }
	         _ns1__GetServiceCapabilities() { _ns1__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _ns1__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns1__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3963 */
#ifndef SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (1333)
/* ns1:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _ns1__GetServiceCapabilitiesResponse
{
public:
	ns1__ActionEngineCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns1:ActionEngineCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (1333)
	virtual int soap_type(void) const { return 1333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _ns1__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetServiceCapabilitiesResponse); }
	         _ns1__GetServiceCapabilitiesResponse() { _ns1__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _ns1__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3966 */
#ifndef SOAP_TYPE__ns1__GetActionTriggers
#define SOAP_TYPE__ns1__GetActionTriggers (1334)
/* ns1:GetActionTriggers complex type: */
class SOAP_CMAC _ns1__GetActionTriggers
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetActionTriggers (1334)
	virtual int soap_type(void) const { return 1334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetActionTriggers, default initialized and not managed by a soap context
	virtual _ns1__GetActionTriggers *soap_alloc(void) const { return SOAP_NEW(_ns1__GetActionTriggers); }
	         _ns1__GetActionTriggers() { _ns1__GetActionTriggers::soap_default(NULL); }
	virtual ~_ns1__GetActionTriggers() { }
	friend SOAP_FMAC1 _ns1__GetActionTriggers * SOAP_FMAC2 soap_instantiate__ns1__GetActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3969 */
#ifndef SOAP_TYPE__ns1__GetActionTriggersResponse
#define SOAP_TYPE__ns1__GetActionTriggersResponse (1335)
/* ns1:GetActionTriggersResponse complex type: */
class SOAP_CMAC _ns1__GetActionTriggersResponse
{
public:
	int __sizeActionTrigger;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ActionTrigger> of XSD type ns1:ActionTrigger */
	ns1__ActionTrigger **ActionTrigger;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__GetActionTriggersResponse (1335)
	virtual int soap_type(void) const { return 1335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__GetActionTriggersResponse, default initialized and not managed by a soap context
	virtual _ns1__GetActionTriggersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetActionTriggersResponse); }
	         _ns1__GetActionTriggersResponse() { _ns1__GetActionTriggersResponse::soap_default(NULL); }
	virtual ~_ns1__GetActionTriggersResponse() { }
	friend SOAP_FMAC1 _ns1__GetActionTriggersResponse * SOAP_FMAC2 soap_instantiate__ns1__GetActionTriggersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3972 */
#ifndef SOAP_TYPE__ns1__CreateActionTriggers
#define SOAP_TYPE__ns1__CreateActionTriggers (1336)
/* ns1:CreateActionTriggers complex type: */
class SOAP_CMAC _ns1__CreateActionTriggers
{
public:
	int __sizeActionTrigger;	/* sequence of elements <ActionTrigger> of XSD type ns1:ActionTriggerConfiguration */
	ns1__ActionTriggerConfiguration **ActionTrigger;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__CreateActionTriggers (1336)
	virtual int soap_type(void) const { return 1336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CreateActionTriggers, default initialized and not managed by a soap context
	virtual _ns1__CreateActionTriggers *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateActionTriggers); }
	         _ns1__CreateActionTriggers() { _ns1__CreateActionTriggers::soap_default(NULL); }
	virtual ~_ns1__CreateActionTriggers() { }
	friend SOAP_FMAC1 _ns1__CreateActionTriggers * SOAP_FMAC2 soap_instantiate__ns1__CreateActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3975 */
#ifndef SOAP_TYPE__ns1__CreateActionTriggersResponse
#define SOAP_TYPE__ns1__CreateActionTriggersResponse (1337)
/* ns1:CreateActionTriggersResponse complex type: */
class SOAP_CMAC _ns1__CreateActionTriggersResponse
{
public:
	int __sizeActionTrigger;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <ActionTrigger> of XSD type ns1:ActionTrigger */
	ns1__ActionTrigger **ActionTrigger;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__CreateActionTriggersResponse (1337)
	virtual int soap_type(void) const { return 1337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CreateActionTriggersResponse, default initialized and not managed by a soap context
	virtual _ns1__CreateActionTriggersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateActionTriggersResponse); }
	         _ns1__CreateActionTriggersResponse() { _ns1__CreateActionTriggersResponse::soap_default(NULL); }
	virtual ~_ns1__CreateActionTriggersResponse() { }
	friend SOAP_FMAC1 _ns1__CreateActionTriggersResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateActionTriggersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3978 */
#ifndef SOAP_TYPE__ns1__ModifyActionTriggers
#define SOAP_TYPE__ns1__ModifyActionTriggers (1338)
/* ns1:ModifyActionTriggers complex type: */
class SOAP_CMAC _ns1__ModifyActionTriggers
{
public:
	int __sizeActionTrigger;	/* sequence of elements <ActionTrigger> of XSD type ns1:ActionTrigger */
	ns1__ActionTrigger **ActionTrigger;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__ModifyActionTriggers (1338)
	virtual int soap_type(void) const { return 1338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ModifyActionTriggers, default initialized and not managed by a soap context
	virtual _ns1__ModifyActionTriggers *soap_alloc(void) const { return SOAP_NEW(_ns1__ModifyActionTriggers); }
	         _ns1__ModifyActionTriggers() { _ns1__ModifyActionTriggers::soap_default(NULL); }
	virtual ~_ns1__ModifyActionTriggers() { }
	friend SOAP_FMAC1 _ns1__ModifyActionTriggers * SOAP_FMAC2 soap_instantiate__ns1__ModifyActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3981 */
#ifndef SOAP_TYPE__ns1__ModifyActionTriggersResponse
#define SOAP_TYPE__ns1__ModifyActionTriggersResponse (1339)
/* ns1:ModifyActionTriggersResponse complex type: */
class SOAP_CMAC _ns1__ModifyActionTriggersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__ModifyActionTriggersResponse (1339)
	virtual int soap_type(void) const { return 1339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ModifyActionTriggersResponse, default initialized and not managed by a soap context
	virtual _ns1__ModifyActionTriggersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ModifyActionTriggersResponse); }
	         _ns1__ModifyActionTriggersResponse() { _ns1__ModifyActionTriggersResponse::soap_default(NULL); }
	virtual ~_ns1__ModifyActionTriggersResponse() { }
	friend SOAP_FMAC1 _ns1__ModifyActionTriggersResponse * SOAP_FMAC2 soap_instantiate__ns1__ModifyActionTriggersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3984 */
#ifndef SOAP_TYPE__ns1__DeleteActionTriggers
#define SOAP_TYPE__ns1__DeleteActionTriggers (1340)
/* ns1:DeleteActionTriggers complex type: */
class SOAP_CMAC _ns1__DeleteActionTriggers
{
public:
	int __sizeToken;	/* sequence of elements <Token> of XSD type tt:ReferenceToken */
	char **Token;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__DeleteActionTriggers (1340)
	virtual int soap_type(void) const { return 1340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DeleteActionTriggers, default initialized and not managed by a soap context
	virtual _ns1__DeleteActionTriggers *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteActionTriggers); }
	         _ns1__DeleteActionTriggers() { _ns1__DeleteActionTriggers::soap_default(NULL); }
	virtual ~_ns1__DeleteActionTriggers() { }
	friend SOAP_FMAC1 _ns1__DeleteActionTriggers * SOAP_FMAC2 soap_instantiate__ns1__DeleteActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3987 */
#ifndef SOAP_TYPE__ns1__DeleteActionTriggersResponse
#define SOAP_TYPE__ns1__DeleteActionTriggersResponse (1341)
/* ns1:DeleteActionTriggersResponse complex type: */
class SOAP_CMAC _ns1__DeleteActionTriggersResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns1__DeleteActionTriggersResponse (1341)
	virtual int soap_type(void) const { return 1341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DeleteActionTriggersResponse, default initialized and not managed by a soap context
	virtual _ns1__DeleteActionTriggersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteActionTriggersResponse); }
	         _ns1__DeleteActionTriggersResponse() { _ns1__DeleteActionTriggersResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteActionTriggersResponse() { }
	friend SOAP_FMAC1 _ns1__DeleteActionTriggersResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteActionTriggersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3990 */
#ifndef SOAP_TYPE_ns2__ServiceCapabilities
#define SOAP_TYPE_ns2__ServiceCapabilities (1342)
/* Type ns2__ServiceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:ServiceCapabilities complex type: */
class SOAP_CMAC ns2__ServiceCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	unsigned int MaxLimit;	/* required attribute of XSD type xsd:unsignedInt */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__ServiceCapabilities (1342)
	virtual int soap_type(void) const { return 1342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__ServiceCapabilities, default initialized and not managed by a soap context
	virtual ns2__ServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__ServiceCapabilities); }
	         ns2__ServiceCapabilities() { ns2__ServiceCapabilities::soap_default(NULL); }
	virtual ~ns2__ServiceCapabilities() { }
	friend SOAP_FMAC1 ns2__ServiceCapabilities * SOAP_FMAC2 soap_instantiate_ns2__ServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3999 */
#ifndef SOAP_TYPE_ns2__AccessPointCapabilities
#define SOAP_TYPE_ns2__AccessPointCapabilities (1345)
/* Type ns2__AccessPointCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AccessPointCapabilities complex type: */
class SOAP_CMAC ns2__AccessPointCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool DisableAccessPoint;	/* required attribute of XSD type xsd:boolean */
	bool *Duress;	/* optional attribute of XSD type xsd:boolean */
	bool *AnonymousAccess;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessTaken;	/* optional attribute of XSD type xsd:boolean */
	bool *ExternalAuthorization;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AccessPointCapabilities (1345)
	virtual int soap_type(void) const { return 1345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AccessPointCapabilities, default initialized and not managed by a soap context
	virtual ns2__AccessPointCapabilities *soap_alloc(void) const { return SOAP_NEW(ns2__AccessPointCapabilities); }
	         ns2__AccessPointCapabilities() { ns2__AccessPointCapabilities::soap_default(NULL); }
	virtual ~ns2__AccessPointCapabilities() { }
	friend SOAP_FMAC1 ns2__AccessPointCapabilities * SOAP_FMAC2 soap_instantiate_ns2__AccessPointCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4008 */
#ifndef SOAP_TYPE_ns2__AccessPointState
#define SOAP_TYPE_ns2__AccessPointState (1348)
/* Type ns2__AccessPointState is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AccessPointState complex type: */
class SOAP_CMAC ns2__AccessPointState : public xsd__anyType
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AccessPointState (1348)
	virtual int soap_type(void) const { return 1348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AccessPointState, default initialized and not managed by a soap context
	virtual ns2__AccessPointState *soap_alloc(void) const { return SOAP_NEW(ns2__AccessPointState); }
	         ns2__AccessPointState() { ns2__AccessPointState::soap_default(NULL); }
	virtual ~ns2__AccessPointState() { }
	friend SOAP_FMAC1 ns2__AccessPointState * SOAP_FMAC2 soap_instantiate_ns2__AccessPointState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4011 */
#ifndef SOAP_TYPE__ns2__GetServiceCapabilities
#define SOAP_TYPE__ns2__GetServiceCapabilities (1349)
/* ns2:GetServiceCapabilities complex type: */
class SOAP_CMAC _ns2__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetServiceCapabilities (1349)
	virtual int soap_type(void) const { return 1349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _ns2__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns2__GetServiceCapabilities); }
	         _ns2__GetServiceCapabilities() { _ns2__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_ns2__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _ns2__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns2__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4014 */
#ifndef SOAP_TYPE__ns2__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns2__GetServiceCapabilitiesResponse (1350)
/* ns2:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _ns2__GetServiceCapabilitiesResponse
{
public:
	ns2__ServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns2:ServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetServiceCapabilitiesResponse (1350)
	virtual int soap_type(void) const { return 1350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _ns2__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetServiceCapabilitiesResponse); }
	         _ns2__GetServiceCapabilitiesResponse() { _ns2__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_ns2__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _ns2__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns2__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4017 */
#ifndef SOAP_TYPE__ns2__GetAccessPointInfoList
#define SOAP_TYPE__ns2__GetAccessPointInfoList (1351)
/* ns2:GetAccessPointInfoList complex type: */
class SOAP_CMAC _ns2__GetAccessPointInfoList
{
public:
	int *Limit;	/* optional element of XSD type xsd:int */
	char *StartReference;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointInfoList (1351)
	virtual int soap_type(void) const { return 1351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointInfoList, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointInfoList *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointInfoList); }
	         _ns2__GetAccessPointInfoList() { _ns2__GetAccessPointInfoList::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointInfoList() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointInfoList * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4020 */
#ifndef SOAP_TYPE__ns2__GetAccessPointInfoListResponse
#define SOAP_TYPE__ns2__GetAccessPointInfoListResponse (1352)
/* ns2:GetAccessPointInfoListResponse complex type: */
class SOAP_CMAC _ns2__GetAccessPointInfoListResponse
{
public:
	char *NextStartReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	int __sizeAccessPointInfo;	/* sequence of elements <AccessPointInfo> of XSD type ns2:AccessPointInfo */
	ns2__AccessPointInfo **AccessPointInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointInfoListResponse (1352)
	virtual int soap_type(void) const { return 1352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointInfoListResponse, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointInfoListResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointInfoListResponse); }
	         _ns2__GetAccessPointInfoListResponse() { _ns2__GetAccessPointInfoListResponse::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointInfoListResponse() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointInfoListResponse * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointInfoListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4023 */
#ifndef SOAP_TYPE__ns2__GetAccessPointInfo
#define SOAP_TYPE__ns2__GetAccessPointInfo (1353)
/* ns2:GetAccessPointInfo complex type: */
class SOAP_CMAC _ns2__GetAccessPointInfo
{
public:
	int __sizeToken;	/* sequence of elements <Token> of XSD type ns3:ReferenceToken */
	char **Token;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointInfo (1353)
	virtual int soap_type(void) const { return 1353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointInfo, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointInfo *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointInfo); }
	         _ns2__GetAccessPointInfo() { _ns2__GetAccessPointInfo::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointInfo() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointInfo * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4026 */
#ifndef SOAP_TYPE__ns2__GetAccessPointInfoResponse
#define SOAP_TYPE__ns2__GetAccessPointInfoResponse (1354)
/* ns2:GetAccessPointInfoResponse complex type: */
class SOAP_CMAC _ns2__GetAccessPointInfoResponse
{
public:
	int __sizeAccessPointInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AccessPointInfo> of XSD type ns2:AccessPointInfo */
	ns2__AccessPointInfo **AccessPointInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointInfoResponse (1354)
	virtual int soap_type(void) const { return 1354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointInfoResponse, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointInfoResponse); }
	         _ns2__GetAccessPointInfoResponse() { _ns2__GetAccessPointInfoResponse::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointInfoResponse() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointInfoResponse * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4029 */
#ifndef SOAP_TYPE__ns2__GetAreaInfoList
#define SOAP_TYPE__ns2__GetAreaInfoList (1355)
/* ns2:GetAreaInfoList complex type: */
class SOAP_CMAC _ns2__GetAreaInfoList
{
public:
	int *Limit;	/* optional element of XSD type xsd:int */
	char *StartReference;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAreaInfoList (1355)
	virtual int soap_type(void) const { return 1355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAreaInfoList, default initialized and not managed by a soap context
	virtual _ns2__GetAreaInfoList *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAreaInfoList); }
	         _ns2__GetAreaInfoList() { _ns2__GetAreaInfoList::soap_default(NULL); }
	virtual ~_ns2__GetAreaInfoList() { }
	friend SOAP_FMAC1 _ns2__GetAreaInfoList * SOAP_FMAC2 soap_instantiate__ns2__GetAreaInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4032 */
#ifndef SOAP_TYPE__ns2__GetAreaInfoListResponse
#define SOAP_TYPE__ns2__GetAreaInfoListResponse (1356)
/* ns2:GetAreaInfoListResponse complex type: */
class SOAP_CMAC _ns2__GetAreaInfoListResponse
{
public:
	char *NextStartReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	int __sizeAreaInfo;	/* sequence of elements <AreaInfo> of XSD type ns2:AreaInfo */
	ns2__AreaInfo **AreaInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAreaInfoListResponse (1356)
	virtual int soap_type(void) const { return 1356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAreaInfoListResponse, default initialized and not managed by a soap context
	virtual _ns2__GetAreaInfoListResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAreaInfoListResponse); }
	         _ns2__GetAreaInfoListResponse() { _ns2__GetAreaInfoListResponse::soap_default(NULL); }
	virtual ~_ns2__GetAreaInfoListResponse() { }
	friend SOAP_FMAC1 _ns2__GetAreaInfoListResponse * SOAP_FMAC2 soap_instantiate__ns2__GetAreaInfoListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4035 */
#ifndef SOAP_TYPE__ns2__GetAreaInfo
#define SOAP_TYPE__ns2__GetAreaInfo (1357)
/* ns2:GetAreaInfo complex type: */
class SOAP_CMAC _ns2__GetAreaInfo
{
public:
	int __sizeToken;	/* sequence of elements <Token> of XSD type ns3:ReferenceToken */
	char **Token;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAreaInfo (1357)
	virtual int soap_type(void) const { return 1357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAreaInfo, default initialized and not managed by a soap context
	virtual _ns2__GetAreaInfo *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAreaInfo); }
	         _ns2__GetAreaInfo() { _ns2__GetAreaInfo::soap_default(NULL); }
	virtual ~_ns2__GetAreaInfo() { }
	friend SOAP_FMAC1 _ns2__GetAreaInfo * SOAP_FMAC2 soap_instantiate__ns2__GetAreaInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4038 */
#ifndef SOAP_TYPE__ns2__GetAreaInfoResponse
#define SOAP_TYPE__ns2__GetAreaInfoResponse (1358)
/* ns2:GetAreaInfoResponse complex type: */
class SOAP_CMAC _ns2__GetAreaInfoResponse
{
public:
	int __sizeAreaInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <AreaInfo> of XSD type ns2:AreaInfo */
	ns2__AreaInfo **AreaInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAreaInfoResponse (1358)
	virtual int soap_type(void) const { return 1358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAreaInfoResponse, default initialized and not managed by a soap context
	virtual _ns2__GetAreaInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAreaInfoResponse); }
	         _ns2__GetAreaInfoResponse() { _ns2__GetAreaInfoResponse::soap_default(NULL); }
	virtual ~_ns2__GetAreaInfoResponse() { }
	friend SOAP_FMAC1 _ns2__GetAreaInfoResponse * SOAP_FMAC2 soap_instantiate__ns2__GetAreaInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4041 */
#ifndef SOAP_TYPE__ns2__GetAccessPointState
#define SOAP_TYPE__ns2__GetAccessPointState (1359)
/* ns2:GetAccessPointState complex type: */
class SOAP_CMAC _ns2__GetAccessPointState
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointState (1359)
	virtual int soap_type(void) const { return 1359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointState, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointState *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointState); }
	         _ns2__GetAccessPointState() { _ns2__GetAccessPointState::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointState() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointState * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4044 */
#ifndef SOAP_TYPE__ns2__GetAccessPointStateResponse
#define SOAP_TYPE__ns2__GetAccessPointStateResponse (1360)
/* ns2:GetAccessPointStateResponse complex type: */
class SOAP_CMAC _ns2__GetAccessPointStateResponse
{
public:
	ns2__AccessPointState *AccessPointState;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns2:AccessPointState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__GetAccessPointStateResponse (1360)
	virtual int soap_type(void) const { return 1360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__GetAccessPointStateResponse, default initialized and not managed by a soap context
	virtual _ns2__GetAccessPointStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__GetAccessPointStateResponse); }
	         _ns2__GetAccessPointStateResponse() { _ns2__GetAccessPointStateResponse::soap_default(NULL); }
	virtual ~_ns2__GetAccessPointStateResponse() { }
	friend SOAP_FMAC1 _ns2__GetAccessPointStateResponse * SOAP_FMAC2 soap_instantiate__ns2__GetAccessPointStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4047 */
#ifndef SOAP_TYPE__ns2__EnableAccessPoint
#define SOAP_TYPE__ns2__EnableAccessPoint (1361)
/* ns2:EnableAccessPoint complex type: */
class SOAP_CMAC _ns2__EnableAccessPoint
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__EnableAccessPoint (1361)
	virtual int soap_type(void) const { return 1361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__EnableAccessPoint, default initialized and not managed by a soap context
	virtual _ns2__EnableAccessPoint *soap_alloc(void) const { return SOAP_NEW(_ns2__EnableAccessPoint); }
	         _ns2__EnableAccessPoint() { _ns2__EnableAccessPoint::soap_default(NULL); }
	virtual ~_ns2__EnableAccessPoint() { }
	friend SOAP_FMAC1 _ns2__EnableAccessPoint * SOAP_FMAC2 soap_instantiate__ns2__EnableAccessPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4050 */
#ifndef SOAP_TYPE__ns2__EnableAccessPointResponse
#define SOAP_TYPE__ns2__EnableAccessPointResponse (1362)
/* ns2:EnableAccessPointResponse complex type: */
class SOAP_CMAC _ns2__EnableAccessPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__EnableAccessPointResponse (1362)
	virtual int soap_type(void) const { return 1362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__EnableAccessPointResponse, default initialized and not managed by a soap context
	virtual _ns2__EnableAccessPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__EnableAccessPointResponse); }
	         _ns2__EnableAccessPointResponse() { _ns2__EnableAccessPointResponse::soap_default(NULL); }
	virtual ~_ns2__EnableAccessPointResponse() { }
	friend SOAP_FMAC1 _ns2__EnableAccessPointResponse * SOAP_FMAC2 soap_instantiate__ns2__EnableAccessPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4053 */
#ifndef SOAP_TYPE__ns2__DisableAccessPoint
#define SOAP_TYPE__ns2__DisableAccessPoint (1363)
/* ns2:DisableAccessPoint complex type: */
class SOAP_CMAC _ns2__DisableAccessPoint
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__DisableAccessPoint (1363)
	virtual int soap_type(void) const { return 1363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__DisableAccessPoint, default initialized and not managed by a soap context
	virtual _ns2__DisableAccessPoint *soap_alloc(void) const { return SOAP_NEW(_ns2__DisableAccessPoint); }
	         _ns2__DisableAccessPoint() { _ns2__DisableAccessPoint::soap_default(NULL); }
	virtual ~_ns2__DisableAccessPoint() { }
	friend SOAP_FMAC1 _ns2__DisableAccessPoint * SOAP_FMAC2 soap_instantiate__ns2__DisableAccessPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4056 */
#ifndef SOAP_TYPE__ns2__DisableAccessPointResponse
#define SOAP_TYPE__ns2__DisableAccessPointResponse (1364)
/* ns2:DisableAccessPointResponse complex type: */
class SOAP_CMAC _ns2__DisableAccessPointResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__DisableAccessPointResponse (1364)
	virtual int soap_type(void) const { return 1364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__DisableAccessPointResponse, default initialized and not managed by a soap context
	virtual _ns2__DisableAccessPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__DisableAccessPointResponse); }
	         _ns2__DisableAccessPointResponse() { _ns2__DisableAccessPointResponse::soap_default(NULL); }
	virtual ~_ns2__DisableAccessPointResponse() { }
	friend SOAP_FMAC1 _ns2__DisableAccessPointResponse * SOAP_FMAC2 soap_instantiate__ns2__DisableAccessPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4059 */
#ifndef SOAP_TYPE__ns2__ExternalAuthorization
#define SOAP_TYPE__ns2__ExternalAuthorization (1365)
/* ns2:ExternalAuthorization complex type: */
class SOAP_CMAC _ns2__ExternalAuthorization
{
public:
	char *AccessPointToken;	/* required element of XSD type ns3:ReferenceToken */
	char *CredentialToken;	/* optional element of XSD type ns3:ReferenceToken */
	char *Reason;	/* optional element of XSD type xsd:string */
	enum ns2__Decision Decision;	/* required element of XSD type ns2:Decision */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__ExternalAuthorization (1365)
	virtual int soap_type(void) const { return 1365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__ExternalAuthorization, default initialized and not managed by a soap context
	virtual _ns2__ExternalAuthorization *soap_alloc(void) const { return SOAP_NEW(_ns2__ExternalAuthorization); }
	         _ns2__ExternalAuthorization() { _ns2__ExternalAuthorization::soap_default(NULL); }
	virtual ~_ns2__ExternalAuthorization() { }
	friend SOAP_FMAC1 _ns2__ExternalAuthorization * SOAP_FMAC2 soap_instantiate__ns2__ExternalAuthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4062 */
#ifndef SOAP_TYPE__ns2__ExternalAuthorizationResponse
#define SOAP_TYPE__ns2__ExternalAuthorizationResponse (1366)
/* ns2:ExternalAuthorizationResponse complex type: */
class SOAP_CMAC _ns2__ExternalAuthorizationResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns2__ExternalAuthorizationResponse (1366)
	virtual int soap_type(void) const { return 1366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns2__ExternalAuthorizationResponse, default initialized and not managed by a soap context
	virtual _ns2__ExternalAuthorizationResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__ExternalAuthorizationResponse); }
	         _ns2__ExternalAuthorizationResponse() { _ns2__ExternalAuthorizationResponse::soap_default(NULL); }
	virtual ~_ns2__ExternalAuthorizationResponse() { }
	friend SOAP_FMAC1 _ns2__ExternalAuthorizationResponse * SOAP_FMAC2 soap_instantiate__ns2__ExternalAuthorizationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4065 */
#ifndef SOAP_TYPE_ns3__DataEntity
#define SOAP_TYPE_ns3__DataEntity (1367)
/* Type ns3__DataEntity is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns3:DataEntity simple type: */
class SOAP_CMAC ns3__DataEntity : public xsd__anyType
{
public:
	char *token;	/* required attribute of XSD type ns3:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__DataEntity (1367)
	virtual int soap_type(void) const { return 1367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__DataEntity, default initialized and not managed by a soap context
	virtual ns3__DataEntity *soap_alloc(void) const { return SOAP_NEW(ns3__DataEntity); }
	         ns3__DataEntity() { ns3__DataEntity::soap_default(NULL); }
	virtual ~ns3__DataEntity() { }
	friend SOAP_FMAC1 ns3__DataEntity * SOAP_FMAC2 soap_instantiate_ns3__DataEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4068 */
#ifndef SOAP_TYPE_ns4__ServiceCapabilities
#define SOAP_TYPE_ns4__ServiceCapabilities (1368)
/* Type ns4__ServiceCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:ServiceCapabilities complex type: */
class SOAP_CMAC ns4__ServiceCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	unsigned int MaxLimit;	/* required attribute of XSD type xsd:unsignedInt */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__ServiceCapabilities (1368)
	virtual int soap_type(void) const { return 1368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__ServiceCapabilities, default initialized and not managed by a soap context
	virtual ns4__ServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(ns4__ServiceCapabilities); }
	         ns4__ServiceCapabilities() { ns4__ServiceCapabilities::soap_default(NULL); }
	virtual ~ns4__ServiceCapabilities() { }
	friend SOAP_FMAC1 ns4__ServiceCapabilities * SOAP_FMAC2 soap_instantiate_ns4__ServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4077 */
#ifndef SOAP_TYPE_ns4__DoorCapabilities
#define SOAP_TYPE_ns4__DoorCapabilities (1371)
/* Type ns4__DoorCapabilities is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorCapabilities complex type: */
class SOAP_CMAC ns4__DoorCapabilities : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	bool *Access;	/* optional attribute of XSD type xsd:boolean */
	bool *AccessTimingOverride;	/* optional attribute of XSD type xsd:boolean */
	bool *Lock;	/* optional attribute of XSD type xsd:boolean */
	bool *Unlock;	/* optional attribute of XSD type xsd:boolean */
	bool *Block;	/* optional attribute of XSD type xsd:boolean */
	bool *DoubleLock;	/* optional attribute of XSD type xsd:boolean */
	bool *LockDown;	/* optional attribute of XSD type xsd:boolean */
	bool *LockOpen;	/* optional attribute of XSD type xsd:boolean */
	bool *DoorMonitor;	/* optional attribute of XSD type xsd:boolean */
	bool *LockMonitor;	/* optional attribute of XSD type xsd:boolean */
	bool *DoubleLockMonitor;	/* optional attribute of XSD type xsd:boolean */
	bool *Alarm;	/* optional attribute of XSD type xsd:boolean */
	bool *Tamper;	/* optional attribute of XSD type xsd:boolean */
	bool *Fault;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorCapabilities (1371)
	virtual int soap_type(void) const { return 1371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorCapabilities, default initialized and not managed by a soap context
	virtual ns4__DoorCapabilities *soap_alloc(void) const { return SOAP_NEW(ns4__DoorCapabilities); }
	         ns4__DoorCapabilities() { ns4__DoorCapabilities::soap_default(NULL); }
	virtual ~ns4__DoorCapabilities() { }
	friend SOAP_FMAC1 ns4__DoorCapabilities * SOAP_FMAC2 soap_instantiate_ns4__DoorCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4080 */
#ifndef SOAP_TYPE_ns4__DoorState
#define SOAP_TYPE_ns4__DoorState (1372)
/* Type ns4__DoorState is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorState complex type: */
class SOAP_CMAC ns4__DoorState : public xsd__anyType
{
public:
	enum ns4__DoorPhysicalState *DoorPhysicalState;	/* optional element of XSD type ns4:DoorPhysicalState */
	enum ns4__LockPhysicalState *LockPhysicalState;	/* optional element of XSD type ns4:LockPhysicalState */
	enum ns4__LockPhysicalState *DoubleLockPhysicalState;	/* optional element of XSD type ns4:LockPhysicalState */
	enum ns4__DoorAlarmState *Alarm;	/* optional element of XSD type ns4:DoorAlarmState */
	ns4__DoorTamper *Tamper;	/* optional element of XSD type ns4:DoorTamper */
	ns4__DoorFault *Fault;	/* optional element of XSD type ns4:DoorFault */
	enum ns4__DoorMode DoorMode;	/* required element of XSD type ns4:DoorMode */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorState (1372)
	virtual int soap_type(void) const { return 1372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorState, default initialized and not managed by a soap context
	virtual ns4__DoorState *soap_alloc(void) const { return SOAP_NEW(ns4__DoorState); }
	         ns4__DoorState() { ns4__DoorState::soap_default(NULL); }
	virtual ~ns4__DoorState() { }
	friend SOAP_FMAC1 ns4__DoorState * SOAP_FMAC2 soap_instantiate_ns4__DoorState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4083 */
#ifndef SOAP_TYPE_ns4__DoorTamper
#define SOAP_TYPE_ns4__DoorTamper (1373)
/* Type ns4__DoorTamper is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorTamper complex type: */
class SOAP_CMAC ns4__DoorTamper : public xsd__anyType
{
public:
	char *Reason;	/* optional element of XSD type xsd:string */
	enum ns4__DoorTamperState State;	/* required element of XSD type ns4:DoorTamperState */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorTamper (1373)
	virtual int soap_type(void) const { return 1373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorTamper, default initialized and not managed by a soap context
	virtual ns4__DoorTamper *soap_alloc(void) const { return SOAP_NEW(ns4__DoorTamper); }
	         ns4__DoorTamper() { ns4__DoorTamper::soap_default(NULL); }
	virtual ~ns4__DoorTamper() { }
	friend SOAP_FMAC1 ns4__DoorTamper * SOAP_FMAC2 soap_instantiate_ns4__DoorTamper(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4086 */
#ifndef SOAP_TYPE_ns4__DoorFault
#define SOAP_TYPE_ns4__DoorFault (1374)
/* Type ns4__DoorFault is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorFault complex type: */
class SOAP_CMAC ns4__DoorFault : public xsd__anyType
{
public:
	char *Reason;	/* optional element of XSD type xsd:string */
	enum ns4__DoorFaultState State;	/* required element of XSD type ns4:DoorFaultState */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorFault (1374)
	virtual int soap_type(void) const { return 1374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorFault, default initialized and not managed by a soap context
	virtual ns4__DoorFault *soap_alloc(void) const { return SOAP_NEW(ns4__DoorFault); }
	         ns4__DoorFault() { ns4__DoorFault::soap_default(NULL); }
	virtual ~ns4__DoorFault() { }
	friend SOAP_FMAC1 ns4__DoorFault * SOAP_FMAC2 soap_instantiate_ns4__DoorFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4089 */
#ifndef SOAP_TYPE_ns4__AccessDoorExtension
#define SOAP_TYPE_ns4__AccessDoorExtension (1375)
/* Type ns4__AccessDoorExtension is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:AccessDoorExtension complex type: */
class SOAP_CMAC ns4__AccessDoorExtension : public xsd__anyType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__AccessDoorExtension (1375)
	virtual int soap_type(void) const { return 1375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__AccessDoorExtension, default initialized and not managed by a soap context
	virtual ns4__AccessDoorExtension *soap_alloc(void) const { return SOAP_NEW(ns4__AccessDoorExtension); }
	         ns4__AccessDoorExtension() { ns4__AccessDoorExtension::soap_default(NULL); }
	virtual ~ns4__AccessDoorExtension() { }
	friend SOAP_FMAC1 ns4__AccessDoorExtension * SOAP_FMAC2 soap_instantiate_ns4__AccessDoorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4092 */
#ifndef SOAP_TYPE__ns4__GetServiceCapabilities
#define SOAP_TYPE__ns4__GetServiceCapabilities (1376)
/* ns4:GetServiceCapabilities complex type: */
class SOAP_CMAC _ns4__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetServiceCapabilities (1376)
	virtual int soap_type(void) const { return 1376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetServiceCapabilities, default initialized and not managed by a soap context
	virtual _ns4__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW(_ns4__GetServiceCapabilities); }
	         _ns4__GetServiceCapabilities() { _ns4__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_ns4__GetServiceCapabilities() { }
	friend SOAP_FMAC1 _ns4__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__ns4__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4095 */
#ifndef SOAP_TYPE__ns4__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns4__GetServiceCapabilitiesResponse (1377)
/* ns4:GetServiceCapabilitiesResponse complex type: */
class SOAP_CMAC _ns4__GetServiceCapabilitiesResponse
{
public:
	ns4__ServiceCapabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns4:ServiceCapabilities */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetServiceCapabilitiesResponse (1377)
	virtual int soap_type(void) const { return 1377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
	virtual _ns4__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__GetServiceCapabilitiesResponse); }
	         _ns4__GetServiceCapabilitiesResponse() { _ns4__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_ns4__GetServiceCapabilitiesResponse() { }
	friend SOAP_FMAC1 _ns4__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__ns4__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4098 */
#ifndef SOAP_TYPE__ns4__GetDoorInfoList
#define SOAP_TYPE__ns4__GetDoorInfoList (1378)
/* ns4:GetDoorInfoList complex type: */
class SOAP_CMAC _ns4__GetDoorInfoList
{
public:
	int *Limit;	/* optional element of XSD type xsd:int */
	char *StartReference;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorInfoList (1378)
	virtual int soap_type(void) const { return 1378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorInfoList, default initialized and not managed by a soap context
	virtual _ns4__GetDoorInfoList *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorInfoList); }
	         _ns4__GetDoorInfoList() { _ns4__GetDoorInfoList::soap_default(NULL); }
	virtual ~_ns4__GetDoorInfoList() { }
	friend SOAP_FMAC1 _ns4__GetDoorInfoList * SOAP_FMAC2 soap_instantiate__ns4__GetDoorInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4101 */
#ifndef SOAP_TYPE__ns4__GetDoorInfoListResponse
#define SOAP_TYPE__ns4__GetDoorInfoListResponse (1379)
/* ns4:GetDoorInfoListResponse complex type: */
class SOAP_CMAC _ns4__GetDoorInfoListResponse
{
public:
	char *NextStartReference;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type xsd:string */
	int __sizeDoorInfo;	/* sequence of elements <DoorInfo> of XSD type ns4:DoorInfo */
	ns4__DoorInfo **DoorInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorInfoListResponse (1379)
	virtual int soap_type(void) const { return 1379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorInfoListResponse, default initialized and not managed by a soap context
	virtual _ns4__GetDoorInfoListResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorInfoListResponse); }
	         _ns4__GetDoorInfoListResponse() { _ns4__GetDoorInfoListResponse::soap_default(NULL); }
	virtual ~_ns4__GetDoorInfoListResponse() { }
	friend SOAP_FMAC1 _ns4__GetDoorInfoListResponse * SOAP_FMAC2 soap_instantiate__ns4__GetDoorInfoListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4104 */
#ifndef SOAP_TYPE__ns4__GetDoorInfo
#define SOAP_TYPE__ns4__GetDoorInfo (1380)
/* ns4:GetDoorInfo complex type: */
class SOAP_CMAC _ns4__GetDoorInfo
{
public:
	int __sizeToken;	/* sequence of elements <Token> of XSD type ns3:ReferenceToken */
	char **Token;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorInfo (1380)
	virtual int soap_type(void) const { return 1380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorInfo, default initialized and not managed by a soap context
	virtual _ns4__GetDoorInfo *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorInfo); }
	         _ns4__GetDoorInfo() { _ns4__GetDoorInfo::soap_default(NULL); }
	virtual ~_ns4__GetDoorInfo() { }
	friend SOAP_FMAC1 _ns4__GetDoorInfo * SOAP_FMAC2 soap_instantiate__ns4__GetDoorInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4107 */
#ifndef SOAP_TYPE__ns4__GetDoorInfoResponse
#define SOAP_TYPE__ns4__GetDoorInfoResponse (1381)
/* ns4:GetDoorInfoResponse complex type: */
class SOAP_CMAC _ns4__GetDoorInfoResponse
{
public:
	int __sizeDoorInfo;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <DoorInfo> of XSD type ns4:DoorInfo */
	ns4__DoorInfo **DoorInfo;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorInfoResponse (1381)
	virtual int soap_type(void) const { return 1381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorInfoResponse, default initialized and not managed by a soap context
	virtual _ns4__GetDoorInfoResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorInfoResponse); }
	         _ns4__GetDoorInfoResponse() { _ns4__GetDoorInfoResponse::soap_default(NULL); }
	virtual ~_ns4__GetDoorInfoResponse() { }
	friend SOAP_FMAC1 _ns4__GetDoorInfoResponse * SOAP_FMAC2 soap_instantiate__ns4__GetDoorInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4110 */
#ifndef SOAP_TYPE__ns4__GetDoorState
#define SOAP_TYPE__ns4__GetDoorState (1382)
/* ns4:GetDoorState complex type: */
class SOAP_CMAC _ns4__GetDoorState
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorState (1382)
	virtual int soap_type(void) const { return 1382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorState, default initialized and not managed by a soap context
	virtual _ns4__GetDoorState *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorState); }
	         _ns4__GetDoorState() { _ns4__GetDoorState::soap_default(NULL); }
	virtual ~_ns4__GetDoorState() { }
	friend SOAP_FMAC1 _ns4__GetDoorState * SOAP_FMAC2 soap_instantiate__ns4__GetDoorState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4113 */
#ifndef SOAP_TYPE__ns4__GetDoorStateResponse
#define SOAP_TYPE__ns4__GetDoorStateResponse (1383)
/* ns4:GetDoorStateResponse complex type: */
class SOAP_CMAC _ns4__GetDoorStateResponse
{
public:
	ns4__DoorState *DoorState;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns4:DoorState */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__GetDoorStateResponse (1383)
	virtual int soap_type(void) const { return 1383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__GetDoorStateResponse, default initialized and not managed by a soap context
	virtual _ns4__GetDoorStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__GetDoorStateResponse); }
	         _ns4__GetDoorStateResponse() { _ns4__GetDoorStateResponse::soap_default(NULL); }
	virtual ~_ns4__GetDoorStateResponse() { }
	friend SOAP_FMAC1 _ns4__GetDoorStateResponse * SOAP_FMAC2 soap_instantiate__ns4__GetDoorStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4116 */
#ifndef SOAP_TYPE__ns4__AccessDoor
#define SOAP_TYPE__ns4__AccessDoor (1384)
/* ns4:AccessDoor complex type: */
class SOAP_CMAC _ns4__AccessDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	bool *UseExtendedTime;	/* optional element of XSD type xsd:boolean */
	LONG64 *AccessTime;	/* optional element of XSD type xsd:duration */
	LONG64 *OpenTooLongTime;	/* optional element of XSD type xsd:duration */
	LONG64 *PreAlarmTime;	/* optional element of XSD type xsd:duration */
	ns4__AccessDoorExtension *Extension;	/* optional element of XSD type ns4:AccessDoorExtension */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__AccessDoor (1384)
	virtual int soap_type(void) const { return 1384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__AccessDoor, default initialized and not managed by a soap context
	virtual _ns4__AccessDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__AccessDoor); }
	         _ns4__AccessDoor() { _ns4__AccessDoor::soap_default(NULL); }
	virtual ~_ns4__AccessDoor() { }
	friend SOAP_FMAC1 _ns4__AccessDoor * SOAP_FMAC2 soap_instantiate__ns4__AccessDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4119 */
#ifndef SOAP_TYPE__ns4__AccessDoorResponse
#define SOAP_TYPE__ns4__AccessDoorResponse (1385)
/* ns4:AccessDoorResponse complex type: */
class SOAP_CMAC _ns4__AccessDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__AccessDoorResponse (1385)
	virtual int soap_type(void) const { return 1385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__AccessDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__AccessDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__AccessDoorResponse); }
	         _ns4__AccessDoorResponse() { _ns4__AccessDoorResponse::soap_default(NULL); }
	virtual ~_ns4__AccessDoorResponse() { }
	friend SOAP_FMAC1 _ns4__AccessDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__AccessDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4122 */
#ifndef SOAP_TYPE__ns4__LockDoor
#define SOAP_TYPE__ns4__LockDoor (1386)
/* ns4:LockDoor complex type: */
class SOAP_CMAC _ns4__LockDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDoor (1386)
	virtual int soap_type(void) const { return 1386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDoor, default initialized and not managed by a soap context
	virtual _ns4__LockDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDoor); }
	         _ns4__LockDoor() { _ns4__LockDoor::soap_default(NULL); }
	virtual ~_ns4__LockDoor() { }
	friend SOAP_FMAC1 _ns4__LockDoor * SOAP_FMAC2 soap_instantiate__ns4__LockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4125 */
#ifndef SOAP_TYPE__ns4__LockDoorResponse
#define SOAP_TYPE__ns4__LockDoorResponse (1387)
/* ns4:LockDoorResponse complex type: */
class SOAP_CMAC _ns4__LockDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDoorResponse (1387)
	virtual int soap_type(void) const { return 1387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__LockDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDoorResponse); }
	         _ns4__LockDoorResponse() { _ns4__LockDoorResponse::soap_default(NULL); }
	virtual ~_ns4__LockDoorResponse() { }
	friend SOAP_FMAC1 _ns4__LockDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__LockDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4128 */
#ifndef SOAP_TYPE__ns4__UnlockDoor
#define SOAP_TYPE__ns4__UnlockDoor (1388)
/* ns4:UnlockDoor complex type: */
class SOAP_CMAC _ns4__UnlockDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__UnlockDoor (1388)
	virtual int soap_type(void) const { return 1388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__UnlockDoor, default initialized and not managed by a soap context
	virtual _ns4__UnlockDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__UnlockDoor); }
	         _ns4__UnlockDoor() { _ns4__UnlockDoor::soap_default(NULL); }
	virtual ~_ns4__UnlockDoor() { }
	friend SOAP_FMAC1 _ns4__UnlockDoor * SOAP_FMAC2 soap_instantiate__ns4__UnlockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4131 */
#ifndef SOAP_TYPE__ns4__UnlockDoorResponse
#define SOAP_TYPE__ns4__UnlockDoorResponse (1389)
/* ns4:UnlockDoorResponse complex type: */
class SOAP_CMAC _ns4__UnlockDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__UnlockDoorResponse (1389)
	virtual int soap_type(void) const { return 1389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__UnlockDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__UnlockDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__UnlockDoorResponse); }
	         _ns4__UnlockDoorResponse() { _ns4__UnlockDoorResponse::soap_default(NULL); }
	virtual ~_ns4__UnlockDoorResponse() { }
	friend SOAP_FMAC1 _ns4__UnlockDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__UnlockDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4134 */
#ifndef SOAP_TYPE__ns4__BlockDoor
#define SOAP_TYPE__ns4__BlockDoor (1390)
/* ns4:BlockDoor complex type: */
class SOAP_CMAC _ns4__BlockDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__BlockDoor (1390)
	virtual int soap_type(void) const { return 1390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__BlockDoor, default initialized and not managed by a soap context
	virtual _ns4__BlockDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__BlockDoor); }
	         _ns4__BlockDoor() { _ns4__BlockDoor::soap_default(NULL); }
	virtual ~_ns4__BlockDoor() { }
	friend SOAP_FMAC1 _ns4__BlockDoor * SOAP_FMAC2 soap_instantiate__ns4__BlockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4137 */
#ifndef SOAP_TYPE__ns4__BlockDoorResponse
#define SOAP_TYPE__ns4__BlockDoorResponse (1391)
/* ns4:BlockDoorResponse complex type: */
class SOAP_CMAC _ns4__BlockDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__BlockDoorResponse (1391)
	virtual int soap_type(void) const { return 1391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__BlockDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__BlockDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__BlockDoorResponse); }
	         _ns4__BlockDoorResponse() { _ns4__BlockDoorResponse::soap_default(NULL); }
	virtual ~_ns4__BlockDoorResponse() { }
	friend SOAP_FMAC1 _ns4__BlockDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__BlockDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4140 */
#ifndef SOAP_TYPE__ns4__LockDownDoor
#define SOAP_TYPE__ns4__LockDownDoor (1392)
/* ns4:LockDownDoor complex type: */
class SOAP_CMAC _ns4__LockDownDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDownDoor (1392)
	virtual int soap_type(void) const { return 1392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDownDoor, default initialized and not managed by a soap context
	virtual _ns4__LockDownDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDownDoor); }
	         _ns4__LockDownDoor() { _ns4__LockDownDoor::soap_default(NULL); }
	virtual ~_ns4__LockDownDoor() { }
	friend SOAP_FMAC1 _ns4__LockDownDoor * SOAP_FMAC2 soap_instantiate__ns4__LockDownDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4143 */
#ifndef SOAP_TYPE__ns4__LockDownDoorResponse
#define SOAP_TYPE__ns4__LockDownDoorResponse (1393)
/* ns4:LockDownDoorResponse complex type: */
class SOAP_CMAC _ns4__LockDownDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDownDoorResponse (1393)
	virtual int soap_type(void) const { return 1393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDownDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__LockDownDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDownDoorResponse); }
	         _ns4__LockDownDoorResponse() { _ns4__LockDownDoorResponse::soap_default(NULL); }
	virtual ~_ns4__LockDownDoorResponse() { }
	friend SOAP_FMAC1 _ns4__LockDownDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__LockDownDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4146 */
#ifndef SOAP_TYPE__ns4__LockDownReleaseDoor
#define SOAP_TYPE__ns4__LockDownReleaseDoor (1394)
/* ns4:LockDownReleaseDoor complex type: */
class SOAP_CMAC _ns4__LockDownReleaseDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDownReleaseDoor (1394)
	virtual int soap_type(void) const { return 1394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDownReleaseDoor, default initialized and not managed by a soap context
	virtual _ns4__LockDownReleaseDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDownReleaseDoor); }
	         _ns4__LockDownReleaseDoor() { _ns4__LockDownReleaseDoor::soap_default(NULL); }
	virtual ~_ns4__LockDownReleaseDoor() { }
	friend SOAP_FMAC1 _ns4__LockDownReleaseDoor * SOAP_FMAC2 soap_instantiate__ns4__LockDownReleaseDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4149 */
#ifndef SOAP_TYPE__ns4__LockDownReleaseDoorResponse
#define SOAP_TYPE__ns4__LockDownReleaseDoorResponse (1395)
/* ns4:LockDownReleaseDoorResponse complex type: */
class SOAP_CMAC _ns4__LockDownReleaseDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockDownReleaseDoorResponse (1395)
	virtual int soap_type(void) const { return 1395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockDownReleaseDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__LockDownReleaseDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__LockDownReleaseDoorResponse); }
	         _ns4__LockDownReleaseDoorResponse() { _ns4__LockDownReleaseDoorResponse::soap_default(NULL); }
	virtual ~_ns4__LockDownReleaseDoorResponse() { }
	friend SOAP_FMAC1 _ns4__LockDownReleaseDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__LockDownReleaseDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4152 */
#ifndef SOAP_TYPE__ns4__LockOpenDoor
#define SOAP_TYPE__ns4__LockOpenDoor (1396)
/* ns4:LockOpenDoor complex type: */
class SOAP_CMAC _ns4__LockOpenDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockOpenDoor (1396)
	virtual int soap_type(void) const { return 1396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockOpenDoor, default initialized and not managed by a soap context
	virtual _ns4__LockOpenDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__LockOpenDoor); }
	         _ns4__LockOpenDoor() { _ns4__LockOpenDoor::soap_default(NULL); }
	virtual ~_ns4__LockOpenDoor() { }
	friend SOAP_FMAC1 _ns4__LockOpenDoor * SOAP_FMAC2 soap_instantiate__ns4__LockOpenDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4155 */
#ifndef SOAP_TYPE__ns4__LockOpenDoorResponse
#define SOAP_TYPE__ns4__LockOpenDoorResponse (1397)
/* ns4:LockOpenDoorResponse complex type: */
class SOAP_CMAC _ns4__LockOpenDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockOpenDoorResponse (1397)
	virtual int soap_type(void) const { return 1397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockOpenDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__LockOpenDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__LockOpenDoorResponse); }
	         _ns4__LockOpenDoorResponse() { _ns4__LockOpenDoorResponse::soap_default(NULL); }
	virtual ~_ns4__LockOpenDoorResponse() { }
	friend SOAP_FMAC1 _ns4__LockOpenDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__LockOpenDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4158 */
#ifndef SOAP_TYPE__ns4__LockOpenReleaseDoor
#define SOAP_TYPE__ns4__LockOpenReleaseDoor (1398)
/* ns4:LockOpenReleaseDoor complex type: */
class SOAP_CMAC _ns4__LockOpenReleaseDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockOpenReleaseDoor (1398)
	virtual int soap_type(void) const { return 1398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockOpenReleaseDoor, default initialized and not managed by a soap context
	virtual _ns4__LockOpenReleaseDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__LockOpenReleaseDoor); }
	         _ns4__LockOpenReleaseDoor() { _ns4__LockOpenReleaseDoor::soap_default(NULL); }
	virtual ~_ns4__LockOpenReleaseDoor() { }
	friend SOAP_FMAC1 _ns4__LockOpenReleaseDoor * SOAP_FMAC2 soap_instantiate__ns4__LockOpenReleaseDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4161 */
#ifndef SOAP_TYPE__ns4__LockOpenReleaseDoorResponse
#define SOAP_TYPE__ns4__LockOpenReleaseDoorResponse (1399)
/* ns4:LockOpenReleaseDoorResponse complex type: */
class SOAP_CMAC _ns4__LockOpenReleaseDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__LockOpenReleaseDoorResponse (1399)
	virtual int soap_type(void) const { return 1399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__LockOpenReleaseDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__LockOpenReleaseDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__LockOpenReleaseDoorResponse); }
	         _ns4__LockOpenReleaseDoorResponse() { _ns4__LockOpenReleaseDoorResponse::soap_default(NULL); }
	virtual ~_ns4__LockOpenReleaseDoorResponse() { }
	friend SOAP_FMAC1 _ns4__LockOpenReleaseDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__LockOpenReleaseDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4164 */
#ifndef SOAP_TYPE__ns4__DoubleLockDoor
#define SOAP_TYPE__ns4__DoubleLockDoor (1400)
/* ns4:DoubleLockDoor complex type: */
class SOAP_CMAC _ns4__DoubleLockDoor
{
public:
	char *Token;	/* required element of XSD type ns3:ReferenceToken */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__DoubleLockDoor (1400)
	virtual int soap_type(void) const { return 1400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__DoubleLockDoor, default initialized and not managed by a soap context
	virtual _ns4__DoubleLockDoor *soap_alloc(void) const { return SOAP_NEW(_ns4__DoubleLockDoor); }
	         _ns4__DoubleLockDoor() { _ns4__DoubleLockDoor::soap_default(NULL); }
	virtual ~_ns4__DoubleLockDoor() { }
	friend SOAP_FMAC1 _ns4__DoubleLockDoor * SOAP_FMAC2 soap_instantiate__ns4__DoubleLockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4167 */
#ifndef SOAP_TYPE__ns4__DoubleLockDoorResponse
#define SOAP_TYPE__ns4__DoubleLockDoorResponse (1401)
/* ns4:DoubleLockDoorResponse complex type: */
class SOAP_CMAC _ns4__DoubleLockDoorResponse
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE__ns4__DoubleLockDoorResponse (1401)
	virtual int soap_type(void) const { return 1401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns4__DoubleLockDoorResponse, default initialized and not managed by a soap context
	virtual _ns4__DoubleLockDoorResponse *soap_alloc(void) const { return SOAP_NEW(_ns4__DoubleLockDoorResponse); }
	         _ns4__DoubleLockDoorResponse() { _ns4__DoubleLockDoorResponse::soap_default(NULL); }
	virtual ~_ns4__DoubleLockDoorResponse() { }
	friend SOAP_FMAC1 _ns4__DoubleLockDoorResponse * SOAP_FMAC2 soap_instantiate__ns4__DoubleLockDoorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:456 */
#ifndef SOAP_TYPE_tmd__SerialPort
#define SOAP_TYPE_tmd__SerialPort (164)
/* Type tmd__SerialPort is a recursive data type (in)directly referencing itself through its (base) class members */
/* tmd:SerialPort complex type: */
class SOAP_CMAC tmd__SerialPort : public tt__DeviceEntity
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tmd__SerialPort (164)
	virtual int soap_type(void) const { return 164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tmd__SerialPort, default initialized and not managed by a soap context
	virtual tmd__SerialPort *soap_alloc(void) const { return SOAP_NEW(tmd__SerialPort); }
	         tmd__SerialPort() { tmd__SerialPort::soap_default(NULL); }
	virtual ~tmd__SerialPort() { }
	friend SOAP_FMAC1 tmd__SerialPort * SOAP_FMAC2 soap_instantiate_tmd__SerialPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1062 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (366)
/* Type tt__VideoSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSource complex type: */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of XSD type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of XSD type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of XSD type tt:VideoSourceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSource (366)
	virtual int soap_type(void) const { return 366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
	virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW(tt__VideoSource); }
	         tt__VideoSource() { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
	friend SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1071 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (369)
/* Type tt__AudioSource is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSource complex type: */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSource (369)
	virtual int soap_type(void) const { return 369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
	virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW(tt__AudioSource); }
	         tt__AudioSource() { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
	friend SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1086 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (374)
/* Type tt__VideoSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoSourceConfiguration complex type: */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of XSD type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of XSD type tt:IntRectangle */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of XSD type tt:VideoSourceConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoSourceConfiguration (374)
	virtual int soap_type(void) const { return 374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoSourceConfiguration); }
	         tt__VideoSourceConfiguration() { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
	friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1116 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (384)
/* Type tt__VideoEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoEncoderConfiguration complex type: */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of XSD type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of XSD type tt:VideoResolution */
	float Quality;	/* required element of XSD type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of XSD type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of XSD type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of XSD type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoEncoderConfiguration (384)
	virtual int soap_type(void) const { return 384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoEncoderConfiguration); }
	         tt__VideoEncoderConfiguration() { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1143 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (393)
/* Type tt__JpegOptions2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:JpegOptions2 complex type: */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__JpegOptions2 (393)
	virtual int soap_type(void) const { return 393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
	virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW(tt__JpegOptions2); }
	         tt__JpegOptions2() { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
	friend SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1149 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (395)
/* Type tt__Mpeg4Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Mpeg4Options2 complex type: */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Mpeg4Options2 (395)
	virtual int soap_type(void) const { return 395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
	virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW(tt__Mpeg4Options2); }
	         tt__Mpeg4Options2() { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
	friend SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1155 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (397)
/* Type tt__H264Options2 is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:H264Options2 complex type: */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of XSD type tt:IntRange */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__H264Options2 (397)
	virtual int soap_type(void) const { return 397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
	virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW(tt__H264Options2); }
	         tt__H264Options2() { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
	friend SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1158 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (398)
/* Type tt__AudioSourceConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioSourceConfiguration complex type: */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioSourceConfiguration (398)
	virtual int soap_type(void) const { return 398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioSourceConfiguration); }
	         tt__AudioSourceConfiguration() { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
	friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1167 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (401)
/* Type tt__AudioEncoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioEncoderConfiguration complex type: */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of XSD type tt:AudioEncoding */
	int Bitrate;	/* required element of XSD type xsd:int */
	int SampleRate;	/* required element of XSD type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioEncoderConfiguration (401)
	virtual int soap_type(void) const { return 401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioEncoderConfiguration); }
	         tt__AudioEncoderConfiguration() { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1176 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (404)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoAnalyticsConfiguration complex type: */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of XSD type tt:RuleEngineConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoAnalyticsConfiguration (404)
	virtual int soap_type(void) const { return 404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoAnalyticsConfiguration); }
	         tt__VideoAnalyticsConfiguration() { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
	friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1179 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (405)
/* Type tt__MetadataConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:MetadataConfiguration complex type: */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of XSD type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of XSD type tt:EventSubscription */
	bool *Analytics;	/* optional element of XSD type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of XSD type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external (custom serializer) */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of XSD type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of XSD type tt:MetadataConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__MetadataConfiguration (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
	virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__MetadataConfiguration); }
	         tt__MetadataConfiguration() { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
	friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1200 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (412)
/* Type tt__VideoOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutput complex type: */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of XSD type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of XSD type tt:VideoResolution */
	float *RefreshRate;	/* optional element of XSD type xsd:float */
	float *AspectRatio;	/* optional element of XSD type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of XSD type tt:VideoOutputExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutput (412)
	virtual int soap_type(void) const { return 412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
	virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutput); }
	         tt__VideoOutput() { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
	friend SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1206 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (414)
/* Type tt__VideoOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:VideoOutputConfiguration complex type: */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of XSD type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__VideoOutputConfiguration (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__VideoOutputConfiguration); }
	         tt__VideoOutputConfiguration() { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
	friend SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1227 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (421)
/* Type tt__AudioOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutput complex type: */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutput (421)
	virtual int soap_type(void) const { return 421; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
	virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutput); }
	         tt__AudioOutput() { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
	friend SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1230 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (422)
/* Type tt__AudioOutputConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioOutputConfiguration complex type: */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of XSD type tt:ReferenceToken */
	char *SendPrimacy;	/* optional element of XSD type xsd:anyURI */
	int OutputLevel;	/* required element of XSD type xsd:int */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioOutputConfiguration (422)
	virtual int soap_type(void) const { return 422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioOutputConfiguration); }
	         tt__AudioOutputConfiguration() { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
	friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1236 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (424)
/* Type tt__AudioDecoderConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AudioDecoderConfiguration complex type: */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AudioDecoderConfiguration (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
	virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__AudioDecoderConfiguration); }
	         tt__AudioDecoderConfiguration() { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
	friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1269 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (435)
/* Type tt__NetworkInterface is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:NetworkInterface complex type: */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of XSD type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of XSD type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of XSD type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of XSD type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of XSD type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of XSD type tt:NetworkInterfaceExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__NetworkInterface (435)
	virtual int soap_type(void) const { return 435; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
	virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW(tt__NetworkInterface); }
	         tt__NetworkInterface() { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
	friend SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1581 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (539)
/* Type tt__CertificateUsage is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:CertificateUsage simple type: */
class SOAP_CMAC tt__CertificateUsage : public xsd__anyType
{
public:
	char *__item;	/* mixed XML content */
	bool Critical;	/* required attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__CertificateUsage (539)
	virtual int soap_type(void) const { return 539; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
	virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW(tt__CertificateUsage); }
	         tt__CertificateUsage() { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
	friend SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1608 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (548)
/* Type tt__RelayOutput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:RelayOutput complex type: */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of XSD type tt:RelayOutputSettings */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__RelayOutput (548)
	virtual int soap_type(void) const { return 548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
	virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW(tt__RelayOutput); }
	         tt__RelayOutput() { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
	friend SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1611 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (549)
/* Type tt__DigitalInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:DigitalInput complex type: */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__DigitalInput (549)
	virtual int soap_type(void) const { return 549; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
	virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW(tt__DigitalInput); }
	         tt__DigitalInput() { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
	friend SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1614 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (550)
/* Type tt__PTZNode is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZNode complex type: */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	char *Name;	/* optional element of XSD type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of XSD type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of XSD type xsd:int */
	bool HomeSupported;	/* required element of XSD type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> of XSD type tt:AuxiliaryData */
	char **AuxiliaryCommands;
	tt__PTZNodeExtension *Extension;	/* optional element of XSD type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute of XSD type xsd:boolean */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZNode (550)
	virtual int soap_type(void) const { return 550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
	virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW(tt__PTZNode); }
	         tt__PTZNode() { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
	friend SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1629 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (555)
/* Type tt__PTZConfiguration is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:PTZConfiguration complex type: */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	char *NodeToken;	/* required element of XSD type tt:ReferenceToken */
	char *DefaultAbsolutePantTiltPositionSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultAbsoluteZoomPositionSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultRelativePanTiltTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultRelativeZoomTranslationSpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultContinuousPanTiltVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	char *DefaultContinuousZoomVelocitySpace;	/* optional element of XSD type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of XSD type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of XSD type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of XSD type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of XSD type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of XSD type tt:PTZConfigurationExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__PTZConfiguration (555)
	virtual int soap_type(void) const { return 555; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
	virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW(tt__PTZConfiguration); }
	         tt__PTZConfiguration() { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
	friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:1989 */
#ifndef SOAP_TYPE_tt__Object
#define SOAP_TYPE_tt__Object (675)
/* Type tt__Object is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:Object complex type: */
class SOAP_CMAC tt__Object : public tt__ObjectId
{
public:
	tt__Appearance *Appearance;	/* optional element of XSD type tt:Appearance */
	tt__Behaviour *Behaviour;	/* optional element of XSD type tt:Behaviour */
	tt__ObjectExtension *Extension;	/* optional element of XSD type tt:ObjectExtension */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__Object (675)
	virtual int soap_type(void) const { return 675; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__Object, default initialized and not managed by a soap context
	virtual tt__Object *soap_alloc(void) const { return SOAP_NEW(tt__Object); }
	         tt__Object() { tt__Object::soap_default(NULL); }
	virtual ~tt__Object() { }
	friend SOAP_FMAC1 tt__Object * SOAP_FMAC2 soap_instantiate_tt__Object(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2166 */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (734)
/* Type tt__EventFilter is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:EventFilter complex type: */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__EventFilter (734)
	virtual int soap_type(void) const { return 734; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__EventFilter, default initialized and not managed by a soap context
	virtual tt__EventFilter *soap_alloc(void) const { return SOAP_NEW(tt__EventFilter); }
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
	friend SOAP_FMAC1 tt__EventFilter * SOAP_FMAC2 soap_instantiate_tt__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2274 */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (770)
/* Type tt__AnalyticsEngine is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngine complex type: */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of XSD type tt:AnalyticsDeviceEngineConfiguration */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngine (770)
	virtual int soap_type(void) const { return 770; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngine, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngine); }
	         tt__AnalyticsEngine() { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
	friend SOAP_FMAC1 tt__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2292 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (776)
/* Type tt__AnalyticsEngineInput is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineInput complex type: */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of XSD type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of XSD type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of XSD type tt:MetadataInput */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineInput (776)
	virtual int soap_type(void) const { return 776; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineInput, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineInput); }
	         tt__AnalyticsEngineInput() { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2307 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (781)
/* Type tt__AnalyticsEngineControl is a recursive data type (in)directly referencing itself through its (base) class members */
/* tt:AnalyticsEngineControl complex type: */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	char *EngineToken;	/* required element of XSD type tt:ReferenceToken */
	char *EngineConfigToken;	/* required element of XSD type tt:ReferenceToken */
	int __sizeInputToken;	/* sequence of elements <InputToken> of XSD type tt:ReferenceToken */
	char **InputToken;
	int __sizeReceiverToken;	/* sequence of elements <ReceiverToken> of XSD type tt:ReferenceToken */
	char **ReceiverToken;
	tt__MulticastConfiguration *Multicast;	/* optional element of XSD type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of XSD type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of XSD type tt:ModeOfOperation */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_tt__AnalyticsEngineControl (781)
	virtual int soap_type(void) const { return 781; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type tt__AnalyticsEngineControl, default initialized and not managed by a soap context
	virtual tt__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW(tt__AnalyticsEngineControl); }
	         tt__AnalyticsEngineControl() { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
	friend SOAP_FMAC1 tt__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2340 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (792)
/* Type wsnt__SubscribeCreationFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:SubscribeCreationFailedFaultType complex type: */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (792)
	virtual int soap_type(void) const { return 792; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__SubscribeCreationFailedFaultType); }
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2343 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (793)
/* Type wsnt__InvalidFilterFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidFilterFaultType complex type: */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnknownFilter;	/* sequence of elements <UnknownFilter> of XSD type xsd:QName */
	char **UnknownFilter;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidFilterFaultType (793)
	virtual int soap_type(void) const { return 793; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidFilterFaultType); }
	         wsnt__InvalidFilterFaultType() { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2346 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (794)
/* Type wsnt__TopicExpressionDialectUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicExpressionDialectUnknownFaultType complex type: */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (794)
	virtual int soap_type(void) const { return 794; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicExpressionDialectUnknownFaultType); }
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2349 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (795)
/* Type wsnt__InvalidTopicExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidTopicExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (795)
	virtual int soap_type(void) const { return 795; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidTopicExpressionFaultType); }
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2352 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (796)
/* Type wsnt__TopicNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:TopicNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__TopicNotSupportedFaultType (796)
	virtual int soap_type(void) const { return 796; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__TopicNotSupportedFaultType); }
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2355 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (797)
/* Type wsnt__MultipleTopicsSpecifiedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:MultipleTopicsSpecifiedFaultType complex type: */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (797)
	virtual int soap_type(void) const { return 797; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
	virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__MultipleTopicsSpecifiedFaultType); }
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
	friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2358 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (798)
/* Type wsnt__InvalidProducerPropertiesExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidProducerPropertiesExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (798)
	virtual int soap_type(void) const { return 798; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidProducerPropertiesExpressionFaultType); }
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2361 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (799)
/* Type wsnt__InvalidMessageContentExpressionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:InvalidMessageContentExpressionFaultType complex type: */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (799)
	virtual int soap_type(void) const { return 799; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
	virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__InvalidMessageContentExpressionFaultType); }
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
	friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2364 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (800)
/* Type wsnt__UnrecognizedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnrecognizedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnrecognizedPolicy;	/* sequence of elements <UnrecognizedPolicy> of XSD type xsd:QName */
	char **UnrecognizedPolicy;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (800)
	virtual int soap_type(void) const { return 800; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnrecognizedPolicyRequestFaultType); }
	         wsnt__UnrecognizedPolicyRequestFaultType() { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2367 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (801)
/* Type wsnt__UnsupportedPolicyRequestFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnsupportedPolicyRequestFaultType complex type: */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	int __sizeUnsupportedPolicy;	/* sequence of elements <UnsupportedPolicy> of XSD type xsd:QName */
	char **UnsupportedPolicy;
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (801)
	virtual int soap_type(void) const { return 801; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnsupportedPolicyRequestFaultType); }
	         wsnt__UnsupportedPolicyRequestFaultType() { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
	friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2370 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (802)
/* Type wsnt__NotifyMessageNotSupportedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NotifyMessageNotSupportedFaultType complex type: */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (802)
	virtual int soap_type(void) const { return 802; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
	virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NotifyMessageNotSupportedFaultType); }
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
	friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2373 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (803)
/* Type wsnt__UnacceptableInitialTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableInitialTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (803)
	virtual int soap_type(void) const { return 803; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableInitialTerminationTimeFaultType); }
	         wsnt__UnacceptableInitialTerminationTimeFaultType() { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2376 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (804)
/* Type wsnt__NoCurrentMessageOnTopicFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:NoCurrentMessageOnTopicFaultType complex type: */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (804)
	virtual int soap_type(void) const { return 804; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
	virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__NoCurrentMessageOnTopicFaultType); }
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
	friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2379 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (805)
/* Type wsnt__UnableToGetMessagesFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToGetMessagesFaultType complex type: */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (805)
	virtual int soap_type(void) const { return 805; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToGetMessagesFaultType); }
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2382 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (806)
/* Type wsnt__UnableToDestroyPullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroyPullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (806)
	virtual int soap_type(void) const { return 806; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroyPullPointFaultType); }
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2385 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (807)
/* Type wsnt__UnableToCreatePullPointFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToCreatePullPointFaultType complex type: */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (807)
	virtual int soap_type(void) const { return 807; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToCreatePullPointFaultType); }
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2388 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (808)
/* Type wsnt__UnacceptableTerminationTimeFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnacceptableTerminationTimeFaultType complex type: */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of XSD type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (808)
	virtual int soap_type(void) const { return 808; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnacceptableTerminationTimeFaultType); }
	         wsnt__UnacceptableTerminationTimeFaultType() { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
	friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2391 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (809)
/* Type wsnt__UnableToDestroySubscriptionFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:UnableToDestroySubscriptionFaultType complex type: */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (809)
	virtual int soap_type(void) const { return 809; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
	virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__UnableToDestroySubscriptionFaultType); }
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
	friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2394 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (810)
/* Type wsnt__PauseFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:PauseFailedFaultType complex type: */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__PauseFailedFaultType (810)
	virtual int soap_type(void) const { return 810; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__PauseFailedFaultType); }
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2397 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (811)
/* Type wsnt__ResumeFailedFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsnt:ResumeFailedFaultType complex type: */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsnt__ResumeFailedFaultType (811)
	virtual int soap_type(void) const { return 811; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
	virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(wsnt__ResumeFailedFaultType); }
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
	friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:45190 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (2294)
/* wstop:TopicNamespaceType-Topic complex type: */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__Documentation *documentation;	/* optional element of XSD type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicType */
	wstop__TopicType **Topic;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *name;	/* required attribute of XSD type xsd:NCName */
	char **messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
	char *parent;	/* optional attribute of XSD type wstop:ConcreteTopicExpression */
public:
	/// Return the unique type ID value SOAP_TYPE__wstop__TopicNamespaceType_Topic (2294)
	virtual int soap_type(void) const { return 2294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
	virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_wstop__TopicNamespaceType_Topic); }
	         _wstop__TopicNamespaceType_Topic() { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
	friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2478 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (838)
/* Type wstop__TopicNamespaceType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicNamespaceType complex type: */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicNamespaceType-Topic */
	_wstop__TopicNamespaceType_Topic *Topic;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *targetNamespace;	/* required attribute of XSD type xsd:anyURI */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicNamespaceType (838)
	virtual int soap_type(void) const { return 838; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
	virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicNamespaceType); }
	         wstop__TopicNamespaceType() { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
	friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2481 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (839)
/* Type wstop__TopicType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicType complex type: */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of XSD type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> of XSD type wstop:TopicType */
	wstop__TopicType **Topic;
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *name;	/* required attribute of XSD type xsd:NCName */
	char **messageTypes;	/* optional attribute of XSD type xsd:QName */
	bool final_;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicType (839)
	virtual int soap_type(void) const { return 839; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
	virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicType); }
	         wstop__TopicType() { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
	friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:2484 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (840)
/* Type wstop__TopicSetType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wstop:TopicSetType complex type: */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_wstop__TopicSetType (840)
	virtual int soap_type(void) const { return 840; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
	virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW(wstop__TopicSetType); }
	         wstop__TopicSetType() { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
	friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3039 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (1025)
/* Type wsrfr__ResourceUnknownFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfr:ResourceUnknownFaultType complex type: */
class SOAP_CMAC wsrfr__ResourceUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfr__ResourceUnknownFaultType (1025)
	virtual int soap_type(void) const { return 1025; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfr__ResourceUnknownFaultType, default initialized and not managed by a soap context
	virtual wsrfr__ResourceUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfr__ResourceUnknownFaultType); }
	         wsrfr__ResourceUnknownFaultType() { wsrfr__ResourceUnknownFaultType::soap_default(NULL); }
	virtual ~wsrfr__ResourceUnknownFaultType() { }
	friend SOAP_FMAC1 wsrfr__ResourceUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3042 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (1026)
/* Type wsrfr__ResourceUnavailableFaultType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrfr:ResourceUnavailableFaultType complex type: */
class SOAP_CMAC wsrfr__ResourceUnavailableFaultType : public wsrfbf__BaseFaultType
{
public:
	/// Return the unique type ID value SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (1026)
	virtual int soap_type(void) const { return 1026; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrfr__ResourceUnavailableFaultType, default initialized and not managed by a soap context
	virtual wsrfr__ResourceUnavailableFaultType *soap_alloc(void) const { return SOAP_NEW(wsrfr__ResourceUnavailableFaultType); }
	         wsrfr__ResourceUnavailableFaultType() { wsrfr__ResourceUnavailableFaultType::soap_default(NULL); }
	virtual ~wsrfr__ResourceUnavailableFaultType() { }
	friend SOAP_FMAC1 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnavailableFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3993 */
#ifndef SOAP_TYPE_ns2__AccessPointInfoBase
#define SOAP_TYPE_ns2__AccessPointInfoBase (1343)
/* Type ns2__AccessPointInfoBase is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AccessPointInfoBase complex type: */
class SOAP_CMAC ns2__AccessPointInfoBase : public ns3__DataEntity
{
public:
	char *Name;	/* required element of XSD type ns3:Name */
	char *Description;	/* optional element of XSD type ns3:Description */
	char *AreaFrom;	/* optional element of XSD type ns3:ReferenceToken */
	char *AreaTo;	/* optional element of XSD type ns3:ReferenceToken */
	char *EntityType;	/* optional element of XSD type xsd:QName */
	char *Entity;	/* required element of XSD type ns3:ReferenceToken */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AccessPointInfoBase (1343)
	virtual int soap_type(void) const { return 1343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AccessPointInfoBase, default initialized and not managed by a soap context
	virtual ns2__AccessPointInfoBase *soap_alloc(void) const { return SOAP_NEW(ns2__AccessPointInfoBase); }
	         ns2__AccessPointInfoBase() { ns2__AccessPointInfoBase::soap_default(NULL); }
	virtual ~ns2__AccessPointInfoBase() { }
	friend SOAP_FMAC1 ns2__AccessPointInfoBase * SOAP_FMAC2 soap_instantiate_ns2__AccessPointInfoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4002 */
#ifndef SOAP_TYPE_ns2__AreaInfoBase
#define SOAP_TYPE_ns2__AreaInfoBase (1346)
/* Type ns2__AreaInfoBase is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AreaInfoBase complex type: */
class SOAP_CMAC ns2__AreaInfoBase : public ns3__DataEntity
{
public:
	char *Name;	/* required element of XSD type ns3:Name */
	char *Description;	/* optional element of XSD type ns3:Description */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AreaInfoBase (1346)
	virtual int soap_type(void) const { return 1346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AreaInfoBase, default initialized and not managed by a soap context
	virtual ns2__AreaInfoBase *soap_alloc(void) const { return SOAP_NEW(ns2__AreaInfoBase); }
	         ns2__AreaInfoBase() { ns2__AreaInfoBase::soap_default(NULL); }
	virtual ~ns2__AreaInfoBase() { }
	friend SOAP_FMAC1 ns2__AreaInfoBase * SOAP_FMAC2 soap_instantiate_ns2__AreaInfoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4071 */
#ifndef SOAP_TYPE_ns4__DoorInfoBase
#define SOAP_TYPE_ns4__DoorInfoBase (1369)
/* Type ns4__DoorInfoBase is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorInfoBase complex type: */
class SOAP_CMAC ns4__DoorInfoBase : public ns3__DataEntity
{
public:
	char *Name;	/* required element of XSD type ns3:Name */
	char *Description;	/* optional element of XSD type ns3:Description */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorInfoBase (1369)
	virtual int soap_type(void) const { return 1369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorInfoBase, default initialized and not managed by a soap context
	virtual ns4__DoorInfoBase *soap_alloc(void) const { return SOAP_NEW(ns4__DoorInfoBase); }
	         ns4__DoorInfoBase() { ns4__DoorInfoBase::soap_default(NULL); }
	virtual ~ns4__DoorInfoBase() { }
	friend SOAP_FMAC1 ns4__DoorInfoBase * SOAP_FMAC2 soap_instantiate_ns4__DoorInfoBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:3996 */
#ifndef SOAP_TYPE_ns2__AccessPointInfo
#define SOAP_TYPE_ns2__AccessPointInfo (1344)
/* Type ns2__AccessPointInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AccessPointInfo complex type: */
class SOAP_CMAC ns2__AccessPointInfo : public ns2__AccessPointInfoBase
{
public:
	ns2__AccessPointCapabilities *Capabilities;	/* required element of XSD type ns2:AccessPointCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AccessPointInfo (1344)
	virtual int soap_type(void) const { return 1344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AccessPointInfo, default initialized and not managed by a soap context
	virtual ns2__AccessPointInfo *soap_alloc(void) const { return SOAP_NEW(ns2__AccessPointInfo); }
	         ns2__AccessPointInfo() { ns2__AccessPointInfo::soap_default(NULL); }
	virtual ~ns2__AccessPointInfo() { }
	friend SOAP_FMAC1 ns2__AccessPointInfo * SOAP_FMAC2 soap_instantiate_ns2__AccessPointInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4005 */
#ifndef SOAP_TYPE_ns2__AreaInfo
#define SOAP_TYPE_ns2__AreaInfo (1347)
/* Type ns2__AreaInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns2:AreaInfo complex type: */
class SOAP_CMAC ns2__AreaInfo : public ns2__AreaInfoBase
{
public:
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AreaInfo (1347)
	virtual int soap_type(void) const { return 1347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AreaInfo, default initialized and not managed by a soap context
	virtual ns2__AreaInfo *soap_alloc(void) const { return SOAP_NEW(ns2__AreaInfo); }
	         ns2__AreaInfo() { ns2__AreaInfo::soap_default(NULL); }
	virtual ~ns2__AreaInfo() { }
	friend SOAP_FMAC1 ns2__AreaInfo * SOAP_FMAC2 soap_instantiate_ns2__AreaInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:4074 */
#ifndef SOAP_TYPE_ns4__DoorInfo
#define SOAP_TYPE_ns4__DoorInfo (1370)
/* Type ns4__DoorInfo is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns4:DoorInfo complex type: */
class SOAP_CMAC ns4__DoorInfo : public ns4__DoorInfoBase
{
public:
	ns4__DoorCapabilities *Capabilities;	/* required element of XSD type ns4:DoorCapabilities */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char *__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__DoorInfo (1370)
	virtual int soap_type(void) const { return 1370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__DoorInfo, default initialized and not managed by a soap context
	virtual ns4__DoorInfo *soap_alloc(void) const { return SOAP_NEW(ns4__DoorInfo); }
	         ns4__DoorInfo() { ns4__DoorInfo::soap_default(NULL); }
	virtual ~ns4__DoorInfo() { }
	friend SOAP_FMAC1 ns4__DoorInfo * SOAP_FMAC2 soap_instantiate_ns4__DoorInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (34)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	wsnt__InvalidFilterFaultType *wsnt__InvalidFilterFault;	/* optional element of XSD type wsnt:InvalidFilterFaultType */
	wsnt__InvalidMessageContentExpressionFaultType *wsnt__InvalidMessageContentExpressionFault;	/* optional element of XSD type wsnt:InvalidMessageContentExpressionFaultType */
	wsnt__InvalidProducerPropertiesExpressionFaultType *wsnt__InvalidProducerPropertiesExpressionFault;	/* optional element of XSD type wsnt:InvalidProducerPropertiesExpressionFaultType */
	wsnt__InvalidTopicExpressionFaultType *wsnt__InvalidTopicExpressionFault;	/* optional element of XSD type wsnt:InvalidTopicExpressionFaultType */
	wsnt__MultipleTopicsSpecifiedFaultType *wsnt__MultipleTopicsSpecifiedFault;	/* optional element of XSD type wsnt:MultipleTopicsSpecifiedFaultType */
	wsnt__NoCurrentMessageOnTopicFaultType *wsnt__NoCurrentMessageOnTopicFault;	/* optional element of XSD type wsnt:NoCurrentMessageOnTopicFaultType */
	wsnt__NotifyMessageNotSupportedFaultType *wsnt__NotifyMessageNotSupportedFault;	/* optional element of XSD type wsnt:NotifyMessageNotSupportedFaultType */
	wsnt__PauseFailedFaultType *wsnt__PauseFailedFault;	/* optional element of XSD type wsnt:PauseFailedFaultType */
	_tev__PullMessagesFaultResponse *tev__PullMessagesFaultResponse;	/* optional element of XSD type tev:PullMessagesFaultResponse */
	wsrfr__ResourceUnknownFaultType *wsrfr__ResourceUnknownFault;	/* optional element of XSD type wsrfr:ResourceUnknownFaultType */
	wsnt__ResumeFailedFaultType *wsnt__ResumeFailedFault;	/* optional element of XSD type wsnt:ResumeFailedFaultType */
	wsnt__SubscribeCreationFailedFaultType *wsnt__SubscribeCreationFailedFault;	/* optional element of XSD type wsnt:SubscribeCreationFailedFaultType */
	wsnt__TopicExpressionDialectUnknownFaultType *wsnt__TopicExpressionDialectUnknownFault;	/* optional element of XSD type wsnt:TopicExpressionDialectUnknownFaultType */
	wsnt__TopicNotSupportedFaultType *wsnt__TopicNotSupportedFault;	/* optional element of XSD type wsnt:TopicNotSupportedFaultType */
	wsnt__UnableToCreatePullPointFaultType *wsnt__UnableToCreatePullPointFault;	/* optional element of XSD type wsnt:UnableToCreatePullPointFaultType */
	wsnt__UnableToDestroyPullPointFaultType *wsnt__UnableToDestroyPullPointFault;	/* optional element of XSD type wsnt:UnableToDestroyPullPointFaultType */
	wsnt__UnableToDestroySubscriptionFaultType *wsnt__UnableToDestroySubscriptionFault;	/* optional element of XSD type wsnt:UnableToDestroySubscriptionFaultType */
	wsnt__UnableToGetMessagesFaultType *wsnt__UnableToGetMessagesFault;	/* optional element of XSD type wsnt:UnableToGetMessagesFaultType */
	wsnt__UnacceptableInitialTerminationTimeFaultType *wsnt__UnacceptableInitialTerminationTimeFault;	/* optional element of XSD type wsnt:UnacceptableInitialTerminationTimeFaultType */
	wsnt__UnacceptableTerminationTimeFaultType *wsnt__UnacceptableTerminationTimeFault;	/* optional element of XSD type wsnt:UnacceptableTerminationTimeFaultType */
	wsnt__UnrecognizedPolicyRequestFaultType *wsnt__UnrecognizedPolicyRequestFault;	/* optional element of XSD type wsnt:UnrecognizedPolicyRequestFaultType */
	wsnt__UnsupportedPolicyRequestFaultType *wsnt__UnsupportedPolicyRequestFault;	/* optional element of XSD type wsnt:UnsupportedPolicyRequestFaultType */
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
	char *__any;
public:
	int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ../../wsdl/onvif.h:47671 */
#ifndef SOAP_TYPE___ns1__GetSupportedActions
#define SOAP_TYPE___ns1__GetSupportedActions (2327)
/* Operation wrapper: */
struct __ns1__GetSupportedActions
{
public:
	_ns1__GetSupportedActions *ns1__GetSupportedActions;	/* optional element of XSD type ns1:GetSupportedActions */
public:
	int soap_type() const { return 2327; } /* = unique type id SOAP_TYPE___ns1__GetSupportedActions */
	         __ns1__GetSupportedActions();
	friend SOAP_FMAC1 __ns1__GetSupportedActions * SOAP_FMAC2 soap_instantiate___ns1__GetSupportedActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:47738 */
#ifndef SOAP_TYPE___ns1__GetActions
#define SOAP_TYPE___ns1__GetActions (2331)
/* Operation wrapper: */
struct __ns1__GetActions
{
public:
	_ns1__GetActions *ns1__GetActions;	/* optional element of XSD type ns1:GetActions */
public:
	int soap_type() const { return 2331; } /* = unique type id SOAP_TYPE___ns1__GetActions */
	         __ns1__GetActions();
	friend SOAP_FMAC1 __ns1__GetActions * SOAP_FMAC2 soap_instantiate___ns1__GetActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:47807 */
#ifndef SOAP_TYPE___ns1__CreateActions
#define SOAP_TYPE___ns1__CreateActions (2335)
/* Operation wrapper: */
struct __ns1__CreateActions
{
public:
	_ns1__CreateActions *ns1__CreateActions;	/* optional element of XSD type ns1:CreateActions */
public:
	int soap_type() const { return 2335; } /* = unique type id SOAP_TYPE___ns1__CreateActions */
	         __ns1__CreateActions();
	friend SOAP_FMAC1 __ns1__CreateActions * SOAP_FMAC2 soap_instantiate___ns1__CreateActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:47876 */
#ifndef SOAP_TYPE___ns1__DeleteActions
#define SOAP_TYPE___ns1__DeleteActions (2339)
/* Operation wrapper: */
struct __ns1__DeleteActions
{
public:
	_ns1__DeleteActions *ns1__DeleteActions;	/* optional element of XSD type ns1:DeleteActions */
public:
	int soap_type() const { return 2339; } /* = unique type id SOAP_TYPE___ns1__DeleteActions */
	         __ns1__DeleteActions();
	friend SOAP_FMAC1 __ns1__DeleteActions * SOAP_FMAC2 soap_instantiate___ns1__DeleteActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:47943 */
#ifndef SOAP_TYPE___ns1__ModifyActions
#define SOAP_TYPE___ns1__ModifyActions (2343)
/* Operation wrapper: */
struct __ns1__ModifyActions
{
public:
	_ns1__ModifyActions *ns1__ModifyActions;	/* optional element of XSD type ns1:ModifyActions */
public:
	int soap_type() const { return 2343; } /* = unique type id SOAP_TYPE___ns1__ModifyActions */
	         __ns1__ModifyActions();
	friend SOAP_FMAC1 __ns1__ModifyActions * SOAP_FMAC2 soap_instantiate___ns1__ModifyActions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48010 */
#ifndef SOAP_TYPE___ns1__GetServiceCapabilities
#define SOAP_TYPE___ns1__GetServiceCapabilities (2347)
/* Operation wrapper: */
struct __ns1__GetServiceCapabilities
{
public:
	_ns1__GetServiceCapabilities *ns1__GetServiceCapabilities;	/* optional element of XSD type ns1:GetServiceCapabilities */
public:
	int soap_type() const { return 2347; } /* = unique type id SOAP_TYPE___ns1__GetServiceCapabilities */
	         __ns1__GetServiceCapabilities();
	friend SOAP_FMAC1 __ns1__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns1__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48077 */
#ifndef SOAP_TYPE___ns1__GetActionTriggers
#define SOAP_TYPE___ns1__GetActionTriggers (2351)
/* Operation wrapper: */
struct __ns1__GetActionTriggers
{
public:
	_ns1__GetActionTriggers *ns1__GetActionTriggers;	/* optional element of XSD type ns1:GetActionTriggers */
public:
	int soap_type() const { return 2351; } /* = unique type id SOAP_TYPE___ns1__GetActionTriggers */
	         __ns1__GetActionTriggers();
	friend SOAP_FMAC1 __ns1__GetActionTriggers * SOAP_FMAC2 soap_instantiate___ns1__GetActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48146 */
#ifndef SOAP_TYPE___ns1__CreateActionTriggers
#define SOAP_TYPE___ns1__CreateActionTriggers (2355)
/* Operation wrapper: */
struct __ns1__CreateActionTriggers
{
public:
	_ns1__CreateActionTriggers *ns1__CreateActionTriggers;	/* optional element of XSD type ns1:CreateActionTriggers */
public:
	int soap_type() const { return 2355; } /* = unique type id SOAP_TYPE___ns1__CreateActionTriggers */
	         __ns1__CreateActionTriggers();
	friend SOAP_FMAC1 __ns1__CreateActionTriggers * SOAP_FMAC2 soap_instantiate___ns1__CreateActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48215 */
#ifndef SOAP_TYPE___ns1__DeleteActionTriggers
#define SOAP_TYPE___ns1__DeleteActionTriggers (2359)
/* Operation wrapper: */
struct __ns1__DeleteActionTriggers
{
public:
	_ns1__DeleteActionTriggers *ns1__DeleteActionTriggers;	/* optional element of XSD type ns1:DeleteActionTriggers */
public:
	int soap_type() const { return 2359; } /* = unique type id SOAP_TYPE___ns1__DeleteActionTriggers */
	         __ns1__DeleteActionTriggers();
	friend SOAP_FMAC1 __ns1__DeleteActionTriggers * SOAP_FMAC2 soap_instantiate___ns1__DeleteActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48284 */
#ifndef SOAP_TYPE___ns1__ModifyActionTriggers
#define SOAP_TYPE___ns1__ModifyActionTriggers (2363)
/* Operation wrapper: */
struct __ns1__ModifyActionTriggers
{
public:
	_ns1__ModifyActionTriggers *ns1__ModifyActionTriggers;	/* optional element of XSD type ns1:ModifyActionTriggers */
public:
	int soap_type() const { return 2363; } /* = unique type id SOAP_TYPE___ns1__ModifyActionTriggers */
	         __ns1__ModifyActionTriggers();
	friend SOAP_FMAC1 __ns1__ModifyActionTriggers * SOAP_FMAC2 soap_instantiate___ns1__ModifyActionTriggers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48373 */
#ifndef SOAP_TYPE___ns2__GetServiceCapabilities
#define SOAP_TYPE___ns2__GetServiceCapabilities (2367)
/* Operation wrapper: */
struct __ns2__GetServiceCapabilities
{
public:
	_ns2__GetServiceCapabilities *ns2__GetServiceCapabilities;	/* optional element of XSD type ns2:GetServiceCapabilities */
public:
	int soap_type() const { return 2367; } /* = unique type id SOAP_TYPE___ns2__GetServiceCapabilities */
	         __ns2__GetServiceCapabilities();
	friend SOAP_FMAC1 __ns2__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns2__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48452 */
#ifndef SOAP_TYPE___ns2__GetAccessPointInfoList
#define SOAP_TYPE___ns2__GetAccessPointInfoList (2371)
/* Operation wrapper: */
struct __ns2__GetAccessPointInfoList
{
public:
	_ns2__GetAccessPointInfoList *ns2__GetAccessPointInfoList;	/* optional element of XSD type ns2:GetAccessPointInfoList */
public:
	int soap_type() const { return 2371; } /* = unique type id SOAP_TYPE___ns2__GetAccessPointInfoList */
	         __ns2__GetAccessPointInfoList();
	friend SOAP_FMAC1 __ns2__GetAccessPointInfoList * SOAP_FMAC2 soap_instantiate___ns2__GetAccessPointInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48532 */
#ifndef SOAP_TYPE___ns2__GetAccessPointInfo
#define SOAP_TYPE___ns2__GetAccessPointInfo (2375)
/* Operation wrapper: */
struct __ns2__GetAccessPointInfo
{
public:
	_ns2__GetAccessPointInfo *ns2__GetAccessPointInfo;	/* optional element of XSD type ns2:GetAccessPointInfo */
public:
	int soap_type() const { return 2375; } /* = unique type id SOAP_TYPE___ns2__GetAccessPointInfo */
	         __ns2__GetAccessPointInfo();
	friend SOAP_FMAC1 __ns2__GetAccessPointInfo * SOAP_FMAC2 soap_instantiate___ns2__GetAccessPointInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48612 */
#ifndef SOAP_TYPE___ns2__GetAreaInfoList
#define SOAP_TYPE___ns2__GetAreaInfoList (2379)
/* Operation wrapper: */
struct __ns2__GetAreaInfoList
{
public:
	_ns2__GetAreaInfoList *ns2__GetAreaInfoList;	/* optional element of XSD type ns2:GetAreaInfoList */
public:
	int soap_type() const { return 2379; } /* = unique type id SOAP_TYPE___ns2__GetAreaInfoList */
	         __ns2__GetAreaInfoList();
	friend SOAP_FMAC1 __ns2__GetAreaInfoList * SOAP_FMAC2 soap_instantiate___ns2__GetAreaInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48692 */
#ifndef SOAP_TYPE___ns2__GetAreaInfo
#define SOAP_TYPE___ns2__GetAreaInfo (2383)
/* Operation wrapper: */
struct __ns2__GetAreaInfo
{
public:
	_ns2__GetAreaInfo *ns2__GetAreaInfo;	/* optional element of XSD type ns2:GetAreaInfo */
public:
	int soap_type() const { return 2383; } /* = unique type id SOAP_TYPE___ns2__GetAreaInfo */
	         __ns2__GetAreaInfo();
	friend SOAP_FMAC1 __ns2__GetAreaInfo * SOAP_FMAC2 soap_instantiate___ns2__GetAreaInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48764 */
#ifndef SOAP_TYPE___ns2__GetAccessPointState
#define SOAP_TYPE___ns2__GetAccessPointState (2387)
/* Operation wrapper: */
struct __ns2__GetAccessPointState
{
public:
	_ns2__GetAccessPointState *ns2__GetAccessPointState;	/* optional element of XSD type ns2:GetAccessPointState */
public:
	int soap_type() const { return 2387; } /* = unique type id SOAP_TYPE___ns2__GetAccessPointState */
	         __ns2__GetAccessPointState();
	friend SOAP_FMAC1 __ns2__GetAccessPointState * SOAP_FMAC2 soap_instantiate___ns2__GetAccessPointState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48837 */
#ifndef SOAP_TYPE___ns2__EnableAccessPoint
#define SOAP_TYPE___ns2__EnableAccessPoint (2391)
/* Operation wrapper: */
struct __ns2__EnableAccessPoint
{
public:
	_ns2__EnableAccessPoint *ns2__EnableAccessPoint;	/* optional element of XSD type ns2:EnableAccessPoint */
public:
	int soap_type() const { return 2391; } /* = unique type id SOAP_TYPE___ns2__EnableAccessPoint */
	         __ns2__EnableAccessPoint();
	friend SOAP_FMAC1 __ns2__EnableAccessPoint * SOAP_FMAC2 soap_instantiate___ns2__EnableAccessPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48910 */
#ifndef SOAP_TYPE___ns2__DisableAccessPoint
#define SOAP_TYPE___ns2__DisableAccessPoint (2395)
/* Operation wrapper: */
struct __ns2__DisableAccessPoint
{
public:
	_ns2__DisableAccessPoint *ns2__DisableAccessPoint;	/* optional element of XSD type ns2:DisableAccessPoint */
public:
	int soap_type() const { return 2395; } /* = unique type id SOAP_TYPE___ns2__DisableAccessPoint */
	         __ns2__DisableAccessPoint();
	friend SOAP_FMAC1 __ns2__DisableAccessPoint * SOAP_FMAC2 soap_instantiate___ns2__DisableAccessPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:48981 */
#ifndef SOAP_TYPE___ns2__ExternalAuthorization
#define SOAP_TYPE___ns2__ExternalAuthorization (2399)
/* Operation wrapper: */
struct __ns2__ExternalAuthorization
{
public:
	_ns2__ExternalAuthorization *ns2__ExternalAuthorization;	/* optional element of XSD type ns2:ExternalAuthorization */
public:
	int soap_type() const { return 2399; } /* = unique type id SOAP_TYPE___ns2__ExternalAuthorization */
	         __ns2__ExternalAuthorization();
	friend SOAP_FMAC1 __ns2__ExternalAuthorization * SOAP_FMAC2 soap_instantiate___ns2__ExternalAuthorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49070 */
#ifndef SOAP_TYPE___ns4__GetServiceCapabilities
#define SOAP_TYPE___ns4__GetServiceCapabilities (2403)
/* Operation wrapper: */
struct __ns4__GetServiceCapabilities
{
public:
	_ns4__GetServiceCapabilities *ns4__GetServiceCapabilities;	/* optional element of XSD type ns4:GetServiceCapabilities */
public:
	int soap_type() const { return 2403; } /* = unique type id SOAP_TYPE___ns4__GetServiceCapabilities */
	         __ns4__GetServiceCapabilities();
	friend SOAP_FMAC1 __ns4__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___ns4__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49148 */
#ifndef SOAP_TYPE___ns4__GetDoorInfoList
#define SOAP_TYPE___ns4__GetDoorInfoList (2407)
/* Operation wrapper: */
struct __ns4__GetDoorInfoList
{
public:
	_ns4__GetDoorInfoList *ns4__GetDoorInfoList;	/* optional element of XSD type ns4:GetDoorInfoList */
public:
	int soap_type() const { return 2407; } /* = unique type id SOAP_TYPE___ns4__GetDoorInfoList */
	         __ns4__GetDoorInfoList();
	friend SOAP_FMAC1 __ns4__GetDoorInfoList * SOAP_FMAC2 soap_instantiate___ns4__GetDoorInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49225 */
#ifndef SOAP_TYPE___ns4__GetDoorInfo
#define SOAP_TYPE___ns4__GetDoorInfo (2411)
/* Operation wrapper: */
struct __ns4__GetDoorInfo
{
public:
	_ns4__GetDoorInfo *ns4__GetDoorInfo;	/* optional element of XSD type ns4:GetDoorInfo */
public:
	int soap_type() const { return 2411; } /* = unique type id SOAP_TYPE___ns4__GetDoorInfo */
	         __ns4__GetDoorInfo();
	friend SOAP_FMAC1 __ns4__GetDoorInfo * SOAP_FMAC2 soap_instantiate___ns4__GetDoorInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49297 */
#ifndef SOAP_TYPE___ns4__GetDoorState
#define SOAP_TYPE___ns4__GetDoorState (2415)
/* Operation wrapper: */
struct __ns4__GetDoorState
{
public:
	_ns4__GetDoorState *ns4__GetDoorState;	/* optional element of XSD type ns4:GetDoorState */
public:
	int soap_type() const { return 2415; } /* = unique type id SOAP_TYPE___ns4__GetDoorState */
	         __ns4__GetDoorState();
	friend SOAP_FMAC1 __ns4__GetDoorState * SOAP_FMAC2 soap_instantiate___ns4__GetDoorState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49387 */
#ifndef SOAP_TYPE___ns4__AccessDoor
#define SOAP_TYPE___ns4__AccessDoor (2419)
/* Operation wrapper: */
struct __ns4__AccessDoor
{
public:
	_ns4__AccessDoor *ns4__AccessDoor;	/* optional element of XSD type ns4:AccessDoor */
public:
	int soap_type() const { return 2419; } /* = unique type id SOAP_TYPE___ns4__AccessDoor */
	         __ns4__AccessDoor();
	friend SOAP_FMAC1 __ns4__AccessDoor * SOAP_FMAC2 soap_instantiate___ns4__AccessDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49463 */
#ifndef SOAP_TYPE___ns4__LockDoor
#define SOAP_TYPE___ns4__LockDoor (2423)
/* Operation wrapper: */
struct __ns4__LockDoor
{
public:
	_ns4__LockDoor *ns4__LockDoor;	/* optional element of XSD type ns4:LockDoor */
public:
	int soap_type() const { return 2423; } /* = unique type id SOAP_TYPE___ns4__LockDoor */
	         __ns4__LockDoor();
	friend SOAP_FMAC1 __ns4__LockDoor * SOAP_FMAC2 soap_instantiate___ns4__LockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49539 */
#ifndef SOAP_TYPE___ns4__UnlockDoor
#define SOAP_TYPE___ns4__UnlockDoor (2427)
/* Operation wrapper: */
struct __ns4__UnlockDoor
{
public:
	_ns4__UnlockDoor *ns4__UnlockDoor;	/* optional element of XSD type ns4:UnlockDoor */
public:
	int soap_type() const { return 2427; } /* = unique type id SOAP_TYPE___ns4__UnlockDoor */
	         __ns4__UnlockDoor();
	friend SOAP_FMAC1 __ns4__UnlockDoor * SOAP_FMAC2 soap_instantiate___ns4__UnlockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49616 */
#ifndef SOAP_TYPE___ns4__BlockDoor
#define SOAP_TYPE___ns4__BlockDoor (2431)
/* Operation wrapper: */
struct __ns4__BlockDoor
{
public:
	_ns4__BlockDoor *ns4__BlockDoor;	/* optional element of XSD type ns4:BlockDoor */
public:
	int soap_type() const { return 2431; } /* = unique type id SOAP_TYPE___ns4__BlockDoor */
	         __ns4__BlockDoor();
	friend SOAP_FMAC1 __ns4__BlockDoor * SOAP_FMAC2 soap_instantiate___ns4__BlockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49699 */
#ifndef SOAP_TYPE___ns4__LockDownDoor
#define SOAP_TYPE___ns4__LockDownDoor (2435)
/* Operation wrapper: */
struct __ns4__LockDownDoor
{
public:
	_ns4__LockDownDoor *ns4__LockDownDoor;	/* optional element of XSD type ns4:LockDownDoor */
public:
	int soap_type() const { return 2435; } /* = unique type id SOAP_TYPE___ns4__LockDownDoor */
	         __ns4__LockDownDoor();
	friend SOAP_FMAC1 __ns4__LockDownDoor * SOAP_FMAC2 soap_instantiate___ns4__LockDownDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49771 */
#ifndef SOAP_TYPE___ns4__LockDownReleaseDoor
#define SOAP_TYPE___ns4__LockDownReleaseDoor (2439)
/* Operation wrapper: */
struct __ns4__LockDownReleaseDoor
{
public:
	_ns4__LockDownReleaseDoor *ns4__LockDownReleaseDoor;	/* optional element of XSD type ns4:LockDownReleaseDoor */
public:
	int soap_type() const { return 2439; } /* = unique type id SOAP_TYPE___ns4__LockDownReleaseDoor */
	         __ns4__LockDownReleaseDoor();
	friend SOAP_FMAC1 __ns4__LockDownReleaseDoor * SOAP_FMAC2 soap_instantiate___ns4__LockDownReleaseDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49851 */
#ifndef SOAP_TYPE___ns4__LockOpenDoor
#define SOAP_TYPE___ns4__LockOpenDoor (2443)
/* Operation wrapper: */
struct __ns4__LockOpenDoor
{
public:
	_ns4__LockOpenDoor *ns4__LockOpenDoor;	/* optional element of XSD type ns4:LockOpenDoor */
public:
	int soap_type() const { return 2443; } /* = unique type id SOAP_TYPE___ns4__LockOpenDoor */
	         __ns4__LockOpenDoor();
	friend SOAP_FMAC1 __ns4__LockOpenDoor * SOAP_FMAC2 soap_instantiate___ns4__LockOpenDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:49924 */
#ifndef SOAP_TYPE___ns4__LockOpenReleaseDoor
#define SOAP_TYPE___ns4__LockOpenReleaseDoor (2447)
/* Operation wrapper: */
struct __ns4__LockOpenReleaseDoor
{
public:
	_ns4__LockOpenReleaseDoor *ns4__LockOpenReleaseDoor;	/* optional element of XSD type ns4:LockOpenReleaseDoor */
public:
	int soap_type() const { return 2447; } /* = unique type id SOAP_TYPE___ns4__LockOpenReleaseDoor */
	         __ns4__LockOpenReleaseDoor();
	friend SOAP_FMAC1 __ns4__LockOpenReleaseDoor * SOAP_FMAC2 soap_instantiate___ns4__LockOpenReleaseDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50002 */
#ifndef SOAP_TYPE___ns4__DoubleLockDoor
#define SOAP_TYPE___ns4__DoubleLockDoor (2451)
/* Operation wrapper: */
struct __ns4__DoubleLockDoor
{
public:
	_ns4__DoubleLockDoor *ns4__DoubleLockDoor;	/* optional element of XSD type ns4:DoubleLockDoor */
public:
	int soap_type() const { return 2451; } /* = unique type id SOAP_TYPE___ns4__DoubleLockDoor */
	         __ns4__DoubleLockDoor();
	friend SOAP_FMAC1 __ns4__DoubleLockDoor * SOAP_FMAC2 soap_instantiate___ns4__DoubleLockDoor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50088 */
#ifndef SOAP_TYPE___tad__GetServiceCapabilities
#define SOAP_TYPE___tad__GetServiceCapabilities (2455)
/* Operation wrapper: */
struct __tad__GetServiceCapabilities
{
public:
	_tad__GetServiceCapabilities *tad__GetServiceCapabilities;	/* optional element of XSD type tad:GetServiceCapabilities */
public:
	int soap_type() const { return 2455; } /* = unique type id SOAP_TYPE___tad__GetServiceCapabilities */
	         __tad__GetServiceCapabilities();
	friend SOAP_FMAC1 __tad__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tad__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50155 */
#ifndef SOAP_TYPE___tad__DeleteAnalyticsEngineControl
#define SOAP_TYPE___tad__DeleteAnalyticsEngineControl (2459)
/* Operation wrapper: */
struct __tad__DeleteAnalyticsEngineControl
{
public:
	_tad__DeleteAnalyticsEngineControl *tad__DeleteAnalyticsEngineControl;	/* optional element of XSD type tad:DeleteAnalyticsEngineControl */
public:
	int soap_type() const { return 2459; } /* = unique type id SOAP_TYPE___tad__DeleteAnalyticsEngineControl */
	         __tad__DeleteAnalyticsEngineControl();
	friend SOAP_FMAC1 __tad__DeleteAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate___tad__DeleteAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50222 */
#ifndef SOAP_TYPE___tad__CreateAnalyticsEngineControl
#define SOAP_TYPE___tad__CreateAnalyticsEngineControl (2463)
/* Operation wrapper: */
struct __tad__CreateAnalyticsEngineControl
{
public:
	_tad__CreateAnalyticsEngineControl *tad__CreateAnalyticsEngineControl;	/* optional element of XSD type tad:CreateAnalyticsEngineControl */
public:
	int soap_type() const { return 2463; } /* = unique type id SOAP_TYPE___tad__CreateAnalyticsEngineControl */
	         __tad__CreateAnalyticsEngineControl();
	friend SOAP_FMAC1 __tad__CreateAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate___tad__CreateAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50289 */
#ifndef SOAP_TYPE___tad__SetAnalyticsEngineControl
#define SOAP_TYPE___tad__SetAnalyticsEngineControl (2467)
/* Operation wrapper: */
struct __tad__SetAnalyticsEngineControl
{
public:
	_tad__SetAnalyticsEngineControl *tad__SetAnalyticsEngineControl;	/* optional element of XSD type tad:SetAnalyticsEngineControl */
public:
	int soap_type() const { return 2467; } /* = unique type id SOAP_TYPE___tad__SetAnalyticsEngineControl */
	         __tad__SetAnalyticsEngineControl();
	friend SOAP_FMAC1 __tad__SetAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate___tad__SetAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50357 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngineControl
#define SOAP_TYPE___tad__GetAnalyticsEngineControl (2471)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngineControl
{
public:
	_tad__GetAnalyticsEngineControl *tad__GetAnalyticsEngineControl;	/* optional element of XSD type tad:GetAnalyticsEngineControl */
public:
	int soap_type() const { return 2471; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngineControl */
	         __tad__GetAnalyticsEngineControl();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngineControl * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50424 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngineControls
#define SOAP_TYPE___tad__GetAnalyticsEngineControls (2475)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngineControls
{
public:
	_tad__GetAnalyticsEngineControls *tad__GetAnalyticsEngineControls;	/* optional element of XSD type tad:GetAnalyticsEngineControls */
public:
	int soap_type() const { return 2475; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngineControls */
	         __tad__GetAnalyticsEngineControls();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngineControls * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngineControls(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50492 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngine
#define SOAP_TYPE___tad__GetAnalyticsEngine (2479)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngine
{
public:
	_tad__GetAnalyticsEngine *tad__GetAnalyticsEngine;	/* optional element of XSD type tad:GetAnalyticsEngine */
public:
	int soap_type() const { return 2479; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngine */
	         __tad__GetAnalyticsEngine();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngine * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50559 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngines
#define SOAP_TYPE___tad__GetAnalyticsEngines (2483)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngines
{
public:
	_tad__GetAnalyticsEngines *tad__GetAnalyticsEngines;	/* optional element of XSD type tad:GetAnalyticsEngines */
public:
	int soap_type() const { return 2483; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngines */
	         __tad__GetAnalyticsEngines();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngines * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngines(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50626 */
#ifndef SOAP_TYPE___tad__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___tad__SetVideoAnalyticsConfiguration (2487)
/* Operation wrapper: */
struct __tad__SetVideoAnalyticsConfiguration
{
public:
	_tad__SetVideoAnalyticsConfiguration *tad__SetVideoAnalyticsConfiguration;	/* optional element of XSD type tad:SetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2487; } /* = unique type id SOAP_TYPE___tad__SetVideoAnalyticsConfiguration */
	         __tad__SetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __tad__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___tad__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50693 */
#ifndef SOAP_TYPE___tad__SetAnalyticsEngineInput
#define SOAP_TYPE___tad__SetAnalyticsEngineInput (2491)
/* Operation wrapper: */
struct __tad__SetAnalyticsEngineInput
{
public:
	_tad__SetAnalyticsEngineInput *tad__SetAnalyticsEngineInput;	/* optional element of XSD type tad:SetAnalyticsEngineInput */
public:
	int soap_type() const { return 2491; } /* = unique type id SOAP_TYPE___tad__SetAnalyticsEngineInput */
	         __tad__SetAnalyticsEngineInput();
	friend SOAP_FMAC1 __tad__SetAnalyticsEngineInput * SOAP_FMAC2 soap_instantiate___tad__SetAnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50761 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngineInput
#define SOAP_TYPE___tad__GetAnalyticsEngineInput (2495)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngineInput
{
public:
	_tad__GetAnalyticsEngineInput *tad__GetAnalyticsEngineInput;	/* optional element of XSD type tad:GetAnalyticsEngineInput */
public:
	int soap_type() const { return 2495; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngineInput */
	         __tad__GetAnalyticsEngineInput();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngineInput * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50829 */
#ifndef SOAP_TYPE___tad__GetAnalyticsEngineInputs
#define SOAP_TYPE___tad__GetAnalyticsEngineInputs (2499)
/* Operation wrapper: */
struct __tad__GetAnalyticsEngineInputs
{
public:
	_tad__GetAnalyticsEngineInputs *tad__GetAnalyticsEngineInputs;	/* optional element of XSD type tad:GetAnalyticsEngineInputs */
public:
	int soap_type() const { return 2499; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsEngineInputs */
	         __tad__GetAnalyticsEngineInputs();
	friend SOAP_FMAC1 __tad__GetAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50897 */
#ifndef SOAP_TYPE___tad__GetAnalyticsDeviceStreamUri
#define SOAP_TYPE___tad__GetAnalyticsDeviceStreamUri (2503)
/* Operation wrapper: */
struct __tad__GetAnalyticsDeviceStreamUri
{
public:
	_tad__GetAnalyticsDeviceStreamUri *tad__GetAnalyticsDeviceStreamUri;	/* optional element of XSD type tad:GetAnalyticsDeviceStreamUri */
public:
	int soap_type() const { return 2503; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsDeviceStreamUri */
	         __tad__GetAnalyticsDeviceStreamUri();
	friend SOAP_FMAC1 __tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsDeviceStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:50965 */
#ifndef SOAP_TYPE___tad__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___tad__GetVideoAnalyticsConfiguration (2507)
/* Operation wrapper: */
struct __tad__GetVideoAnalyticsConfiguration
{
public:
	_tad__GetVideoAnalyticsConfiguration *tad__GetVideoAnalyticsConfiguration;	/* optional element of XSD type tad:GetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 2507; } /* = unique type id SOAP_TYPE___tad__GetVideoAnalyticsConfiguration */
	         __tad__GetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __tad__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___tad__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51032 */
#ifndef SOAP_TYPE___tad__CreateAnalyticsEngineInputs
#define SOAP_TYPE___tad__CreateAnalyticsEngineInputs (2511)
/* Operation wrapper: */
struct __tad__CreateAnalyticsEngineInputs
{
public:
	_tad__CreateAnalyticsEngineInputs *tad__CreateAnalyticsEngineInputs;	/* optional element of XSD type tad:CreateAnalyticsEngineInputs */
public:
	int soap_type() const { return 2511; } /* = unique type id SOAP_TYPE___tad__CreateAnalyticsEngineInputs */
	         __tad__CreateAnalyticsEngineInputs();
	friend SOAP_FMAC1 __tad__CreateAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate___tad__CreateAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51099 */
#ifndef SOAP_TYPE___tad__DeleteAnalyticsEngineInputs
#define SOAP_TYPE___tad__DeleteAnalyticsEngineInputs (2515)
/* Operation wrapper: */
struct __tad__DeleteAnalyticsEngineInputs
{
public:
	_tad__DeleteAnalyticsEngineInputs *tad__DeleteAnalyticsEngineInputs;	/* optional element of XSD type tad:DeleteAnalyticsEngineInputs */
public:
	int soap_type() const { return 2515; } /* = unique type id SOAP_TYPE___tad__DeleteAnalyticsEngineInputs */
	         __tad__DeleteAnalyticsEngineInputs();
	friend SOAP_FMAC1 __tad__DeleteAnalyticsEngineInputs * SOAP_FMAC2 soap_instantiate___tad__DeleteAnalyticsEngineInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51167 */
#ifndef SOAP_TYPE___tad__GetAnalyticsState
#define SOAP_TYPE___tad__GetAnalyticsState (2519)
/* Operation wrapper: */
struct __tad__GetAnalyticsState
{
public:
	_tad__GetAnalyticsState *tad__GetAnalyticsState;	/* optional element of XSD type tad:GetAnalyticsState */
public:
	int soap_type() const { return 2519; } /* = unique type id SOAP_TYPE___tad__GetAnalyticsState */
	         __tad__GetAnalyticsState();
	friend SOAP_FMAC1 __tad__GetAnalyticsState * SOAP_FMAC2 soap_instantiate___tad__GetAnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51258 */
#ifndef SOAP_TYPE___tan__GetSupportedRules
#define SOAP_TYPE___tan__GetSupportedRules (2523)
/* Operation wrapper: */
struct __tan__GetSupportedRules
{
public:
	_tan__GetSupportedRules *tan__GetSupportedRules;	/* optional element of XSD type tan:GetSupportedRules */
public:
	int soap_type() const { return 2523; } /* = unique type id SOAP_TYPE___tan__GetSupportedRules */
	         __tan__GetSupportedRules();
	friend SOAP_FMAC1 __tan__GetSupportedRules * SOAP_FMAC2 soap_instantiate___tan__GetSupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51328 */
#ifndef SOAP_TYPE___tan__CreateRules
#define SOAP_TYPE___tan__CreateRules (2527)
/* Operation wrapper: */
struct __tan__CreateRules
{
public:
	_tan__CreateRules *tan__CreateRules;	/* optional element of XSD type tan:CreateRules */
public:
	int soap_type() const { return 2527; } /* = unique type id SOAP_TYPE___tan__CreateRules */
	         __tan__CreateRules();
	friend SOAP_FMAC1 __tan__CreateRules * SOAP_FMAC2 soap_instantiate___tan__CreateRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51397 */
#ifndef SOAP_TYPE___tan__DeleteRules
#define SOAP_TYPE___tan__DeleteRules (2531)
/* Operation wrapper: */
struct __tan__DeleteRules
{
public:
	_tan__DeleteRules *tan__DeleteRules;	/* optional element of XSD type tan:DeleteRules */
public:
	int soap_type() const { return 2531; } /* = unique type id SOAP_TYPE___tan__DeleteRules */
	         __tan__DeleteRules();
	friend SOAP_FMAC1 __tan__DeleteRules * SOAP_FMAC2 soap_instantiate___tan__DeleteRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51466 */
#ifndef SOAP_TYPE___tan__GetRules
#define SOAP_TYPE___tan__GetRules (2535)
/* Operation wrapper: */
struct __tan__GetRules
{
public:
	_tan__GetRules *tan__GetRules;	/* optional element of XSD type tan:GetRules */
public:
	int soap_type() const { return 2535; } /* = unique type id SOAP_TYPE___tan__GetRules */
	         __tan__GetRules();
	friend SOAP_FMAC1 __tan__GetRules * SOAP_FMAC2 soap_instantiate___tan__GetRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51536 */
#ifndef SOAP_TYPE___tan__ModifyRules
#define SOAP_TYPE___tan__ModifyRules (2539)
/* Operation wrapper: */
struct __tan__ModifyRules
{
public:
	_tan__ModifyRules *tan__ModifyRules;	/* optional element of XSD type tan:ModifyRules */
public:
	int soap_type() const { return 2539; } /* = unique type id SOAP_TYPE___tan__ModifyRules */
	         __tan__ModifyRules();
	friend SOAP_FMAC1 __tan__ModifyRules * SOAP_FMAC2 soap_instantiate___tan__ModifyRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51604 */
#ifndef SOAP_TYPE___tan__GetServiceCapabilities
#define SOAP_TYPE___tan__GetServiceCapabilities (2543)
/* Operation wrapper: */
struct __tan__GetServiceCapabilities
{
public:
	_tan__GetServiceCapabilities *tan__GetServiceCapabilities;	/* optional element of XSD type tan:GetServiceCapabilities */
public:
	int soap_type() const { return 2543; } /* = unique type id SOAP_TYPE___tan__GetServiceCapabilities */
	         __tan__GetServiceCapabilities();
	friend SOAP_FMAC1 __tan__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tan__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51678 */
#ifndef SOAP_TYPE___tan__GetSupportedAnalyticsModules
#define SOAP_TYPE___tan__GetSupportedAnalyticsModules (2547)
/* Operation wrapper: */
struct __tan__GetSupportedAnalyticsModules
{
public:
	_tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules;	/* optional element of XSD type tan:GetSupportedAnalyticsModules */
public:
	int soap_type() const { return 2547; } /* = unique type id SOAP_TYPE___tan__GetSupportedAnalyticsModules */
	         __tan__GetSupportedAnalyticsModules();
	friend SOAP_FMAC1 __tan__GetSupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate___tan__GetSupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51749 */
#ifndef SOAP_TYPE___tan__CreateAnalyticsModules
#define SOAP_TYPE___tan__CreateAnalyticsModules (2551)
/* Operation wrapper: */
struct __tan__CreateAnalyticsModules
{
public:
	_tan__CreateAnalyticsModules *tan__CreateAnalyticsModules;	/* optional element of XSD type tan:CreateAnalyticsModules */
public:
	int soap_type() const { return 2551; } /* = unique type id SOAP_TYPE___tan__CreateAnalyticsModules */
	         __tan__CreateAnalyticsModules();
	friend SOAP_FMAC1 __tan__CreateAnalyticsModules * SOAP_FMAC2 soap_instantiate___tan__CreateAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51818 */
#ifndef SOAP_TYPE___tan__DeleteAnalyticsModules
#define SOAP_TYPE___tan__DeleteAnalyticsModules (2555)
/* Operation wrapper: */
struct __tan__DeleteAnalyticsModules
{
public:
	_tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules;	/* optional element of XSD type tan:DeleteAnalyticsModules */
public:
	int soap_type() const { return 2555; } /* = unique type id SOAP_TYPE___tan__DeleteAnalyticsModules */
	         __tan__DeleteAnalyticsModules();
	friend SOAP_FMAC1 __tan__DeleteAnalyticsModules * SOAP_FMAC2 soap_instantiate___tan__DeleteAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51888 */
#ifndef SOAP_TYPE___tan__GetAnalyticsModules
#define SOAP_TYPE___tan__GetAnalyticsModules (2559)
/* Operation wrapper: */
struct __tan__GetAnalyticsModules
{
public:
	_tan__GetAnalyticsModules *tan__GetAnalyticsModules;	/* optional element of XSD type tan:GetAnalyticsModules */
public:
	int soap_type() const { return 2559; } /* = unique type id SOAP_TYPE___tan__GetAnalyticsModules */
	         __tan__GetAnalyticsModules();
	friend SOAP_FMAC1 __tan__GetAnalyticsModules * SOAP_FMAC2 soap_instantiate___tan__GetAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:51959 */
#ifndef SOAP_TYPE___tan__ModifyAnalyticsModules
#define SOAP_TYPE___tan__ModifyAnalyticsModules (2563)
/* Operation wrapper: */
struct __tan__ModifyAnalyticsModules
{
public:
	_tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules;	/* optional element of XSD type tan:ModifyAnalyticsModules */
public:
	int soap_type() const { return 2563; } /* = unique type id SOAP_TYPE___tan__ModifyAnalyticsModules */
	         __tan__ModifyAnalyticsModules();
	friend SOAP_FMAC1 __tan__ModifyAnalyticsModules * SOAP_FMAC2 soap_instantiate___tan__ModifyAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52043 */
#ifndef SOAP_TYPE___tdn__Hello
#define SOAP_TYPE___tdn__Hello (2566)
/* Operation wrapper: */
struct __tdn__Hello
{
public:
	struct wsdd__HelloType tdn__Hello;	/* required element of XSD type wsdd:HelloType */
public:
	int soap_type() const { return 2566; } /* = unique type id SOAP_TYPE___tdn__Hello */
	         __tdn__Hello();
	friend SOAP_FMAC1 __tdn__Hello * SOAP_FMAC2 soap_instantiate___tdn__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52109 */
#ifndef SOAP_TYPE___tdn__Bye
#define SOAP_TYPE___tdn__Bye (2568)
/* Operation wrapper: */
struct __tdn__Bye
{
public:
	struct wsdd__ByeType tdn__Bye;	/* required element of XSD type wsdd:ByeType */
public:
	int soap_type() const { return 2568; } /* = unique type id SOAP_TYPE___tdn__Bye */
	         __tdn__Bye();
	friend SOAP_FMAC1 __tdn__Bye * SOAP_FMAC2 soap_instantiate___tdn__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52175 */
#ifndef SOAP_TYPE___tdn__Probe
#define SOAP_TYPE___tdn__Probe (2571)
/* Operation wrapper: */
struct __tdn__Probe
{
public:
	struct wsdd__ProbeType tdn__Probe;	/* required element of XSD type wsdd:ProbeType */
public:
	int soap_type() const { return 2571; } /* = unique type id SOAP_TYPE___tdn__Probe */
	         __tdn__Probe();
	friend SOAP_FMAC1 __tdn__Probe * SOAP_FMAC2 soap_instantiate___tdn__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52260 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (2575)
/* Operation wrapper: */
struct __tds__GetServices
{
public:
	_tds__GetServices *tds__GetServices;	/* optional element of XSD type tds:GetServices */
public:
	int soap_type() const { return 2575; } /* = unique type id SOAP_TYPE___tds__GetServices */
	         __tds__GetServices();
	friend SOAP_FMAC1 __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52328 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (2579)
/* Operation wrapper: */
struct __tds__GetServiceCapabilities
{
public:
	_tds__GetServiceCapabilities *tds__GetServiceCapabilities;	/* optional element of XSD type tds:GetServiceCapabilities */
public:
	int soap_type() const { return 2579; } /* = unique type id SOAP_TYPE___tds__GetServiceCapabilities */
	         __tds__GetServiceCapabilities();
	friend SOAP_FMAC1 __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52395 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (2583)
/* Operation wrapper: */
struct __tds__GetDeviceInformation
{
public:
	_tds__GetDeviceInformation *tds__GetDeviceInformation;	/* optional element of XSD type tds:GetDeviceInformation */
public:
	int soap_type() const { return 2583; } /* = unique type id SOAP_TYPE___tds__GetDeviceInformation */
	         __tds__GetDeviceInformation();
	friend SOAP_FMAC1 __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52467 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (2587)
/* Operation wrapper: */
struct __tds__SetSystemDateAndTime
{
public:
	_tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;	/* optional element of XSD type tds:SetSystemDateAndTime */
public:
	int soap_type() const { return 2587; } /* = unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
	         __tds__SetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52539 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (2591)
/* Operation wrapper: */
struct __tds__GetSystemDateAndTime
{
public:
	_tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;	/* optional element of XSD type tds:GetSystemDateAndTime */
public:
	int soap_type() const { return 2591; } /* = unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
	         __tds__GetSystemDateAndTime();
	friend SOAP_FMAC1 __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52606 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (2595)
/* Operation wrapper: */
struct __tds__SetSystemFactoryDefault
{
public:
	_tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;	/* optional element of XSD type tds:SetSystemFactoryDefault */
public:
	int soap_type() const { return 2595; } /* = unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
	         __tds__SetSystemFactoryDefault();
	friend SOAP_FMAC1 __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52679 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (2599)
/* Operation wrapper: */
struct __tds__UpgradeSystemFirmware
{
public:
	_tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;	/* optional element of XSD type tds:UpgradeSystemFirmware */
public:
	int soap_type() const { return 2599; } /* = unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
	         __tds__UpgradeSystemFirmware();
	friend SOAP_FMAC1 __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52746 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (2603)
/* Operation wrapper: */
struct __tds__SystemReboot
{
public:
	_tds__SystemReboot *tds__SystemReboot;	/* optional element of XSD type tds:SystemReboot */
public:
	int soap_type() const { return 2603; } /* = unique type id SOAP_TYPE___tds__SystemReboot */
	         __tds__SystemReboot();
	friend SOAP_FMAC1 __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52821 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (2607)
/* Operation wrapper: */
struct __tds__RestoreSystem
{
public:
	_tds__RestoreSystem *tds__RestoreSystem;	/* optional element of XSD type tds:RestoreSystem */
public:
	int soap_type() const { return 2607; } /* = unique type id SOAP_TYPE___tds__RestoreSystem */
	         __tds__RestoreSystem();
	friend SOAP_FMAC1 __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52895 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (2611)
/* Operation wrapper: */
struct __tds__GetSystemBackup
{
public:
	_tds__GetSystemBackup *tds__GetSystemBackup;	/* optional element of XSD type tds:GetSystemBackup */
public:
	int soap_type() const { return 2611; } /* = unique type id SOAP_TYPE___tds__GetSystemBackup */
	         __tds__GetSystemBackup();
	friend SOAP_FMAC1 __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:52963 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (2615)
/* Operation wrapper: */
struct __tds__GetSystemLog
{
public:
	_tds__GetSystemLog *tds__GetSystemLog;	/* optional element of XSD type tds:GetSystemLog */
public:
	int soap_type() const { return 2615; } /* = unique type id SOAP_TYPE___tds__GetSystemLog */
	         __tds__GetSystemLog();
	friend SOAP_FMAC1 __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53030 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (2619)
/* Operation wrapper: */
struct __tds__GetSystemSupportInformation
{
public:
	_tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;	/* optional element of XSD type tds:GetSystemSupportInformation */
public:
	int soap_type() const { return 2619; } /* = unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
	         __tds__GetSystemSupportInformation();
	friend SOAP_FMAC1 __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53101 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (2623)
/* Operation wrapper: */
struct __tds__GetScopes
{
public:
	_tds__GetScopes *tds__GetScopes;	/* optional element of XSD type tds:GetScopes */
public:
	int soap_type() const { return 2623; } /* = unique type id SOAP_TYPE___tds__GetScopes */
	         __tds__GetScopes();
	friend SOAP_FMAC1 __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53176 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (2627)
/* Operation wrapper: */
struct __tds__SetScopes
{
public:
	_tds__SetScopes *tds__SetScopes;	/* optional element of XSD type tds:SetScopes */
public:
	int soap_type() const { return 2627; } /* = unique type id SOAP_TYPE___tds__SetScopes */
	         __tds__SetScopes();
	friend SOAP_FMAC1 __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53247 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (2631)
/* Operation wrapper: */
struct __tds__AddScopes
{
public:
	_tds__AddScopes *tds__AddScopes;	/* optional element of XSD type tds:AddScopes */
public:
	int soap_type() const { return 2631; } /* = unique type id SOAP_TYPE___tds__AddScopes */
	         __tds__AddScopes();
	friend SOAP_FMAC1 __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53320 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (2635)
/* Operation wrapper: */
struct __tds__RemoveScopes
{
public:
	_tds__RemoveScopes *tds__RemoveScopes;	/* optional element of XSD type tds:RemoveScopes */
public:
	int soap_type() const { return 2635; } /* = unique type id SOAP_TYPE___tds__RemoveScopes */
	         __tds__RemoveScopes();
	friend SOAP_FMAC1 __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53391 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (2639)
/* Operation wrapper: */
struct __tds__GetDiscoveryMode
{
public:
	_tds__GetDiscoveryMode *tds__GetDiscoveryMode;	/* optional element of XSD type tds:GetDiscoveryMode */
public:
	int soap_type() const { return 2639; } /* = unique type id SOAP_TYPE___tds__GetDiscoveryMode */
	         __tds__GetDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53463 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (2643)
/* Operation wrapper: */
struct __tds__SetDiscoveryMode
{
public:
	_tds__SetDiscoveryMode *tds__SetDiscoveryMode;	/* optional element of XSD type tds:SetDiscoveryMode */
public:
	int soap_type() const { return 2643; } /* = unique type id SOAP_TYPE___tds__SetDiscoveryMode */
	         __tds__SetDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53536 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (2647)
/* Operation wrapper: */
struct __tds__GetRemoteDiscoveryMode
{
public:
	_tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;	/* optional element of XSD type tds:GetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2647; } /* = unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
	         __tds__GetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53609 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (2651)
/* Operation wrapper: */
struct __tds__SetRemoteDiscoveryMode
{
public:
	_tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;	/* optional element of XSD type tds:SetRemoteDiscoveryMode */
public:
	int soap_type() const { return 2651; } /* = unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
	         __tds__SetRemoteDiscoveryMode();
	friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53680 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (2655)
/* Operation wrapper: */
struct __tds__GetDPAddresses
{
public:
	_tds__GetDPAddresses *tds__GetDPAddresses;	/* optional element of XSD type tds:GetDPAddresses */
public:
	int soap_type() const { return 2655; } /* = unique type id SOAP_TYPE___tds__GetDPAddresses */
	         __tds__GetDPAddresses();
	friend SOAP_FMAC1 __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53753 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (2659)
/* Operation wrapper: */
struct __tds__GetEndpointReference
{
public:
	_tds__GetEndpointReference *tds__GetEndpointReference;	/* optional element of XSD type tds:GetEndpointReference */
public:
	int soap_type() const { return 2659; } /* = unique type id SOAP_TYPE___tds__GetEndpointReference */
	         __tds__GetEndpointReference();
	friend SOAP_FMAC1 __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53824 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (2663)
/* Operation wrapper: */
struct __tds__GetRemoteUser
{
public:
	_tds__GetRemoteUser *tds__GetRemoteUser;	/* optional element of XSD type tds:GetRemoteUser */
public:
	int soap_type() const { return 2663; } /* = unique type id SOAP_TYPE___tds__GetRemoteUser */
	         __tds__GetRemoteUser();
	friend SOAP_FMAC1 __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53894 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (2667)
/* Operation wrapper: */
struct __tds__SetRemoteUser
{
public:
	_tds__SetRemoteUser *tds__SetRemoteUser;	/* optional element of XSD type tds:SetRemoteUser */
public:
	int soap_type() const { return 2667; } /* = unique type id SOAP_TYPE___tds__SetRemoteUser */
	         __tds__SetRemoteUser();
	friend SOAP_FMAC1 __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:53965 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (2671)
/* Operation wrapper: */
struct __tds__GetUsers
{
public:
	_tds__GetUsers *tds__GetUsers;	/* optional element of XSD type tds:GetUsers */
public:
	int soap_type() const { return 2671; } /* = unique type id SOAP_TYPE___tds__GetUsers */
	         __tds__GetUsers();
	friend SOAP_FMAC1 __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54038 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (2675)
/* Operation wrapper: */
struct __tds__CreateUsers
{
public:
	_tds__CreateUsers *tds__CreateUsers;	/* optional element of XSD type tds:CreateUsers */
public:
	int soap_type() const { return 2675; } /* = unique type id SOAP_TYPE___tds__CreateUsers */
	         __tds__CreateUsers();
	friend SOAP_FMAC1 __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54112 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (2679)
/* Operation wrapper: */
struct __tds__DeleteUsers
{
public:
	_tds__DeleteUsers *tds__DeleteUsers;	/* optional element of XSD type tds:DeleteUsers */
public:
	int soap_type() const { return 2679; } /* = unique type id SOAP_TYPE___tds__DeleteUsers */
	         __tds__DeleteUsers();
	friend SOAP_FMAC1 __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54184 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (2683)
/* Operation wrapper: */
struct __tds__SetUser
{
public:
	_tds__SetUser *tds__SetUser;	/* optional element of XSD type tds:SetUser */
public:
	int soap_type() const { return 2683; } /* = unique type id SOAP_TYPE___tds__SetUser */
	         __tds__SetUser();
	friend SOAP_FMAC1 __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54258 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (2687)
/* Operation wrapper: */
struct __tds__GetWsdlUrl
{
public:
	_tds__GetWsdlUrl *tds__GetWsdlUrl;	/* optional element of XSD type tds:GetWsdlUrl */
public:
	int soap_type() const { return 2687; } /* = unique type id SOAP_TYPE___tds__GetWsdlUrl */
	         __tds__GetWsdlUrl();
	friend SOAP_FMAC1 __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54334 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (2691)
/* Operation wrapper: */
struct __tds__GetCapabilities
{
public:
	_tds__GetCapabilities *tds__GetCapabilities;	/* optional element of XSD type tds:GetCapabilities */
public:
	int soap_type() const { return 2691; } /* = unique type id SOAP_TYPE___tds__GetCapabilities */
	         __tds__GetCapabilities();
	friend SOAP_FMAC1 __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54406 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (2695)
/* Operation wrapper: */
struct __tds__SetDPAddresses
{
public:
	_tds__SetDPAddresses *tds__SetDPAddresses;	/* optional element of XSD type tds:SetDPAddresses */
public:
	int soap_type() const { return 2695; } /* = unique type id SOAP_TYPE___tds__SetDPAddresses */
	         __tds__SetDPAddresses();
	friend SOAP_FMAC1 __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54476 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (2699)
/* Operation wrapper: */
struct __tds__GetHostname
{
public:
	_tds__GetHostname *tds__GetHostname;	/* optional element of XSD type tds:GetHostname */
public:
	int soap_type() const { return 2699; } /* = unique type id SOAP_TYPE___tds__GetHostname */
	         __tds__GetHostname();
	friend SOAP_FMAC1 __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54545 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (2703)
/* Operation wrapper: */
struct __tds__SetHostname
{
public:
	_tds__SetHostname *tds__SetHostname;	/* optional element of XSD type tds:SetHostname */
public:
	int soap_type() const { return 2703; } /* = unique type id SOAP_TYPE___tds__SetHostname */
	         __tds__SetHostname();
	friend SOAP_FMAC1 __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54612 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (2707)
/* Operation wrapper: */
struct __tds__SetHostnameFromDHCP
{
public:
	_tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;	/* optional element of XSD type tds:SetHostnameFromDHCP */
public:
	int soap_type() const { return 2707; } /* = unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
	         __tds__SetHostnameFromDHCP();
	friend SOAP_FMAC1 __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54681 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (2711)
/* Operation wrapper: */
struct __tds__GetDNS
{
public:
	_tds__GetDNS *tds__GetDNS;	/* optional element of XSD type tds:GetDNS */
public:
	int soap_type() const { return 2711; } /* = unique type id SOAP_TYPE___tds__GetDNS */
	         __tds__GetDNS();
	friend SOAP_FMAC1 __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54750 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (2715)
/* Operation wrapper: */
struct __tds__SetDNS
{
public:
	_tds__SetDNS *tds__SetDNS;	/* optional element of XSD type tds:SetDNS */
public:
	int soap_type() const { return 2715; } /* = unique type id SOAP_TYPE___tds__SetDNS */
	         __tds__SetDNS();
	friend SOAP_FMAC1 __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54820 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (2719)
/* Operation wrapper: */
struct __tds__GetNTP
{
public:
	_tds__GetNTP *tds__GetNTP;	/* optional element of XSD type tds:GetNTP */
public:
	int soap_type() const { return 2719; } /* = unique type id SOAP_TYPE___tds__GetNTP */
	         __tds__GetNTP();
	friend SOAP_FMAC1 __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54890 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (2723)
/* Operation wrapper: */
struct __tds__SetNTP
{
public:
	_tds__SetNTP *tds__SetNTP;	/* optional element of XSD type tds:SetNTP */
public:
	int soap_type() const { return 2723; } /* = unique type id SOAP_TYPE___tds__SetNTP */
	         __tds__SetNTP();
	friend SOAP_FMAC1 __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:54961 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (2727)
/* Operation wrapper: */
struct __tds__GetDynamicDNS
{
public:
	_tds__GetDynamicDNS *tds__GetDynamicDNS;	/* optional element of XSD type tds:GetDynamicDNS */
public:
	int soap_type() const { return 2727; } /* = unique type id SOAP_TYPE___tds__GetDynamicDNS */
	         __tds__GetDynamicDNS();
	friend SOAP_FMAC1 __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55032 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (2731)
/* Operation wrapper: */
struct __tds__SetDynamicDNS
{
public:
	_tds__SetDynamicDNS *tds__SetDynamicDNS;	/* optional element of XSD type tds:SetDynamicDNS */
public:
	int soap_type() const { return 2731; } /* = unique type id SOAP_TYPE___tds__SetDynamicDNS */
	         __tds__SetDynamicDNS();
	friend SOAP_FMAC1 __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55103 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (2735)
/* Operation wrapper: */
struct __tds__GetNetworkInterfaces
{
public:
	_tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;	/* optional element of XSD type tds:GetNetworkInterfaces */
public:
	int soap_type() const { return 2735; } /* = unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
	         __tds__GetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55174 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (2739)
/* Operation wrapper: */
struct __tds__SetNetworkInterfaces
{
public:
	_tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;	/* optional element of XSD type tds:SetNetworkInterfaces */
public:
	int soap_type() const { return 2739; } /* = unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
	         __tds__SetNetworkInterfaces();
	friend SOAP_FMAC1 __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55244 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (2743)
/* Operation wrapper: */
struct __tds__GetNetworkProtocols
{
public:
	_tds__GetNetworkProtocols *tds__GetNetworkProtocols;	/* optional element of XSD type tds:GetNetworkProtocols */
public:
	int soap_type() const { return 2743; } /* = unique type id SOAP_TYPE___tds__GetNetworkProtocols */
	         __tds__GetNetworkProtocols();
	friend SOAP_FMAC1 __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55314 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (2747)
/* Operation wrapper: */
struct __tds__SetNetworkProtocols
{
public:
	_tds__SetNetworkProtocols *tds__SetNetworkProtocols;	/* optional element of XSD type tds:SetNetworkProtocols */
public:
	int soap_type() const { return 2747; } /* = unique type id SOAP_TYPE___tds__SetNetworkProtocols */
	         __tds__SetNetworkProtocols();
	friend SOAP_FMAC1 __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55384 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (2751)
/* Operation wrapper: */
struct __tds__GetNetworkDefaultGateway
{
public:
	_tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;	/* optional element of XSD type tds:GetNetworkDefaultGateway */
public:
	int soap_type() const { return 2751; } /* = unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
	         __tds__GetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55453 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (2755)
/* Operation wrapper: */
struct __tds__SetNetworkDefaultGateway
{
public:
	_tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;	/* optional element of XSD type tds:SetNetworkDefaultGateway */
public:
	int soap_type() const { return 2755; } /* = unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
	         __tds__SetNetworkDefaultGateway();
	friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55525 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (2759)
/* Operation wrapper: */
struct __tds__GetZeroConfiguration
{
public:
	_tds__GetZeroConfiguration *tds__GetZeroConfiguration;	/* optional element of XSD type tds:GetZeroConfiguration */
public:
	int soap_type() const { return 2759; } /* = unique type id SOAP_TYPE___tds__GetZeroConfiguration */
	         __tds__GetZeroConfiguration();
	friend SOAP_FMAC1 __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55593 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (2763)
/* Operation wrapper: */
struct __tds__SetZeroConfiguration
{
public:
	_tds__SetZeroConfiguration *tds__SetZeroConfiguration;	/* optional element of XSD type tds:SetZeroConfiguration */
public:
	int soap_type() const { return 2763; } /* = unique type id SOAP_TYPE___tds__SetZeroConfiguration */
	         __tds__SetZeroConfiguration();
	friend SOAP_FMAC1 __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55664 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (2767)
/* Operation wrapper: */
struct __tds__GetIPAddressFilter
{
public:
	_tds__GetIPAddressFilter *tds__GetIPAddressFilter;	/* optional element of XSD type tds:GetIPAddressFilter */
public:
	int soap_type() const { return 2767; } /* = unique type id SOAP_TYPE___tds__GetIPAddressFilter */
	         __tds__GetIPAddressFilter();
	friend SOAP_FMAC1 __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55737 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (2771)
/* Operation wrapper: */
struct __tds__SetIPAddressFilter
{
public:
	_tds__SetIPAddressFilter *tds__SetIPAddressFilter;	/* optional element of XSD type tds:SetIPAddressFilter */
public:
	int soap_type() const { return 2771; } /* = unique type id SOAP_TYPE___tds__SetIPAddressFilter */
	         __tds__SetIPAddressFilter();
	friend SOAP_FMAC1 __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55809 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (2775)
/* Operation wrapper: */
struct __tds__AddIPAddressFilter
{
public:
	_tds__AddIPAddressFilter *tds__AddIPAddressFilter;	/* optional element of XSD type tds:AddIPAddressFilter */
public:
	int soap_type() const { return 2775; } /* = unique type id SOAP_TYPE___tds__AddIPAddressFilter */
	         __tds__AddIPAddressFilter();
	friend SOAP_FMAC1 __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55881 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (2779)
/* Operation wrapper: */
struct __tds__RemoveIPAddressFilter
{
public:
	_tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;	/* optional element of XSD type tds:RemoveIPAddressFilter */
public:
	int soap_type() const { return 2779; } /* = unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
	         __tds__RemoveIPAddressFilter();
	friend SOAP_FMAC1 __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:55962 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (2783)
/* Operation wrapper: */
struct __tds__GetAccessPolicy
{
public:
	_tds__GetAccessPolicy *tds__GetAccessPolicy;	/* optional element of XSD type tds:GetAccessPolicy */
public:
	int soap_type() const { return 2783; } /* = unique type id SOAP_TYPE___tds__GetAccessPolicy */
	         __tds__GetAccessPolicy();
	friend SOAP_FMAC1 __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56034 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (2787)
/* Operation wrapper: */
struct __tds__SetAccessPolicy
{
public:
	_tds__SetAccessPolicy *tds__SetAccessPolicy;	/* optional element of XSD type tds:SetAccessPolicy */
public:
	int soap_type() const { return 2787; } /* = unique type id SOAP_TYPE___tds__SetAccessPolicy */
	         __tds__SetAccessPolicy();
	friend SOAP_FMAC1 __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56105 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (2791)
/* Operation wrapper: */
struct __tds__CreateCertificate
{
public:
	_tds__CreateCertificate *tds__CreateCertificate;	/* optional element of XSD type tds:CreateCertificate */
public:
	int soap_type() const { return 2791; } /* = unique type id SOAP_TYPE___tds__CreateCertificate */
	         __tds__CreateCertificate();
	friend SOAP_FMAC1 __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56184 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (2795)
/* Operation wrapper: */
struct __tds__GetCertificates
{
public:
	_tds__GetCertificates *tds__GetCertificates;	/* optional element of XSD type tds:GetCertificates */
public:
	int soap_type() const { return 2795; } /* = unique type id SOAP_TYPE___tds__GetCertificates */
	         __tds__GetCertificates();
	friend SOAP_FMAC1 __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56254 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (2799)
/* Operation wrapper: */
struct __tds__GetCertificatesStatus
{
public:
	_tds__GetCertificatesStatus *tds__GetCertificatesStatus;	/* optional element of XSD type tds:GetCertificatesStatus */
public:
	int soap_type() const { return 2799; } /* = unique type id SOAP_TYPE___tds__GetCertificatesStatus */
	         __tds__GetCertificatesStatus();
	friend SOAP_FMAC1 __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56326 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (2803)
/* Operation wrapper: */
struct __tds__SetCertificatesStatus
{
public:
	_tds__SetCertificatesStatus *tds__SetCertificatesStatus;	/* optional element of XSD type tds:SetCertificatesStatus */
public:
	int soap_type() const { return 2803; } /* = unique type id SOAP_TYPE___tds__SetCertificatesStatus */
	         __tds__SetCertificatesStatus();
	friend SOAP_FMAC1 __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56401 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (2807)
/* Operation wrapper: */
struct __tds__DeleteCertificates
{
public:
	_tds__DeleteCertificates *tds__DeleteCertificates;	/* optional element of XSD type tds:DeleteCertificates */
public:
	int soap_type() const { return 2807; } /* = unique type id SOAP_TYPE___tds__DeleteCertificates */
	         __tds__DeleteCertificates();
	friend SOAP_FMAC1 __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56478 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (2811)
/* Operation wrapper: */
struct __tds__GetPkcs10Request
{
public:
	_tds__GetPkcs10Request *tds__GetPkcs10Request;	/* optional element of XSD type tds:GetPkcs10Request */
public:
	int soap_type() const { return 2811; } /* = unique type id SOAP_TYPE___tds__GetPkcs10Request */
	         __tds__GetPkcs10Request();
	friend SOAP_FMAC1 __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56559 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (2815)
/* Operation wrapper: */
struct __tds__LoadCertificates
{
public:
	_tds__LoadCertificates *tds__LoadCertificates;	/* optional element of XSD type tds:LoadCertificates */
public:
	int soap_type() const { return 2815; } /* = unique type id SOAP_TYPE___tds__LoadCertificates */
	         __tds__LoadCertificates();
	friend SOAP_FMAC1 __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56629 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (2819)
/* Operation wrapper: */
struct __tds__GetClientCertificateMode
{
public:
	_tds__GetClientCertificateMode *tds__GetClientCertificateMode;	/* optional element of XSD type tds:GetClientCertificateMode */
public:
	int soap_type() const { return 2819; } /* = unique type id SOAP_TYPE___tds__GetClientCertificateMode */
	         __tds__GetClientCertificateMode();
	friend SOAP_FMAC1 __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56699 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (2823)
/* Operation wrapper: */
struct __tds__SetClientCertificateMode
{
public:
	_tds__SetClientCertificateMode *tds__SetClientCertificateMode;	/* optional element of XSD type tds:SetClientCertificateMode */
public:
	int soap_type() const { return 2823; } /* = unique type id SOAP_TYPE___tds__SetClientCertificateMode */
	         __tds__SetClientCertificateMode();
	friend SOAP_FMAC1 __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56766 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (2827)
/* Operation wrapper: */
struct __tds__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 2827; } /* = unique type id SOAP_TYPE___tds__GetRelayOutputs */
	         __tds__GetRelayOutputs();
	friend SOAP_FMAC1 __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56834 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (2831)
/* Operation wrapper: */
struct __tds__SetRelayOutputSettings
{
public:
	_tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;	/* optional element of XSD type tds:SetRelayOutputSettings */
public:
	int soap_type() const { return 2831; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
	         __tds__SetRelayOutputSettings();
	friend SOAP_FMAC1 __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56902 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (2835)
/* Operation wrapper: */
struct __tds__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 2835; } /* = unique type id SOAP_TYPE___tds__SetRelayOutputState */
	         __tds__SetRelayOutputState();
	friend SOAP_FMAC1 __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:56972 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (2839)
/* Operation wrapper: */
struct __tds__SendAuxiliaryCommand
{
public:
	_tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;	/* optional element of XSD type tds:SendAuxiliaryCommand */
public:
	int soap_type() const { return 2839; } /* = unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
	         __tds__SendAuxiliaryCommand();
	friend SOAP_FMAC1 __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57050 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (2843)
/* Operation wrapper: */
struct __tds__GetCACertificates
{
public:
	_tds__GetCACertificates *tds__GetCACertificates;	/* optional element of XSD type tds:GetCACertificates */
public:
	int soap_type() const { return 2843; } /* = unique type id SOAP_TYPE___tds__GetCACertificates */
	         __tds__GetCACertificates();
	friend SOAP_FMAC1 __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57127 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (2847)
/* Operation wrapper: */
struct __tds__LoadCertificateWithPrivateKey
{
public:
	_tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;	/* optional element of XSD type tds:LoadCertificateWithPrivateKey */
public:
	int soap_type() const { return 2847; } /* = unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
	         __tds__LoadCertificateWithPrivateKey();
	friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57202 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (2851)
/* Operation wrapper: */
struct __tds__GetCertificateInformation
{
public:
	_tds__GetCertificateInformation *tds__GetCertificateInformation;	/* optional element of XSD type tds:GetCertificateInformation */
public:
	int soap_type() const { return 2851; } /* = unique type id SOAP_TYPE___tds__GetCertificateInformation */
	         __tds__GetCertificateInformation();
	friend SOAP_FMAC1 __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57274 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (2855)
/* Operation wrapper: */
struct __tds__LoadCACertificates
{
public:
	_tds__LoadCACertificates *tds__LoadCACertificates;	/* optional element of XSD type tds:LoadCACertificates */
public:
	int soap_type() const { return 2855; } /* = unique type id SOAP_TYPE___tds__LoadCACertificates */
	         __tds__LoadCACertificates();
	friend SOAP_FMAC1 __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57349 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (2859)
/* Operation wrapper: */
struct __tds__CreateDot1XConfiguration
{
public:
	_tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;	/* optional element of XSD type tds:CreateDot1XConfiguration */
public:
	int soap_type() const { return 2859; } /* = unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
	         __tds__CreateDot1XConfiguration();
	friend SOAP_FMAC1 __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57420 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (2863)
/* Operation wrapper: */
struct __tds__SetDot1XConfiguration
{
public:
	_tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;	/* optional element of XSD type tds:SetDot1XConfiguration */
public:
	int soap_type() const { return 2863; } /* = unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
	         __tds__SetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57489 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (2867)
/* Operation wrapper: */
struct __tds__GetDot1XConfiguration
{
public:
	_tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;	/* optional element of XSD type tds:GetDot1XConfiguration */
public:
	int soap_type() const { return 2867; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
	         __tds__GetDot1XConfiguration();
	friend SOAP_FMAC1 __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57561 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (2871)
/* Operation wrapper: */
struct __tds__GetDot1XConfigurations
{
public:
	_tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;	/* optional element of XSD type tds:GetDot1XConfigurations */
public:
	int soap_type() const { return 2871; } /* = unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
	         __tds__GetDot1XConfigurations();
	friend SOAP_FMAC1 __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57633 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (2875)
/* Operation wrapper: */
struct __tds__DeleteDot1XConfiguration
{
public:
	_tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;	/* optional element of XSD type tds:DeleteDot1XConfiguration */
public:
	int soap_type() const { return 2875; } /* = unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
	         __tds__DeleteDot1XConfiguration();
	friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57701 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (2879)
/* Operation wrapper: */
struct __tds__GetDot11Capabilities
{
public:
	_tds__GetDot11Capabilities *tds__GetDot11Capabilities;	/* optional element of XSD type tds:GetDot11Capabilities */
public:
	int soap_type() const { return 2879; } /* = unique type id SOAP_TYPE___tds__GetDot11Capabilities */
	         __tds__GetDot11Capabilities();
	friend SOAP_FMAC1 __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57770 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (2883)
/* Operation wrapper: */
struct __tds__GetDot11Status
{
public:
	_tds__GetDot11Status *tds__GetDot11Status;	/* optional element of XSD type tds:GetDot11Status */
public:
	int soap_type() const { return 2883; } /* = unique type id SOAP_TYPE___tds__GetDot11Status */
	         __tds__GetDot11Status();
	friend SOAP_FMAC1 __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57839 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (2887)
/* Operation wrapper: */
struct __tds__ScanAvailableDot11Networks
{
public:
	_tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;	/* optional element of XSD type tds:ScanAvailableDot11Networks */
public:
	int soap_type() const { return 2887; } /* = unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
	         __tds__ScanAvailableDot11Networks();
	friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57908 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (2891)
/* Operation wrapper: */
struct __tds__GetSystemUris
{
public:
	_tds__GetSystemUris *tds__GetSystemUris;	/* optional element of XSD type tds:GetSystemUris */
public:
	int soap_type() const { return 2891; } /* = unique type id SOAP_TYPE___tds__GetSystemUris */
	         __tds__GetSystemUris();
	friend SOAP_FMAC1 __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:57985 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (2895)
/* Operation wrapper: */
struct __tds__StartFirmwareUpgrade
{
public:
	_tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;	/* optional element of XSD type tds:StartFirmwareUpgrade */
public:
	int soap_type() const { return 2895; } /* = unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
	         __tds__StartFirmwareUpgrade();
	friend SOAP_FMAC1 __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58062 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (2899)
/* Operation wrapper: */
struct __tds__StartSystemRestore
{
public:
	_tds__StartSystemRestore *tds__StartSystemRestore;	/* optional element of XSD type tds:StartSystemRestore */
public:
	int soap_type() const { return 2899; } /* = unique type id SOAP_TYPE___tds__StartSystemRestore */
	         __tds__StartSystemRestore();
	friend SOAP_FMAC1 __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58157 */
#ifndef SOAP_TYPE___tev__PullMessages
#define SOAP_TYPE___tev__PullMessages (2903)
/* Operation wrapper: */
struct __tev__PullMessages
{
public:
	_tev__PullMessages *tev__PullMessages;	/* optional element of XSD type tev:PullMessages */
public:
	int soap_type() const { return 2903; } /* = unique type id SOAP_TYPE___tev__PullMessages */
	         __tev__PullMessages();
	friend SOAP_FMAC1 __tev__PullMessages * SOAP_FMAC2 soap_instantiate___tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58234 */
#ifndef SOAP_TYPE___tev__Seek
#define SOAP_TYPE___tev__Seek (2907)
/* Operation wrapper: */
struct __tev__Seek
{
public:
	_tev__Seek *tev__Seek;	/* optional element of XSD type tev:Seek */
public:
	int soap_type() const { return 2907; } /* = unique type id SOAP_TYPE___tev__Seek */
	         __tev__Seek();
	friend SOAP_FMAC1 __tev__Seek * SOAP_FMAC2 soap_instantiate___tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58316 */
#ifndef SOAP_TYPE___tev__SetSynchronizationPoint
#define SOAP_TYPE___tev__SetSynchronizationPoint (2911)
/* Operation wrapper: */
struct __tev__SetSynchronizationPoint
{
public:
	_tev__SetSynchronizationPoint *tev__SetSynchronizationPoint;	/* optional element of XSD type tev:SetSynchronizationPoint */
public:
	int soap_type() const { return 2911; } /* = unique type id SOAP_TYPE___tev__SetSynchronizationPoint */
	         __tev__SetSynchronizationPoint();
	friend SOAP_FMAC1 __tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58384 */
#ifndef SOAP_TYPE___tev__GetServiceCapabilities
#define SOAP_TYPE___tev__GetServiceCapabilities (2915)
/* Operation wrapper: */
struct __tev__GetServiceCapabilities
{
public:
	_tev__GetServiceCapabilities *tev__GetServiceCapabilities;	/* optional element of XSD type tev:GetServiceCapabilities */
public:
	int soap_type() const { return 2915; } /* = unique type id SOAP_TYPE___tev__GetServiceCapabilities */
	         __tev__GetServiceCapabilities();
	friend SOAP_FMAC1 __tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58490 */
#ifndef SOAP_TYPE___tev__CreatePullPointSubscription
#define SOAP_TYPE___tev__CreatePullPointSubscription (2919)
/* Operation wrapper: */
struct __tev__CreatePullPointSubscription
{
public:
	_tev__CreatePullPointSubscription *tev__CreatePullPointSubscription;	/* optional element of XSD type tev:CreatePullPointSubscription */
public:
	int soap_type() const { return 2919; } /* = unique type id SOAP_TYPE___tev__CreatePullPointSubscription */
	         __tev__CreatePullPointSubscription();
	friend SOAP_FMAC1 __tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate___tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58564 */
#ifndef SOAP_TYPE___tev__GetEventProperties
#define SOAP_TYPE___tev__GetEventProperties (2923)
/* Operation wrapper: */
struct __tev__GetEventProperties
{
public:
	_tev__GetEventProperties *tev__GetEventProperties;	/* optional element of XSD type tev:GetEventProperties */
public:
	int soap_type() const { return 2923; } /* = unique type id SOAP_TYPE___tev__GetEventProperties */
	         __tev__GetEventProperties();
	friend SOAP_FMAC1 __tev__GetEventProperties * SOAP_FMAC2 soap_instantiate___tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58636 */
#ifndef SOAP_TYPE___tev__Renew
#define SOAP_TYPE___tev__Renew (2927)
/* Operation wrapper: */
struct __tev__Renew
{
public:
	_wsnt__Renew *wsnt__Renew;	/* optional element of XSD type wsnt:Renew */
public:
	int soap_type() const { return 2927; } /* = unique type id SOAP_TYPE___tev__Renew */
	         __tev__Renew();
	friend SOAP_FMAC1 __tev__Renew * SOAP_FMAC2 soap_instantiate___tev__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58708 */
#ifndef SOAP_TYPE___tev__Unsubscribe
#define SOAP_TYPE___tev__Unsubscribe (2931)
/* Operation wrapper: */
struct __tev__Unsubscribe
{
public:
	_wsnt__Unsubscribe *wsnt__Unsubscribe;	/* optional element of XSD type wsnt:Unsubscribe */
public:
	int soap_type() const { return 2931; } /* = unique type id SOAP_TYPE___tev__Unsubscribe */
	         __tev__Unsubscribe();
	friend SOAP_FMAC1 __tev__Unsubscribe * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58810 */
#ifndef SOAP_TYPE___tev__Subscribe
#define SOAP_TYPE___tev__Subscribe (2935)
/* Operation wrapper: */
struct __tev__Subscribe
{
public:
	_wsnt__Subscribe *wsnt__Subscribe;	/* optional element of XSD type wsnt:Subscribe */
public:
	int soap_type() const { return 2935; } /* = unique type id SOAP_TYPE___tev__Subscribe */
	         __tev__Subscribe();
	friend SOAP_FMAC1 __tev__Subscribe * SOAP_FMAC2 soap_instantiate___tev__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58894 */
#ifndef SOAP_TYPE___tev__GetCurrentMessage
#define SOAP_TYPE___tev__GetCurrentMessage (2939)
/* Operation wrapper: */
struct __tev__GetCurrentMessage
{
public:
	_wsnt__GetCurrentMessage *wsnt__GetCurrentMessage;	/* optional element of XSD type wsnt:GetCurrentMessage */
public:
	int soap_type() const { return 2939; } /* = unique type id SOAP_TYPE___tev__GetCurrentMessage */
	         __tev__GetCurrentMessage();
	friend SOAP_FMAC1 __tev__GetCurrentMessage * SOAP_FMAC2 soap_instantiate___tev__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:58956 */
#ifndef SOAP_TYPE___tev__Notify
#define SOAP_TYPE___tev__Notify (2942)
/* Operation wrapper: */
struct __tev__Notify
{
public:
	_wsnt__Notify *wsnt__Notify;	/* optional element of XSD type wsnt:Notify */
public:
	int soap_type() const { return 2942; } /* = unique type id SOAP_TYPE___tev__Notify */
	         __tev__Notify();
	friend SOAP_FMAC1 __tev__Notify * SOAP_FMAC2 soap_instantiate___tev__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59028 */
#ifndef SOAP_TYPE___tev__GetMessages
#define SOAP_TYPE___tev__GetMessages (2946)
/* Operation wrapper: */
struct __tev__GetMessages
{
public:
	_wsnt__GetMessages *wsnt__GetMessages;	/* optional element of XSD type wsnt:GetMessages */
public:
	int soap_type() const { return 2946; } /* = unique type id SOAP_TYPE___tev__GetMessages */
	         __tev__GetMessages();
	friend SOAP_FMAC1 __tev__GetMessages * SOAP_FMAC2 soap_instantiate___tev__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59100 */
#ifndef SOAP_TYPE___tev__DestroyPullPoint
#define SOAP_TYPE___tev__DestroyPullPoint (2950)
/* Operation wrapper: */
struct __tev__DestroyPullPoint
{
public:
	_wsnt__DestroyPullPoint *wsnt__DestroyPullPoint;	/* optional element of XSD type wsnt:DestroyPullPoint */
public:
	int soap_type() const { return 2950; } /* = unique type id SOAP_TYPE___tev__DestroyPullPoint */
	         __tev__DestroyPullPoint();
	friend SOAP_FMAC1 __tev__DestroyPullPoint * SOAP_FMAC2 soap_instantiate___tev__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59162 */
#ifndef SOAP_TYPE___tev__Notify_
#define SOAP_TYPE___tev__Notify_ (2952)
/* Operation wrapper: */
struct __tev__Notify_
{
public:
	_wsnt__Notify *wsnt__Notify;	/* optional element of XSD type wsnt:Notify */
public:
	int soap_type() const { return 2952; } /* = unique type id SOAP_TYPE___tev__Notify_ */
	         __tev__Notify_();
	friend SOAP_FMAC1 __tev__Notify_ * SOAP_FMAC2 soap_instantiate___tev__Notify_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59231 */
#ifndef SOAP_TYPE___tev__CreatePullPoint
#define SOAP_TYPE___tev__CreatePullPoint (2956)
/* Operation wrapper: */
struct __tev__CreatePullPoint
{
public:
	_wsnt__CreatePullPoint *wsnt__CreatePullPoint;	/* optional element of XSD type wsnt:CreatePullPoint */
public:
	int soap_type() const { return 2956; } /* = unique type id SOAP_TYPE___tev__CreatePullPoint */
	         __tev__CreatePullPoint();
	friend SOAP_FMAC1 __tev__CreatePullPoint * SOAP_FMAC2 soap_instantiate___tev__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59303 */
#ifndef SOAP_TYPE___tev__Renew_
#define SOAP_TYPE___tev__Renew_ (2958)
/* Operation wrapper: */
struct __tev__Renew_
{
public:
	_wsnt__Renew *wsnt__Renew;	/* optional element of XSD type wsnt:Renew */
public:
	int soap_type() const { return 2958; } /* = unique type id SOAP_TYPE___tev__Renew_ */
	         __tev__Renew_();
	friend SOAP_FMAC1 __tev__Renew_ * SOAP_FMAC2 soap_instantiate___tev__Renew_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59375 */
#ifndef SOAP_TYPE___tev__Unsubscribe_
#define SOAP_TYPE___tev__Unsubscribe_ (2960)
/* Operation wrapper: */
struct __tev__Unsubscribe_
{
public:
	_wsnt__Unsubscribe *wsnt__Unsubscribe;	/* optional element of XSD type wsnt:Unsubscribe */
public:
	int soap_type() const { return 2960; } /* = unique type id SOAP_TYPE___tev__Unsubscribe_ */
	         __tev__Unsubscribe_();
	friend SOAP_FMAC1 __tev__Unsubscribe_ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59447 */
#ifndef SOAP_TYPE___tev__PauseSubscription
#define SOAP_TYPE___tev__PauseSubscription (2964)
/* Operation wrapper: */
struct __tev__PauseSubscription
{
public:
	_wsnt__PauseSubscription *wsnt__PauseSubscription;	/* optional element of XSD type wsnt:PauseSubscription */
public:
	int soap_type() const { return 2964; } /* = unique type id SOAP_TYPE___tev__PauseSubscription */
	         __tev__PauseSubscription();
	friend SOAP_FMAC1 __tev__PauseSubscription * SOAP_FMAC2 soap_instantiate___tev__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59519 */
#ifndef SOAP_TYPE___tev__ResumeSubscription
#define SOAP_TYPE___tev__ResumeSubscription (2968)
/* Operation wrapper: */
struct __tev__ResumeSubscription
{
public:
	_wsnt__ResumeSubscription *wsnt__ResumeSubscription;	/* optional element of XSD type wsnt:ResumeSubscription */
public:
	int soap_type() const { return 2968; } /* = unique type id SOAP_TYPE___tev__ResumeSubscription */
	         __tev__ResumeSubscription();
	friend SOAP_FMAC1 __tev__ResumeSubscription * SOAP_FMAC2 soap_instantiate___tev__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59605 */
#ifndef SOAP_TYPE___timg__GetServiceCapabilities
#define SOAP_TYPE___timg__GetServiceCapabilities (2972)
/* Operation wrapper: */
struct __timg__GetServiceCapabilities
{
public:
	_timg__GetServiceCapabilities *timg__GetServiceCapabilities;	/* optional element of XSD type timg:GetServiceCapabilities */
public:
	int soap_type() const { return 2972; } /* = unique type id SOAP_TYPE___timg__GetServiceCapabilities */
	         __timg__GetServiceCapabilities();
	friend SOAP_FMAC1 __timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59672 */
#ifndef SOAP_TYPE___timg__GetImagingSettings
#define SOAP_TYPE___timg__GetImagingSettings (2976)
/* Operation wrapper: */
struct __timg__GetImagingSettings
{
public:
	_timg__GetImagingSettings *timg__GetImagingSettings;	/* optional element of XSD type timg:GetImagingSettings */
public:
	int soap_type() const { return 2976; } /* = unique type id SOAP_TYPE___timg__GetImagingSettings */
	         __timg__GetImagingSettings();
	friend SOAP_FMAC1 __timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59739 */
#ifndef SOAP_TYPE___timg__SetImagingSettings
#define SOAP_TYPE___timg__SetImagingSettings (2980)
/* Operation wrapper: */
struct __timg__SetImagingSettings
{
public:
	_timg__SetImagingSettings *timg__SetImagingSettings;	/* optional element of XSD type timg:SetImagingSettings */
public:
	int soap_type() const { return 2980; } /* = unique type id SOAP_TYPE___timg__SetImagingSettings */
	         __timg__SetImagingSettings();
	friend SOAP_FMAC1 __timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59812 */
#ifndef SOAP_TYPE___timg__GetOptions
#define SOAP_TYPE___timg__GetOptions (2984)
/* Operation wrapper: */
struct __timg__GetOptions
{
public:
	_timg__GetOptions *timg__GetOptions;	/* optional element of XSD type timg:GetOptions */
public:
	int soap_type() const { return 2984; } /* = unique type id SOAP_TYPE___timg__GetOptions */
	         __timg__GetOptions();
	friend SOAP_FMAC1 __timg__GetOptions * SOAP_FMAC2 soap_instantiate___timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59890 */
#ifndef SOAP_TYPE___timg__Move
#define SOAP_TYPE___timg__Move (2988)
/* Operation wrapper: */
struct __timg__Move
{
public:
	_timg__Move *timg__Move;	/* optional element of XSD type timg:Move */
public:
	int soap_type() const { return 2988; } /* = unique type id SOAP_TYPE___timg__Move */
	         __timg__Move();
	friend SOAP_FMAC1 __timg__Move * SOAP_FMAC2 soap_instantiate___timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:59959 */
#ifndef SOAP_TYPE___timg__Stop
#define SOAP_TYPE___timg__Stop (2992)
/* Operation wrapper: */
struct __timg__Stop
{
public:
	_timg__Stop *timg__Stop;	/* optional element of XSD type timg:Stop */
public:
	int soap_type() const { return 2992; } /* = unique type id SOAP_TYPE___timg__Stop */
	         __timg__Stop();
	friend SOAP_FMAC1 __timg__Stop * SOAP_FMAC2 soap_instantiate___timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60028 */
#ifndef SOAP_TYPE___timg__GetStatus
#define SOAP_TYPE___timg__GetStatus (2996)
/* Operation wrapper: */
struct __timg__GetStatus
{
public:
	_timg__GetStatus *timg__GetStatus;	/* optional element of XSD type timg:GetStatus */
public:
	int soap_type() const { return 2996; } /* = unique type id SOAP_TYPE___timg__GetStatus */
	         __timg__GetStatus();
	friend SOAP_FMAC1 __timg__GetStatus * SOAP_FMAC2 soap_instantiate___timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60095 */
#ifndef SOAP_TYPE___timg__GetMoveOptions
#define SOAP_TYPE___timg__GetMoveOptions (3000)
/* Operation wrapper: */
struct __timg__GetMoveOptions
{
public:
	_timg__GetMoveOptions *timg__GetMoveOptions;	/* optional element of XSD type timg:GetMoveOptions */
public:
	int soap_type() const { return 3000; } /* = unique type id SOAP_TYPE___timg__GetMoveOptions */
	         __timg__GetMoveOptions();
	friend SOAP_FMAC1 __timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate___timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60181 */
#ifndef SOAP_TYPE___tls__GetServiceCapabilities
#define SOAP_TYPE___tls__GetServiceCapabilities (3004)
/* Operation wrapper: */
struct __tls__GetServiceCapabilities
{
public:
	_tls__GetServiceCapabilities *tls__GetServiceCapabilities;	/* optional element of XSD type tls:GetServiceCapabilities */
public:
	int soap_type() const { return 3004; } /* = unique type id SOAP_TYPE___tls__GetServiceCapabilities */
	         __tls__GetServiceCapabilities();
	friend SOAP_FMAC1 __tls__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tls__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60252 */
#ifndef SOAP_TYPE___tls__GetLayout
#define SOAP_TYPE___tls__GetLayout (3008)
/* Operation wrapper: */
struct __tls__GetLayout
{
public:
	_tls__GetLayout *tls__GetLayout;	/* optional element of XSD type tls:GetLayout */
public:
	int soap_type() const { return 3008; } /* = unique type id SOAP_TYPE___tls__GetLayout */
	         __tls__GetLayout();
	friend SOAP_FMAC1 __tls__GetLayout * SOAP_FMAC2 soap_instantiate___tls__GetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60324 */
#ifndef SOAP_TYPE___tls__SetLayout
#define SOAP_TYPE___tls__SetLayout (3012)
/* Operation wrapper: */
struct __tls__SetLayout
{
public:
	_tls__SetLayout *tls__SetLayout;	/* optional element of XSD type tls:SetLayout */
public:
	int soap_type() const { return 3012; } /* = unique type id SOAP_TYPE___tls__SetLayout */
	         __tls__SetLayout();
	friend SOAP_FMAC1 __tls__SetLayout * SOAP_FMAC2 soap_instantiate___tls__SetLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60395 */
#ifndef SOAP_TYPE___tls__GetDisplayOptions
#define SOAP_TYPE___tls__GetDisplayOptions (3016)
/* Operation wrapper: */
struct __tls__GetDisplayOptions
{
public:
	_tls__GetDisplayOptions *tls__GetDisplayOptions;	/* optional element of XSD type tls:GetDisplayOptions */
public:
	int soap_type() const { return 3016; } /* = unique type id SOAP_TYPE___tls__GetDisplayOptions */
	         __tls__GetDisplayOptions();
	friend SOAP_FMAC1 __tls__GetDisplayOptions * SOAP_FMAC2 soap_instantiate___tls__GetDisplayOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60470 */
#ifndef SOAP_TYPE___tls__GetPaneConfigurations
#define SOAP_TYPE___tls__GetPaneConfigurations (3020)
/* Operation wrapper: */
struct __tls__GetPaneConfigurations
{
public:
	_tls__GetPaneConfigurations *tls__GetPaneConfigurations;	/* optional element of XSD type tls:GetPaneConfigurations */
public:
	int soap_type() const { return 3020; } /* = unique type id SOAP_TYPE___tls__GetPaneConfigurations */
	         __tls__GetPaneConfigurations();
	friend SOAP_FMAC1 __tls__GetPaneConfigurations * SOAP_FMAC2 soap_instantiate___tls__GetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60537 */
#ifndef SOAP_TYPE___tls__GetPaneConfiguration
#define SOAP_TYPE___tls__GetPaneConfiguration (3024)
/* Operation wrapper: */
struct __tls__GetPaneConfiguration
{
public:
	_tls__GetPaneConfiguration *tls__GetPaneConfiguration;	/* optional element of XSD type tls:GetPaneConfiguration */
public:
	int soap_type() const { return 3024; } /* = unique type id SOAP_TYPE___tls__GetPaneConfiguration */
	         __tls__GetPaneConfiguration();
	friend SOAP_FMAC1 __tls__GetPaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__GetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60607 */
#ifndef SOAP_TYPE___tls__SetPaneConfigurations
#define SOAP_TYPE___tls__SetPaneConfigurations (3028)
/* Operation wrapper: */
struct __tls__SetPaneConfigurations
{
public:
	_tls__SetPaneConfigurations *tls__SetPaneConfigurations;	/* optional element of XSD type tls:SetPaneConfigurations */
public:
	int soap_type() const { return 3028; } /* = unique type id SOAP_TYPE___tls__SetPaneConfigurations */
	         __tls__SetPaneConfigurations();
	friend SOAP_FMAC1 __tls__SetPaneConfigurations * SOAP_FMAC2 soap_instantiate___tls__SetPaneConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60674 */
#ifndef SOAP_TYPE___tls__SetPaneConfiguration
#define SOAP_TYPE___tls__SetPaneConfiguration (3032)
/* Operation wrapper: */
struct __tls__SetPaneConfiguration
{
public:
	_tls__SetPaneConfiguration *tls__SetPaneConfiguration;	/* optional element of XSD type tls:SetPaneConfiguration */
public:
	int soap_type() const { return 3032; } /* = unique type id SOAP_TYPE___tls__SetPaneConfiguration */
	         __tls__SetPaneConfiguration();
	friend SOAP_FMAC1 __tls__SetPaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__SetPaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60742 */
#ifndef SOAP_TYPE___tls__CreatePaneConfiguration
#define SOAP_TYPE___tls__CreatePaneConfiguration (3036)
/* Operation wrapper: */
struct __tls__CreatePaneConfiguration
{
public:
	_tls__CreatePaneConfiguration *tls__CreatePaneConfiguration;	/* optional element of XSD type tls:CreatePaneConfiguration */
public:
	int soap_type() const { return 3036; } /* = unique type id SOAP_TYPE___tls__CreatePaneConfiguration */
	         __tls__CreatePaneConfiguration();
	friend SOAP_FMAC1 __tls__CreatePaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__CreatePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60810 */
#ifndef SOAP_TYPE___tls__DeletePaneConfiguration
#define SOAP_TYPE___tls__DeletePaneConfiguration (3040)
/* Operation wrapper: */
struct __tls__DeletePaneConfiguration
{
public:
	_tls__DeletePaneConfiguration *tls__DeletePaneConfiguration;	/* optional element of XSD type tls:DeletePaneConfiguration */
public:
	int soap_type() const { return 3040; } /* = unique type id SOAP_TYPE___tls__DeletePaneConfiguration */
	         __tls__DeletePaneConfiguration();
	friend SOAP_FMAC1 __tls__DeletePaneConfiguration * SOAP_FMAC2 soap_instantiate___tls__DeletePaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60896 */
#ifndef SOAP_TYPE___tmd__GetServiceCapabilities
#define SOAP_TYPE___tmd__GetServiceCapabilities (3044)
/* Operation wrapper: */
struct __tmd__GetServiceCapabilities
{
public:
	_tmd__GetServiceCapabilities *tmd__GetServiceCapabilities;	/* optional element of XSD type tmd:GetServiceCapabilities */
public:
	int soap_type() const { return 3044; } /* = unique type id SOAP_TYPE___tmd__GetServiceCapabilities */
	         __tmd__GetServiceCapabilities();
	friend SOAP_FMAC1 __tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:60964 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputOptions
#define SOAP_TYPE___tmd__GetRelayOutputOptions (3048)
/* Operation wrapper: */
struct __tmd__GetRelayOutputOptions
{
public:
	_tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions;	/* optional element of XSD type tmd:GetRelayOutputOptions */
public:
	int soap_type() const { return 3048; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputOptions */
	         __tmd__GetRelayOutputOptions();
	friend SOAP_FMAC1 __tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61033 */
#ifndef SOAP_TYPE___tmd__GetAudioSources
#define SOAP_TYPE___tmd__GetAudioSources (3052)
/* Operation wrapper: */
struct __tmd__GetAudioSources
{
public:
	_trt__GetAudioSources *trt__GetAudioSources;	/* optional element of XSD type trt:GetAudioSources */
public:
	int soap_type() const { return 3052; } /* = unique type id SOAP_TYPE___tmd__GetAudioSources */
	         __tmd__GetAudioSources();
	friend SOAP_FMAC1 __tmd__GetAudioSources * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61102 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputs
#define SOAP_TYPE___tmd__GetAudioOutputs (3056)
/* Operation wrapper: */
struct __tmd__GetAudioOutputs
{
public:
	_trt__GetAudioOutputs *trt__GetAudioOutputs;	/* optional element of XSD type trt:GetAudioOutputs */
public:
	int soap_type() const { return 3056; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputs */
	         __tmd__GetAudioOutputs();
	friend SOAP_FMAC1 __tmd__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61171 */
#ifndef SOAP_TYPE___tmd__GetVideoSources
#define SOAP_TYPE___tmd__GetVideoSources (3060)
/* Operation wrapper: */
struct __tmd__GetVideoSources
{
public:
	_trt__GetVideoSources *trt__GetVideoSources;	/* optional element of XSD type trt:GetVideoSources */
public:
	int soap_type() const { return 3060; } /* = unique type id SOAP_TYPE___tmd__GetVideoSources */
	         __tmd__GetVideoSources();
	friend SOAP_FMAC1 __tmd__GetVideoSources * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61240 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputs
#define SOAP_TYPE___tmd__GetVideoOutputs (3064)
/* Operation wrapper: */
struct __tmd__GetVideoOutputs
{
public:
	_tmd__GetVideoOutputs *tmd__GetVideoOutputs;	/* optional element of XSD type tmd:GetVideoOutputs */
public:
	int soap_type() const { return 3064; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputs */
	         __tmd__GetVideoOutputs();
	friend SOAP_FMAC1 __tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61308 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfiguration
#define SOAP_TYPE___tmd__GetVideoSourceConfiguration (3068)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfiguration
{
public:
	_tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration;	/* optional element of XSD type tmd:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 3068; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfiguration */
	         __tmd__GetVideoSourceConfiguration();
	friend SOAP_FMAC1 __tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61376 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfiguration
#define SOAP_TYPE___tmd__GetVideoOutputConfiguration (3072)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfiguration
{
public:
	_tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration;	/* optional element of XSD type tmd:GetVideoOutputConfiguration */
public:
	int soap_type() const { return 3072; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfiguration */
	         __tmd__GetVideoOutputConfiguration();
	friend SOAP_FMAC1 __tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61444 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfiguration
#define SOAP_TYPE___tmd__GetAudioSourceConfiguration (3076)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfiguration
{
public:
	_tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration;	/* optional element of XSD type tmd:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 3076; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfiguration */
	         __tmd__GetAudioSourceConfiguration();
	friend SOAP_FMAC1 __tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61513 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfiguration
#define SOAP_TYPE___tmd__GetAudioOutputConfiguration (3080)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfiguration
{
public:
	_tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration;	/* optional element of XSD type tmd:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 3080; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfiguration */
	         __tmd__GetAudioOutputConfiguration();
	friend SOAP_FMAC1 __tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61581 */
#ifndef SOAP_TYPE___tmd__SetVideoSourceConfiguration
#define SOAP_TYPE___tmd__SetVideoSourceConfiguration (3084)
/* Operation wrapper: */
struct __tmd__SetVideoSourceConfiguration
{
public:
	_tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration;	/* optional element of XSD type tmd:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 3084; } /* = unique type id SOAP_TYPE___tmd__SetVideoSourceConfiguration */
	         __tmd__SetVideoSourceConfiguration();
	friend SOAP_FMAC1 __tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61649 */
#ifndef SOAP_TYPE___tmd__SetVideoOutputConfiguration
#define SOAP_TYPE___tmd__SetVideoOutputConfiguration (3088)
/* Operation wrapper: */
struct __tmd__SetVideoOutputConfiguration
{
public:
	_tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration;	/* optional element of XSD type tmd:SetVideoOutputConfiguration */
public:
	int soap_type() const { return 3088; } /* = unique type id SOAP_TYPE___tmd__SetVideoOutputConfiguration */
	         __tmd__SetVideoOutputConfiguration();
	friend SOAP_FMAC1 __tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61717 */
#ifndef SOAP_TYPE___tmd__SetAudioSourceConfiguration
#define SOAP_TYPE___tmd__SetAudioSourceConfiguration (3092)
/* Operation wrapper: */
struct __tmd__SetAudioSourceConfiguration
{
public:
	_tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration;	/* optional element of XSD type tmd:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 3092; } /* = unique type id SOAP_TYPE___tmd__SetAudioSourceConfiguration */
	         __tmd__SetAudioSourceConfiguration();
	friend SOAP_FMAC1 __tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61785 */
#ifndef SOAP_TYPE___tmd__SetAudioOutputConfiguration
#define SOAP_TYPE___tmd__SetAudioOutputConfiguration (3096)
/* Operation wrapper: */
struct __tmd__SetAudioOutputConfiguration
{
public:
	_tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration;	/* optional element of XSD type tmd:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 3096; } /* = unique type id SOAP_TYPE___tmd__SetAudioOutputConfiguration */
	         __tmd__SetAudioOutputConfiguration();
	friend SOAP_FMAC1 __tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61853 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions (3100)
/* Operation wrapper: */
struct __tmd__GetVideoSourceConfigurationOptions
{
public:
	_tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions;	/* optional element of XSD type tmd:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 3100; } /* = unique type id SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions */
	         __tmd__GetVideoSourceConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61922 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions (3104)
/* Operation wrapper: */
struct __tmd__GetVideoOutputConfigurationOptions
{
public:
	_tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions;	/* optional element of XSD type tmd:GetVideoOutputConfigurationOptions */
public:
	int soap_type() const { return 3104; } /* = unique type id SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions */
	         __tmd__GetVideoOutputConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:61990 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions (3108)
/* Operation wrapper: */
struct __tmd__GetAudioSourceConfigurationOptions
{
public:
	_tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions;	/* optional element of XSD type tmd:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 3108; } /* = unique type id SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions */
	         __tmd__GetAudioSourceConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62058 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions (3112)
/* Operation wrapper: */
struct __tmd__GetAudioOutputConfigurationOptions
{
public:
	_tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions;	/* optional element of XSD type tmd:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 3112; } /* = unique type id SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions */
	         __tmd__GetAudioOutputConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62125 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputs
#define SOAP_TYPE___tmd__GetRelayOutputs (3114)
/* Operation wrapper: */
struct __tmd__GetRelayOutputs
{
public:
	_tds__GetRelayOutputs *tds__GetRelayOutputs;	/* optional element of XSD type tds:GetRelayOutputs */
public:
	int soap_type() const { return 3114; } /* = unique type id SOAP_TYPE___tmd__GetRelayOutputs */
	         __tmd__GetRelayOutputs();
	friend SOAP_FMAC1 __tmd__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62193 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputSettings
#define SOAP_TYPE___tmd__SetRelayOutputSettings (3118)
/* Operation wrapper: */
struct __tmd__SetRelayOutputSettings
{
public:
	_tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings;	/* optional element of XSD type tmd:SetRelayOutputSettings */
public:
	int soap_type() const { return 3118; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputSettings */
	         __tmd__SetRelayOutputSettings();
	friend SOAP_FMAC1 __tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62260 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputState
#define SOAP_TYPE___tmd__SetRelayOutputState (3120)
/* Operation wrapper: */
struct __tmd__SetRelayOutputState
{
public:
	_tds__SetRelayOutputState *tds__SetRelayOutputState;	/* optional element of XSD type tds:SetRelayOutputState */
public:
	int soap_type() const { return 3120; } /* = unique type id SOAP_TYPE___tmd__SetRelayOutputState */
	         __tmd__SetRelayOutputState();
	friend SOAP_FMAC1 __tmd__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62326 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputs
#define SOAP_TYPE___tmd__GetDigitalInputs (3124)
/* Operation wrapper: */
struct __tmd__GetDigitalInputs
{
public:
	_tmd__GetDigitalInputs *tmd__GetDigitalInputs;	/* optional element of XSD type tmd:GetDigitalInputs */
public:
	int soap_type() const { return 3124; } /* = unique type id SOAP_TYPE___tmd__GetDigitalInputs */
	         __tmd__GetDigitalInputs();
	friend SOAP_FMAC1 __tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate___tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62392 */
#ifndef SOAP_TYPE___tmd__GetSerialPorts
#define SOAP_TYPE___tmd__GetSerialPorts (3128)
/* Operation wrapper: */
struct __tmd__GetSerialPorts
{
public:
	_tmd__GetSerialPorts *tmd__GetSerialPorts;	/* optional element of XSD type tmd:GetSerialPorts */
public:
	int soap_type() const { return 3128; } /* = unique type id SOAP_TYPE___tmd__GetSerialPorts */
	         __tmd__GetSerialPorts();
	friend SOAP_FMAC1 __tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62458 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfiguration
#define SOAP_TYPE___tmd__GetSerialPortConfiguration (3132)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfiguration
{
public:
	_tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration;	/* optional element of XSD type tmd:GetSerialPortConfiguration */
public:
	int soap_type() const { return 3132; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfiguration */
	         __tmd__GetSerialPortConfiguration();
	friend SOAP_FMAC1 __tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62524 */
#ifndef SOAP_TYPE___tmd__SetSerialPortConfiguration
#define SOAP_TYPE___tmd__SetSerialPortConfiguration (3136)
/* Operation wrapper: */
struct __tmd__SetSerialPortConfiguration
{
public:
	_tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration;	/* optional element of XSD type tmd:SetSerialPortConfiguration */
public:
	int soap_type() const { return 3136; } /* = unique type id SOAP_TYPE___tmd__SetSerialPortConfiguration */
	         __tmd__SetSerialPortConfiguration();
	friend SOAP_FMAC1 __tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62590 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE___tmd__GetSerialPortConfigurationOptions (3140)
/* Operation wrapper: */
struct __tmd__GetSerialPortConfigurationOptions
{
public:
	_tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions;	/* optional element of XSD type tmd:GetSerialPortConfigurationOptions */
public:
	int soap_type() const { return 3140; } /* = unique type id SOAP_TYPE___tmd__GetSerialPortConfigurationOptions */
	         __tmd__GetSerialPortConfigurationOptions();
	friend SOAP_FMAC1 __tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62656 */
#ifndef SOAP_TYPE___tmd__SendReceiveSerialCommand
#define SOAP_TYPE___tmd__SendReceiveSerialCommand (3144)
/* Operation wrapper: */
struct __tmd__SendReceiveSerialCommand
{
public:
	_tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand;	/* optional element of XSD type tmd:SendReceiveSerialCommand */
public:
	int soap_type() const { return 3144; } /* = unique type id SOAP_TYPE___tmd__SendReceiveSerialCommand */
	         __tmd__SendReceiveSerialCommand();
	friend SOAP_FMAC1 __tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate___tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62741 */
#ifndef SOAP_TYPE___tptz__GetServiceCapabilities
#define SOAP_TYPE___tptz__GetServiceCapabilities (3148)
/* Operation wrapper: */
struct __tptz__GetServiceCapabilities
{
public:
	_tptz__GetServiceCapabilities *tptz__GetServiceCapabilities;	/* optional element of XSD type tptz:GetServiceCapabilities */
public:
	int soap_type() const { return 3148; } /* = unique type id SOAP_TYPE___tptz__GetServiceCapabilities */
	         __tptz__GetServiceCapabilities();
	friend SOAP_FMAC1 __tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62810 */
#ifndef SOAP_TYPE___tptz__GetConfigurations
#define SOAP_TYPE___tptz__GetConfigurations (3152)
/* Operation wrapper: */
struct __tptz__GetConfigurations
{
public:
	_tptz__GetConfigurations *tptz__GetConfigurations;	/* optional element of XSD type tptz:GetConfigurations */
public:
	int soap_type() const { return 3152; } /* = unique type id SOAP_TYPE___tptz__GetConfigurations */
	         __tptz__GetConfigurations();
	friend SOAP_FMAC1 __tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62880 */
#ifndef SOAP_TYPE___tptz__GetPresets
#define SOAP_TYPE___tptz__GetPresets (3156)
/* Operation wrapper: */
struct __tptz__GetPresets
{
public:
	_tptz__GetPresets *tptz__GetPresets;	/* optional element of XSD type tptz:GetPresets */
public:
	int soap_type() const { return 3156; } /* = unique type id SOAP_TYPE___tptz__GetPresets */
	         __tptz__GetPresets();
	friend SOAP_FMAC1 __tptz__GetPresets * SOAP_FMAC2 soap_instantiate___tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:62965 */
#ifndef SOAP_TYPE___tptz__SetPreset
#define SOAP_TYPE___tptz__SetPreset (3160)
/* Operation wrapper: */
struct __tptz__SetPreset
{
public:
	_tptz__SetPreset *tptz__SetPreset;	/* optional element of XSD type tptz:SetPreset */
public:
	int soap_type() const { return 3160; } /* = unique type id SOAP_TYPE___tptz__SetPreset */
	         __tptz__SetPreset();
	friend SOAP_FMAC1 __tptz__SetPreset * SOAP_FMAC2 soap_instantiate___tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63039 */
#ifndef SOAP_TYPE___tptz__RemovePreset
#define SOAP_TYPE___tptz__RemovePreset (3164)
/* Operation wrapper: */
struct __tptz__RemovePreset
{
public:
	_tptz__RemovePreset *tptz__RemovePreset;	/* optional element of XSD type tptz:RemovePreset */
public:
	int soap_type() const { return 3164; } /* = unique type id SOAP_TYPE___tptz__RemovePreset */
	         __tptz__RemovePreset();
	friend SOAP_FMAC1 __tptz__RemovePreset * SOAP_FMAC2 soap_instantiate___tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63109 */
#ifndef SOAP_TYPE___tptz__GotoPreset
#define SOAP_TYPE___tptz__GotoPreset (3168)
/* Operation wrapper: */
struct __tptz__GotoPreset
{
public:
	_tptz__GotoPreset *tptz__GotoPreset;	/* optional element of XSD type tptz:GotoPreset */
public:
	int soap_type() const { return 3168; } /* = unique type id SOAP_TYPE___tptz__GotoPreset */
	         __tptz__GotoPreset();
	friend SOAP_FMAC1 __tptz__GotoPreset * SOAP_FMAC2 soap_instantiate___tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63179 */
#ifndef SOAP_TYPE___tptz__GetStatus
#define SOAP_TYPE___tptz__GetStatus (3172)
/* Operation wrapper: */
struct __tptz__GetStatus
{
public:
	_tptz__GetStatus *tptz__GetStatus;	/* optional element of XSD type tptz:GetStatus */
public:
	int soap_type() const { return 3172; } /* = unique type id SOAP_TYPE___tptz__GetStatus */
	         __tptz__GetStatus();
	friend SOAP_FMAC1 __tptz__GetStatus * SOAP_FMAC2 soap_instantiate___tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63248 */
#ifndef SOAP_TYPE___tptz__GetConfiguration
#define SOAP_TYPE___tptz__GetConfiguration (3176)
/* Operation wrapper: */
struct __tptz__GetConfiguration
{
public:
	_tptz__GetConfiguration *tptz__GetConfiguration;	/* optional element of XSD type tptz:GetConfiguration */
public:
	int soap_type() const { return 3176; } /* = unique type id SOAP_TYPE___tptz__GetConfiguration */
	         __tptz__GetConfiguration();
	friend SOAP_FMAC1 __tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63317 */
#ifndef SOAP_TYPE___tptz__GetNodes
#define SOAP_TYPE___tptz__GetNodes (3180)
/* Operation wrapper: */
struct __tptz__GetNodes
{
public:
	_tptz__GetNodes *tptz__GetNodes;	/* optional element of XSD type tptz:GetNodes */
public:
	int soap_type() const { return 3180; } /* = unique type id SOAP_TYPE___tptz__GetNodes */
	         __tptz__GetNodes();
	friend SOAP_FMAC1 __tptz__GetNodes * SOAP_FMAC2 soap_instantiate___tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63386 */
#ifndef SOAP_TYPE___tptz__GetNode
#define SOAP_TYPE___tptz__GetNode (3184)
/* Operation wrapper: */
struct __tptz__GetNode
{
public:
	_tptz__GetNode *tptz__GetNode;	/* optional element of XSD type tptz:GetNode */
public:
	int soap_type() const { return 3184; } /* = unique type id SOAP_TYPE___tptz__GetNode */
	         __tptz__GetNode();
	friend SOAP_FMAC1 __tptz__GetNode * SOAP_FMAC2 soap_instantiate___tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63455 */
#ifndef SOAP_TYPE___tptz__SetConfiguration
#define SOAP_TYPE___tptz__SetConfiguration (3188)
/* Operation wrapper: */
struct __tptz__SetConfiguration
{
public:
	_tptz__SetConfiguration *tptz__SetConfiguration;	/* optional element of XSD type tptz:SetConfiguration */
public:
	int soap_type() const { return 3188; } /* = unique type id SOAP_TYPE___tptz__SetConfiguration */
	         __tptz__SetConfiguration();
	friend SOAP_FMAC1 __tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63534 */
#ifndef SOAP_TYPE___tptz__GetConfigurationOptions
#define SOAP_TYPE___tptz__GetConfigurationOptions (3192)
/* Operation wrapper: */
struct __tptz__GetConfigurationOptions
{
public:
	_tptz__GetConfigurationOptions *tptz__GetConfigurationOptions;	/* optional element of XSD type tptz:GetConfigurationOptions */
public:
	int soap_type() const { return 3192; } /* = unique type id SOAP_TYPE___tptz__GetConfigurationOptions */
	         __tptz__GetConfigurationOptions();
	friend SOAP_FMAC1 __tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63603 */
#ifndef SOAP_TYPE___tptz__GotoHomePosition
#define SOAP_TYPE___tptz__GotoHomePosition (3196)
/* Operation wrapper: */
struct __tptz__GotoHomePosition
{
public:
	_tptz__GotoHomePosition *tptz__GotoHomePosition;	/* optional element of XSD type tptz:GotoHomePosition */
public:
	int soap_type() const { return 3196; } /* = unique type id SOAP_TYPE___tptz__GotoHomePosition */
	         __tptz__GotoHomePosition();
	friend SOAP_FMAC1 __tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate___tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63675 */
#ifndef SOAP_TYPE___tptz__SetHomePosition
#define SOAP_TYPE___tptz__SetHomePosition (3200)
/* Operation wrapper: */
struct __tptz__SetHomePosition
{
public:
	_tptz__SetHomePosition *tptz__SetHomePosition;	/* optional element of XSD type tptz:SetHomePosition */
public:
	int soap_type() const { return 3200; } /* = unique type id SOAP_TYPE___tptz__SetHomePosition */
	         __tptz__SetHomePosition();
	friend SOAP_FMAC1 __tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate___tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63745 */
#ifndef SOAP_TYPE___tptz__ContinuousMove
#define SOAP_TYPE___tptz__ContinuousMove (3204)
/* Operation wrapper: */
struct __tptz__ContinuousMove
{
public:
	_tptz__ContinuousMove *tptz__ContinuousMove;	/* optional element of XSD type tptz:ContinuousMove */
public:
	int soap_type() const { return 3204; } /* = unique type id SOAP_TYPE___tptz__ContinuousMove */
	         __tptz__ContinuousMove();
	friend SOAP_FMAC1 __tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate___tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63813 */
#ifndef SOAP_TYPE___tptz__RelativeMove
#define SOAP_TYPE___tptz__RelativeMove (3208)
/* Operation wrapper: */
struct __tptz__RelativeMove
{
public:
	_tptz__RelativeMove *tptz__RelativeMove;	/* optional element of XSD type tptz:RelativeMove */
public:
	int soap_type() const { return 3208; } /* = unique type id SOAP_TYPE___tptz__RelativeMove */
	         __tptz__RelativeMove();
	friend SOAP_FMAC1 __tptz__RelativeMove * SOAP_FMAC2 soap_instantiate___tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63885 */
#ifndef SOAP_TYPE___tptz__SendAuxiliaryCommand
#define SOAP_TYPE___tptz__SendAuxiliaryCommand (3212)
/* Operation wrapper: */
struct __tptz__SendAuxiliaryCommand
{
public:
	_tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand;	/* optional element of XSD type tptz:SendAuxiliaryCommand */
public:
	int soap_type() const { return 3212; } /* = unique type id SOAP_TYPE___tptz__SendAuxiliaryCommand */
	         __tptz__SendAuxiliaryCommand();
	friend SOAP_FMAC1 __tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:63952 */
#ifndef SOAP_TYPE___tptz__AbsoluteMove
#define SOAP_TYPE___tptz__AbsoluteMove (3216)
/* Operation wrapper: */
struct __tptz__AbsoluteMove
{
public:
	_tptz__AbsoluteMove *tptz__AbsoluteMove;	/* optional element of XSD type tptz:AbsoluteMove */
public:
	int soap_type() const { return 3216; } /* = unique type id SOAP_TYPE___tptz__AbsoluteMove */
	         __tptz__AbsoluteMove();
	friend SOAP_FMAC1 __tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate___tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64022 */
#ifndef SOAP_TYPE___tptz__Stop
#define SOAP_TYPE___tptz__Stop (3220)
/* Operation wrapper: */
struct __tptz__Stop
{
public:
	_tptz__Stop *tptz__Stop;	/* optional element of XSD type tptz:Stop */
public:
	int soap_type() const { return 3220; } /* = unique type id SOAP_TYPE___tptz__Stop */
	         __tptz__Stop();
	friend SOAP_FMAC1 __tptz__Stop * SOAP_FMAC2 soap_instantiate___tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64089 */
#ifndef SOAP_TYPE___tptz__GetPresetTours
#define SOAP_TYPE___tptz__GetPresetTours (3224)
/* Operation wrapper: */
struct __tptz__GetPresetTours
{
public:
	_tptz__GetPresetTours *tptz__GetPresetTours;	/* optional element of XSD type tptz:GetPresetTours */
public:
	int soap_type() const { return 3224; } /* = unique type id SOAP_TYPE___tptz__GetPresetTours */
	         __tptz__GetPresetTours();
	friend SOAP_FMAC1 __tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64156 */
#ifndef SOAP_TYPE___tptz__GetPresetTour
#define SOAP_TYPE___tptz__GetPresetTour (3228)
/* Operation wrapper: */
struct __tptz__GetPresetTour
{
public:
	_tptz__GetPresetTour *tptz__GetPresetTour;	/* optional element of XSD type tptz:GetPresetTour */
public:
	int soap_type() const { return 3228; } /* = unique type id SOAP_TYPE___tptz__GetPresetTour */
	         __tptz__GetPresetTour();
	friend SOAP_FMAC1 __tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64223 */
#ifndef SOAP_TYPE___tptz__GetPresetTourOptions
#define SOAP_TYPE___tptz__GetPresetTourOptions (3232)
/* Operation wrapper: */
struct __tptz__GetPresetTourOptions
{
public:
	_tptz__GetPresetTourOptions *tptz__GetPresetTourOptions;	/* optional element of XSD type tptz:GetPresetTourOptions */
public:
	int soap_type() const { return 3232; } /* = unique type id SOAP_TYPE___tptz__GetPresetTourOptions */
	         __tptz__GetPresetTourOptions();
	friend SOAP_FMAC1 __tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64290 */
#ifndef SOAP_TYPE___tptz__CreatePresetTour
#define SOAP_TYPE___tptz__CreatePresetTour (3236)
/* Operation wrapper: */
struct __tptz__CreatePresetTour
{
public:
	_tptz__CreatePresetTour *tptz__CreatePresetTour;	/* optional element of XSD type tptz:CreatePresetTour */
public:
	int soap_type() const { return 3236; } /* = unique type id SOAP_TYPE___tptz__CreatePresetTour */
	         __tptz__CreatePresetTour();
	friend SOAP_FMAC1 __tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64357 */
#ifndef SOAP_TYPE___tptz__ModifyPresetTour
#define SOAP_TYPE___tptz__ModifyPresetTour (3240)
/* Operation wrapper: */
struct __tptz__ModifyPresetTour
{
public:
	_tptz__ModifyPresetTour *tptz__ModifyPresetTour;	/* optional element of XSD type tptz:ModifyPresetTour */
public:
	int soap_type() const { return 3240; } /* = unique type id SOAP_TYPE___tptz__ModifyPresetTour */
	         __tptz__ModifyPresetTour();
	friend SOAP_FMAC1 __tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate___tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64424 */
#ifndef SOAP_TYPE___tptz__OperatePresetTour
#define SOAP_TYPE___tptz__OperatePresetTour (3244)
/* Operation wrapper: */
struct __tptz__OperatePresetTour
{
public:
	_tptz__OperatePresetTour *tptz__OperatePresetTour;	/* optional element of XSD type tptz:OperatePresetTour */
public:
	int soap_type() const { return 3244; } /* = unique type id SOAP_TYPE___tptz__OperatePresetTour */
	         __tptz__OperatePresetTour();
	friend SOAP_FMAC1 __tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64491 */
#ifndef SOAP_TYPE___tptz__RemovePresetTour
#define SOAP_TYPE___tptz__RemovePresetTour (3248)
/* Operation wrapper: */
struct __tptz__RemovePresetTour
{
public:
	_tptz__RemovePresetTour *tptz__RemovePresetTour;	/* optional element of XSD type tptz:RemovePresetTour */
public:
	int soap_type() const { return 3248; } /* = unique type id SOAP_TYPE___tptz__RemovePresetTour */
	         __tptz__RemovePresetTour();
	friend SOAP_FMAC1 __tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate___tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64577 */
#ifndef SOAP_TYPE___trc__GetServiceCapabilities
#define SOAP_TYPE___trc__GetServiceCapabilities (3252)
/* Operation wrapper: */
struct __trc__GetServiceCapabilities
{
public:
	_trc__GetServiceCapabilities *trc__GetServiceCapabilities;	/* optional element of XSD type trc:GetServiceCapabilities */
public:
	int soap_type() const { return 3252; } /* = unique type id SOAP_TYPE___trc__GetServiceCapabilities */
	         __trc__GetServiceCapabilities();
	friend SOAP_FMAC1 __trc__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trc__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64646 */
#ifndef SOAP_TYPE___trc__CreateRecording
#define SOAP_TYPE___trc__CreateRecording (3256)
/* Operation wrapper: */
struct __trc__CreateRecording
{
public:
	_trc__CreateRecording *trc__CreateRecording;	/* optional element of XSD type trc:CreateRecording */
public:
	int soap_type() const { return 3256; } /* = unique type id SOAP_TYPE___trc__CreateRecording */
	         __trc__CreateRecording();
	friend SOAP_FMAC1 __trc__CreateRecording * SOAP_FMAC2 soap_instantiate___trc__CreateRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64723 */
#ifndef SOAP_TYPE___trc__DeleteRecording
#define SOAP_TYPE___trc__DeleteRecording (3260)
/* Operation wrapper: */
struct __trc__DeleteRecording
{
public:
	_trc__DeleteRecording *trc__DeleteRecording;	/* optional element of XSD type trc:DeleteRecording */
public:
	int soap_type() const { return 3260; } /* = unique type id SOAP_TYPE___trc__DeleteRecording */
	         __trc__DeleteRecording();
	friend SOAP_FMAC1 __trc__DeleteRecording * SOAP_FMAC2 soap_instantiate___trc__DeleteRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64793 */
#ifndef SOAP_TYPE___trc__GetRecordings
#define SOAP_TYPE___trc__GetRecordings (3264)
/* Operation wrapper: */
struct __trc__GetRecordings
{
public:
	_trc__GetRecordings *trc__GetRecordings;	/* optional element of XSD type trc:GetRecordings */
public:
	int soap_type() const { return 3264; } /* = unique type id SOAP_TYPE___trc__GetRecordings */
	         __trc__GetRecordings();
	friend SOAP_FMAC1 __trc__GetRecordings * SOAP_FMAC2 soap_instantiate___trc__GetRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64860 */
#ifndef SOAP_TYPE___trc__SetRecordingConfiguration
#define SOAP_TYPE___trc__SetRecordingConfiguration (3268)
/* Operation wrapper: */
struct __trc__SetRecordingConfiguration
{
public:
	_trc__SetRecordingConfiguration *trc__SetRecordingConfiguration;	/* optional element of XSD type trc:SetRecordingConfiguration */
public:
	int soap_type() const { return 3268; } /* = unique type id SOAP_TYPE___trc__SetRecordingConfiguration */
	         __trc__SetRecordingConfiguration();
	friend SOAP_FMAC1 __trc__SetRecordingConfiguration * SOAP_FMAC2 soap_instantiate___trc__SetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64927 */
#ifndef SOAP_TYPE___trc__GetRecordingConfiguration
#define SOAP_TYPE___trc__GetRecordingConfiguration (3272)
/* Operation wrapper: */
struct __trc__GetRecordingConfiguration
{
public:
	_trc__GetRecordingConfiguration *trc__GetRecordingConfiguration;	/* optional element of XSD type trc:GetRecordingConfiguration */
public:
	int soap_type() const { return 3272; } /* = unique type id SOAP_TYPE___trc__GetRecordingConfiguration */
	         __trc__GetRecordingConfiguration();
	friend SOAP_FMAC1 __trc__GetRecordingConfiguration * SOAP_FMAC2 soap_instantiate___trc__GetRecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:64996 */
#ifndef SOAP_TYPE___trc__GetRecordingOptions
#define SOAP_TYPE___trc__GetRecordingOptions (3276)
/* Operation wrapper: */
struct __trc__GetRecordingOptions
{
public:
	_trc__GetRecordingOptions *trc__GetRecordingOptions;	/* optional element of XSD type trc:GetRecordingOptions */
public:
	int soap_type() const { return 3276; } /* = unique type id SOAP_TYPE___trc__GetRecordingOptions */
	         __trc__GetRecordingOptions();
	friend SOAP_FMAC1 __trc__GetRecordingOptions * SOAP_FMAC2 soap_instantiate___trc__GetRecordingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65063 */
#ifndef SOAP_TYPE___trc__CreateTrack
#define SOAP_TYPE___trc__CreateTrack (3280)
/* Operation wrapper: */
struct __trc__CreateTrack
{
public:
	_trc__CreateTrack *trc__CreateTrack;	/* optional element of XSD type trc:CreateTrack */
public:
	int soap_type() const { return 3280; } /* = unique type id SOAP_TYPE___trc__CreateTrack */
	         __trc__CreateTrack();
	friend SOAP_FMAC1 __trc__CreateTrack * SOAP_FMAC2 soap_instantiate___trc__CreateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65131 */
#ifndef SOAP_TYPE___trc__DeleteTrack
#define SOAP_TYPE___trc__DeleteTrack (3284)
/* Operation wrapper: */
struct __trc__DeleteTrack
{
public:
	_trc__DeleteTrack *trc__DeleteTrack;	/* optional element of XSD type trc:DeleteTrack */
public:
	int soap_type() const { return 3284; } /* = unique type id SOAP_TYPE___trc__DeleteTrack */
	         __trc__DeleteTrack();
	friend SOAP_FMAC1 __trc__DeleteTrack * SOAP_FMAC2 soap_instantiate___trc__DeleteTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65198 */
#ifndef SOAP_TYPE___trc__GetTrackConfiguration
#define SOAP_TYPE___trc__GetTrackConfiguration (3288)
/* Operation wrapper: */
struct __trc__GetTrackConfiguration
{
public:
	_trc__GetTrackConfiguration *trc__GetTrackConfiguration;	/* optional element of XSD type trc:GetTrackConfiguration */
public:
	int soap_type() const { return 3288; } /* = unique type id SOAP_TYPE___trc__GetTrackConfiguration */
	         __trc__GetTrackConfiguration();
	friend SOAP_FMAC1 __trc__GetTrackConfiguration * SOAP_FMAC2 soap_instantiate___trc__GetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65265 */
#ifndef SOAP_TYPE___trc__SetTrackConfiguration
#define SOAP_TYPE___trc__SetTrackConfiguration (3292)
/* Operation wrapper: */
struct __trc__SetTrackConfiguration
{
public:
	_trc__SetTrackConfiguration *trc__SetTrackConfiguration;	/* optional element of XSD type trc:SetTrackConfiguration */
public:
	int soap_type() const { return 3292; } /* = unique type id SOAP_TYPE___trc__SetTrackConfiguration */
	         __trc__SetTrackConfiguration();
	friend SOAP_FMAC1 __trc__SetTrackConfiguration * SOAP_FMAC2 soap_instantiate___trc__SetTrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65332 */
#ifndef SOAP_TYPE___trc__CreateRecordingJob
#define SOAP_TYPE___trc__CreateRecordingJob (3296)
/* Operation wrapper: */
struct __trc__CreateRecordingJob
{
public:
	_trc__CreateRecordingJob *trc__CreateRecordingJob;	/* optional element of XSD type trc:CreateRecordingJob */
public:
	int soap_type() const { return 3296; } /* = unique type id SOAP_TYPE___trc__CreateRecordingJob */
	         __trc__CreateRecordingJob();
	friend SOAP_FMAC1 __trc__CreateRecordingJob * SOAP_FMAC2 soap_instantiate___trc__CreateRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65405 */
#ifndef SOAP_TYPE___trc__DeleteRecordingJob
#define SOAP_TYPE___trc__DeleteRecordingJob (3300)
/* Operation wrapper: */
struct __trc__DeleteRecordingJob
{
public:
	_trc__DeleteRecordingJob *trc__DeleteRecordingJob;	/* optional element of XSD type trc:DeleteRecordingJob */
public:
	int soap_type() const { return 3300; } /* = unique type id SOAP_TYPE___trc__DeleteRecordingJob */
	         __trc__DeleteRecordingJob();
	friend SOAP_FMAC1 __trc__DeleteRecordingJob * SOAP_FMAC2 soap_instantiate___trc__DeleteRecordingJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65472 */
#ifndef SOAP_TYPE___trc__GetRecordingJobs
#define SOAP_TYPE___trc__GetRecordingJobs (3304)
/* Operation wrapper: */
struct __trc__GetRecordingJobs
{
public:
	_trc__GetRecordingJobs *trc__GetRecordingJobs;	/* optional element of XSD type trc:GetRecordingJobs */
public:
	int soap_type() const { return 3304; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobs */
	         __trc__GetRecordingJobs();
	friend SOAP_FMAC1 __trc__GetRecordingJobs * SOAP_FMAC2 soap_instantiate___trc__GetRecordingJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65539 */
#ifndef SOAP_TYPE___trc__SetRecordingJobConfiguration
#define SOAP_TYPE___trc__SetRecordingJobConfiguration (3308)
/* Operation wrapper: */
struct __trc__SetRecordingJobConfiguration
{
public:
	_trc__SetRecordingJobConfiguration *trc__SetRecordingJobConfiguration;	/* optional element of XSD type trc:SetRecordingJobConfiguration */
public:
	int soap_type() const { return 3308; } /* = unique type id SOAP_TYPE___trc__SetRecordingJobConfiguration */
	         __trc__SetRecordingJobConfiguration();
	friend SOAP_FMAC1 __trc__SetRecordingJobConfiguration * SOAP_FMAC2 soap_instantiate___trc__SetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65607 */
#ifndef SOAP_TYPE___trc__GetRecordingJobConfiguration
#define SOAP_TYPE___trc__GetRecordingJobConfiguration (3312)
/* Operation wrapper: */
struct __trc__GetRecordingJobConfiguration
{
public:
	_trc__GetRecordingJobConfiguration *trc__GetRecordingJobConfiguration;	/* optional element of XSD type trc:GetRecordingJobConfiguration */
public:
	int soap_type() const { return 3312; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobConfiguration */
	         __trc__GetRecordingJobConfiguration();
	friend SOAP_FMAC1 __trc__GetRecordingJobConfiguration * SOAP_FMAC2 soap_instantiate___trc__GetRecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65678 */
#ifndef SOAP_TYPE___trc__SetRecordingJobMode
#define SOAP_TYPE___trc__SetRecordingJobMode (3316)
/* Operation wrapper: */
struct __trc__SetRecordingJobMode
{
public:
	_trc__SetRecordingJobMode *trc__SetRecordingJobMode;	/* optional element of XSD type trc:SetRecordingJobMode */
public:
	int soap_type() const { return 3316; } /* = unique type id SOAP_TYPE___trc__SetRecordingJobMode */
	         __trc__SetRecordingJobMode();
	friend SOAP_FMAC1 __trc__SetRecordingJobMode * SOAP_FMAC2 soap_instantiate___trc__SetRecordingJobMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65747 */
#ifndef SOAP_TYPE___trc__GetRecordingJobState
#define SOAP_TYPE___trc__GetRecordingJobState (3320)
/* Operation wrapper: */
struct __trc__GetRecordingJobState
{
public:
	_trc__GetRecordingJobState *trc__GetRecordingJobState;	/* optional element of XSD type trc:GetRecordingJobState */
public:
	int soap_type() const { return 3320; } /* = unique type id SOAP_TYPE___trc__GetRecordingJobState */
	         __trc__GetRecordingJobState();
	friend SOAP_FMAC1 __trc__GetRecordingJobState * SOAP_FMAC2 soap_instantiate___trc__GetRecordingJobState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65833 */
#ifndef SOAP_TYPE___trp__GetServiceCapabilities
#define SOAP_TYPE___trp__GetServiceCapabilities (3324)
/* Operation wrapper: */
struct __trp__GetServiceCapabilities
{
public:
	_trp__GetServiceCapabilities *trp__GetServiceCapabilities;	/* optional element of XSD type trp:GetServiceCapabilities */
public:
	int soap_type() const { return 3324; } /* = unique type id SOAP_TYPE___trp__GetServiceCapabilities */
	         __trp__GetServiceCapabilities();
	friend SOAP_FMAC1 __trp__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trp__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65907 */
#ifndef SOAP_TYPE___trp__GetReplayUri
#define SOAP_TYPE___trp__GetReplayUri (3328)
/* Operation wrapper: */
struct __trp__GetReplayUri
{
public:
	_trp__GetReplayUri *trp__GetReplayUri;	/* optional element of XSD type trp:GetReplayUri */
public:
	int soap_type() const { return 3328; } /* = unique type id SOAP_TYPE___trp__GetReplayUri */
	         __trp__GetReplayUri();
	friend SOAP_FMAC1 __trp__GetReplayUri * SOAP_FMAC2 soap_instantiate___trp__GetReplayUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:65978 */
#ifndef SOAP_TYPE___trp__GetReplayConfiguration
#define SOAP_TYPE___trp__GetReplayConfiguration (3332)
/* Operation wrapper: */
struct __trp__GetReplayConfiguration
{
public:
	_trp__GetReplayConfiguration *trp__GetReplayConfiguration;	/* optional element of XSD type trp:GetReplayConfiguration */
public:
	int soap_type() const { return 3332; } /* = unique type id SOAP_TYPE___trp__GetReplayConfiguration */
	         __trp__GetReplayConfiguration();
	friend SOAP_FMAC1 __trp__GetReplayConfiguration * SOAP_FMAC2 soap_instantiate___trp__GetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66049 */
#ifndef SOAP_TYPE___trp__SetReplayConfiguration
#define SOAP_TYPE___trp__SetReplayConfiguration (3336)
/* Operation wrapper: */
struct __trp__SetReplayConfiguration
{
public:
	_trp__SetReplayConfiguration *trp__SetReplayConfiguration;	/* optional element of XSD type trp:SetReplayConfiguration */
public:
	int soap_type() const { return 3336; } /* = unique type id SOAP_TYPE___trp__SetReplayConfiguration */
	         __trp__SetReplayConfiguration();
	friend SOAP_FMAC1 __trp__SetReplayConfiguration * SOAP_FMAC2 soap_instantiate___trp__SetReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66135 */
#ifndef SOAP_TYPE___trt__GetServiceCapabilities
#define SOAP_TYPE___trt__GetServiceCapabilities (3340)
/* Operation wrapper: */
struct __trt__GetServiceCapabilities
{
public:
	_trt__GetServiceCapabilities *trt__GetServiceCapabilities;	/* optional element of XSD type trt:GetServiceCapabilities */
public:
	int soap_type() const { return 3340; } /* = unique type id SOAP_TYPE___trt__GetServiceCapabilities */
	         __trt__GetServiceCapabilities();
	friend SOAP_FMAC1 __trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66202 */
#ifndef SOAP_TYPE___trt__GetVideoSources
#define SOAP_TYPE___trt__GetVideoSources (3342)
/* Operation wrapper: */
struct __trt__GetVideoSources
{
public:
	_trt__GetVideoSources *trt__GetVideoSources;	/* optional element of XSD type trt:GetVideoSources */
public:
	int soap_type() const { return 3342; } /* = unique type id SOAP_TYPE___trt__GetVideoSources */
	         __trt__GetVideoSources();
	friend SOAP_FMAC1 __trt__GetVideoSources * SOAP_FMAC2 soap_instantiate___trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66269 */
#ifndef SOAP_TYPE___trt__GetAudioSources
#define SOAP_TYPE___trt__GetAudioSources (3344)
/* Operation wrapper: */
struct __trt__GetAudioSources
{
public:
	_trt__GetAudioSources *trt__GetAudioSources;	/* optional element of XSD type trt:GetAudioSources */
public:
	int soap_type() const { return 3344; } /* = unique type id SOAP_TYPE___trt__GetAudioSources */
	         __trt__GetAudioSources();
	friend SOAP_FMAC1 __trt__GetAudioSources * SOAP_FMAC2 soap_instantiate___trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66336 */
#ifndef SOAP_TYPE___trt__GetAudioOutputs
#define SOAP_TYPE___trt__GetAudioOutputs (3346)
/* Operation wrapper: */
struct __trt__GetAudioOutputs
{
public:
	_trt__GetAudioOutputs *trt__GetAudioOutputs;	/* optional element of XSD type trt:GetAudioOutputs */
public:
	int soap_type() const { return 3346; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputs */
	         __trt__GetAudioOutputs();
	friend SOAP_FMAC1 __trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66407 */
#ifndef SOAP_TYPE___trt__CreateProfile
#define SOAP_TYPE___trt__CreateProfile (3350)
/* Operation wrapper: */
struct __trt__CreateProfile
{
public:
	_trt__CreateProfile *trt__CreateProfile;	/* optional element of XSD type trt:CreateProfile */
public:
	int soap_type() const { return 3350; } /* = unique type id SOAP_TYPE___trt__CreateProfile */
	         __trt__CreateProfile();
	friend SOAP_FMAC1 __trt__CreateProfile * SOAP_FMAC2 soap_instantiate___trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66475 */
#ifndef SOAP_TYPE___trt__GetProfile
#define SOAP_TYPE___trt__GetProfile (3354)
/* Operation wrapper: */
struct __trt__GetProfile
{
public:
	_trt__GetProfile *trt__GetProfile;	/* optional element of XSD type trt:GetProfile */
public:
	int soap_type() const { return 3354; } /* = unique type id SOAP_TYPE___trt__GetProfile */
	         __trt__GetProfile();
	friend SOAP_FMAC1 __trt__GetProfile * SOAP_FMAC2 soap_instantiate___trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66547 */
#ifndef SOAP_TYPE___trt__GetProfiles
#define SOAP_TYPE___trt__GetProfiles (3358)
/* Operation wrapper: */
struct __trt__GetProfiles
{
public:
	_trt__GetProfiles *trt__GetProfiles;	/* optional element of XSD type trt:GetProfiles */
public:
	int soap_type() const { return 3358; } /* = unique type id SOAP_TYPE___trt__GetProfiles */
	         __trt__GetProfiles();
	friend SOAP_FMAC1 __trt__GetProfiles * SOAP_FMAC2 soap_instantiate___trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66621 */
#ifndef SOAP_TYPE___trt__AddVideoEncoderConfiguration
#define SOAP_TYPE___trt__AddVideoEncoderConfiguration (3362)
/* Operation wrapper: */
struct __trt__AddVideoEncoderConfiguration
{
public:
	_trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration;	/* optional element of XSD type trt:AddVideoEncoderConfiguration */
public:
	int soap_type() const { return 3362; } /* = unique type id SOAP_TYPE___trt__AddVideoEncoderConfiguration */
	         __trt__AddVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66691 */
#ifndef SOAP_TYPE___trt__AddVideoSourceConfiguration
#define SOAP_TYPE___trt__AddVideoSourceConfiguration (3366)
/* Operation wrapper: */
struct __trt__AddVideoSourceConfiguration
{
public:
	_trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration;	/* optional element of XSD type trt:AddVideoSourceConfiguration */
public:
	int soap_type() const { return 3366; } /* = unique type id SOAP_TYPE___trt__AddVideoSourceConfiguration */
	         __trt__AddVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66765 */
#ifndef SOAP_TYPE___trt__AddAudioEncoderConfiguration
#define SOAP_TYPE___trt__AddAudioEncoderConfiguration (3370)
/* Operation wrapper: */
struct __trt__AddAudioEncoderConfiguration
{
public:
	_trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration;	/* optional element of XSD type trt:AddAudioEncoderConfiguration */
public:
	int soap_type() const { return 3370; } /* = unique type id SOAP_TYPE___trt__AddAudioEncoderConfiguration */
	         __trt__AddAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66835 */
#ifndef SOAP_TYPE___trt__AddAudioSourceConfiguration
#define SOAP_TYPE___trt__AddAudioSourceConfiguration (3374)
/* Operation wrapper: */
struct __trt__AddAudioSourceConfiguration
{
public:
	_trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration;	/* optional element of XSD type trt:AddAudioSourceConfiguration */
public:
	int soap_type() const { return 3374; } /* = unique type id SOAP_TYPE___trt__AddAudioSourceConfiguration */
	         __trt__AddAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66909 */
#ifndef SOAP_TYPE___trt__AddPTZConfiguration
#define SOAP_TYPE___trt__AddPTZConfiguration (3378)
/* Operation wrapper: */
struct __trt__AddPTZConfiguration
{
public:
	_trt__AddPTZConfiguration *trt__AddPTZConfiguration;	/* optional element of XSD type trt:AddPTZConfiguration */
public:
	int soap_type() const { return 3378; } /* = unique type id SOAP_TYPE___trt__AddPTZConfiguration */
	         __trt__AddPTZConfiguration();
	friend SOAP_FMAC1 __trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:66986 */
#ifndef SOAP_TYPE___trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__AddVideoAnalyticsConfiguration (3382)
/* Operation wrapper: */
struct __trt__AddVideoAnalyticsConfiguration
{
public:
	_trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration;	/* optional element of XSD type trt:AddVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3382; } /* = unique type id SOAP_TYPE___trt__AddVideoAnalyticsConfiguration */
	         __trt__AddVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67057 */
#ifndef SOAP_TYPE___trt__AddMetadataConfiguration
#define SOAP_TYPE___trt__AddMetadataConfiguration (3386)
/* Operation wrapper: */
struct __trt__AddMetadataConfiguration
{
public:
	_trt__AddMetadataConfiguration *trt__AddMetadataConfiguration;	/* optional element of XSD type trt:AddMetadataConfiguration */
public:
	int soap_type() const { return 3386; } /* = unique type id SOAP_TYPE___trt__AddMetadataConfiguration */
	         __trt__AddMetadataConfiguration();
	friend SOAP_FMAC1 __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67126 */
#ifndef SOAP_TYPE___trt__AddAudioOutputConfiguration
#define SOAP_TYPE___trt__AddAudioOutputConfiguration (3390)
/* Operation wrapper: */
struct __trt__AddAudioOutputConfiguration
{
public:
	_trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration;	/* optional element of XSD type trt:AddAudioOutputConfiguration */
public:
	int soap_type() const { return 3390; } /* = unique type id SOAP_TYPE___trt__AddAudioOutputConfiguration */
	         __trt__AddAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67195 */
#ifndef SOAP_TYPE___trt__AddAudioDecoderConfiguration
#define SOAP_TYPE___trt__AddAudioDecoderConfiguration (3394)
/* Operation wrapper: */
struct __trt__AddAudioDecoderConfiguration
{
public:
	_trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration;	/* optional element of XSD type trt:AddAudioDecoderConfiguration */
public:
	int soap_type() const { return 3394; } /* = unique type id SOAP_TYPE___trt__AddAudioDecoderConfiguration */
	         __trt__AddAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67265 */
#ifndef SOAP_TYPE___trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___trt__RemoveVideoEncoderConfiguration (3398)
/* Operation wrapper: */
struct __trt__RemoveVideoEncoderConfiguration
{
public:
	_trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration;	/* optional element of XSD type trt:RemoveVideoEncoderConfiguration */
public:
	int soap_type() const { return 3398; } /* = unique type id SOAP_TYPE___trt__RemoveVideoEncoderConfiguration */
	         __trt__RemoveVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67337 */
#ifndef SOAP_TYPE___trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE___trt__RemoveVideoSourceConfiguration (3402)
/* Operation wrapper: */
struct __trt__RemoveVideoSourceConfiguration
{
public:
	_trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration;	/* optional element of XSD type trt:RemoveVideoSourceConfiguration */
public:
	int soap_type() const { return 3402; } /* = unique type id SOAP_TYPE___trt__RemoveVideoSourceConfiguration */
	         __trt__RemoveVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67408 */
#ifndef SOAP_TYPE___trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioEncoderConfiguration (3406)
/* Operation wrapper: */
struct __trt__RemoveAudioEncoderConfiguration
{
public:
	_trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration;	/* optional element of XSD type trt:RemoveAudioEncoderConfiguration */
public:
	int soap_type() const { return 3406; } /* = unique type id SOAP_TYPE___trt__RemoveAudioEncoderConfiguration */
	         __trt__RemoveAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67481 */
#ifndef SOAP_TYPE___trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE___trt__RemoveAudioSourceConfiguration (3410)
/* Operation wrapper: */
struct __trt__RemoveAudioSourceConfiguration
{
public:
	_trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration;	/* optional element of XSD type trt:RemoveAudioSourceConfiguration */
public:
	int soap_type() const { return 3410; } /* = unique type id SOAP_TYPE___trt__RemoveAudioSourceConfiguration */
	         __trt__RemoveAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67551 */
#ifndef SOAP_TYPE___trt__RemovePTZConfiguration
#define SOAP_TYPE___trt__RemovePTZConfiguration (3414)
/* Operation wrapper: */
struct __trt__RemovePTZConfiguration
{
public:
	_trt__RemovePTZConfiguration *trt__RemovePTZConfiguration;	/* optional element of XSD type trt:RemovePTZConfiguration */
public:
	int soap_type() const { return 3414; } /* = unique type id SOAP_TYPE___trt__RemovePTZConfiguration */
	         __trt__RemovePTZConfiguration();
	friend SOAP_FMAC1 __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67621 */
#ifndef SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration (3418)
/* Operation wrapper: */
struct __trt__RemoveVideoAnalyticsConfiguration
{
public:
	_trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration;	/* optional element of XSD type trt:RemoveVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3418; } /* = unique type id SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration */
	         __trt__RemoveVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67690 */
#ifndef SOAP_TYPE___trt__RemoveMetadataConfiguration
#define SOAP_TYPE___trt__RemoveMetadataConfiguration (3422)
/* Operation wrapper: */
struct __trt__RemoveMetadataConfiguration
{
public:
	_trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration;	/* optional element of XSD type trt:RemoveMetadataConfiguration */
public:
	int soap_type() const { return 3422; } /* = unique type id SOAP_TYPE___trt__RemoveMetadataConfiguration */
	         __trt__RemoveMetadataConfiguration();
	friend SOAP_FMAC1 __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67759 */
#ifndef SOAP_TYPE___trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE___trt__RemoveAudioOutputConfiguration (3426)
/* Operation wrapper: */
struct __trt__RemoveAudioOutputConfiguration
{
public:
	_trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration;	/* optional element of XSD type trt:RemoveAudioOutputConfiguration */
public:
	int soap_type() const { return 3426; } /* = unique type id SOAP_TYPE___trt__RemoveAudioOutputConfiguration */
	         __trt__RemoveAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67828 */
#ifndef SOAP_TYPE___trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioDecoderConfiguration (3430)
/* Operation wrapper: */
struct __trt__RemoveAudioDecoderConfiguration
{
public:
	_trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration;	/* optional element of XSD type trt:RemoveAudioDecoderConfiguration */
public:
	int soap_type() const { return 3430; } /* = unique type id SOAP_TYPE___trt__RemoveAudioDecoderConfiguration */
	         __trt__RemoveAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67896 */
#ifndef SOAP_TYPE___trt__DeleteProfile
#define SOAP_TYPE___trt__DeleteProfile (3434)
/* Operation wrapper: */
struct __trt__DeleteProfile
{
public:
	_trt__DeleteProfile *trt__DeleteProfile;	/* optional element of XSD type trt:DeleteProfile */
public:
	int soap_type() const { return 3434; } /* = unique type id SOAP_TYPE___trt__DeleteProfile */
	         __trt__DeleteProfile();
	friend SOAP_FMAC1 __trt__DeleteProfile * SOAP_FMAC2 soap_instantiate___trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:67965 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurations
#define SOAP_TYPE___trt__GetVideoSourceConfigurations (3438)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurations
{
public:
	_trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations;	/* optional element of XSD type trt:GetVideoSourceConfigurations */
public:
	int soap_type() const { return 3438; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurations */
	         __trt__GetVideoSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68035 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetVideoEncoderConfigurations (3442)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurations
{
public:
	_trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations;	/* optional element of XSD type trt:GetVideoEncoderConfigurations */
public:
	int soap_type() const { return 3442; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurations */
	         __trt__GetVideoEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68105 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurations
#define SOAP_TYPE___trt__GetAudioSourceConfigurations (3446)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurations
{
public:
	_trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations;	/* optional element of XSD type trt:GetAudioSourceConfigurations */
public:
	int soap_type() const { return 3446; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurations */
	         __trt__GetAudioSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68174 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetAudioEncoderConfigurations (3450)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurations
{
public:
	_trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations;	/* optional element of XSD type trt:GetAudioEncoderConfigurations */
public:
	int soap_type() const { return 3450; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurations */
	         __trt__GetAudioEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68243 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetVideoAnalyticsConfigurations (3454)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfigurations
{
public:
	_trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 3454; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfigurations */
	         __trt__GetVideoAnalyticsConfigurations();
	friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68311 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurations
#define SOAP_TYPE___trt__GetMetadataConfigurations (3458)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurations
{
public:
	_trt__GetMetadataConfigurations *trt__GetMetadataConfigurations;	/* optional element of XSD type trt:GetMetadataConfigurations */
public:
	int soap_type() const { return 3458; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurations */
	         __trt__GetMetadataConfigurations();
	friend SOAP_FMAC1 __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68379 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurations
#define SOAP_TYPE___trt__GetAudioOutputConfigurations (3462)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurations
{
public:
	_trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations;	/* optional element of XSD type trt:GetAudioOutputConfigurations */
public:
	int soap_type() const { return 3462; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurations */
	         __trt__GetAudioOutputConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68449 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetAudioDecoderConfigurations (3466)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurations
{
public:
	_trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations;	/* optional element of XSD type trt:GetAudioDecoderConfigurations */
public:
	int soap_type() const { return 3466; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurations */
	         __trt__GetAudioDecoderConfigurations();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68517 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfiguration
#define SOAP_TYPE___trt__GetVideoSourceConfiguration (3470)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfiguration
{
public:
	_trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration;	/* optional element of XSD type trt:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 3470; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfiguration */
	         __trt__GetVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68585 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfiguration
#define SOAP_TYPE___trt__GetVideoEncoderConfiguration (3474)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfiguration
{
public:
	_trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration;	/* optional element of XSD type trt:GetVideoEncoderConfiguration */
public:
	int soap_type() const { return 3474; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfiguration */
	         __trt__GetVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68653 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfiguration
#define SOAP_TYPE___trt__GetAudioSourceConfiguration (3478)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfiguration
{
public:
	_trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration;	/* optional element of XSD type trt:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 3478; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfiguration */
	         __trt__GetAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68721 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfiguration
#define SOAP_TYPE___trt__GetAudioEncoderConfiguration (3482)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfiguration
{
public:
	_trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration;	/* optional element of XSD type trt:GetAudioEncoderConfiguration */
public:
	int soap_type() const { return 3482; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfiguration */
	         __trt__GetAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68789 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__GetVideoAnalyticsConfiguration (3486)
/* Operation wrapper: */
struct __trt__GetVideoAnalyticsConfiguration
{
public:
	_trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:GetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3486; } /* = unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfiguration */
	         __trt__GetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68857 */
#ifndef SOAP_TYPE___trt__GetMetadataConfiguration
#define SOAP_TYPE___trt__GetMetadataConfiguration (3490)
/* Operation wrapper: */
struct __trt__GetMetadataConfiguration
{
public:
	_trt__GetMetadataConfiguration *trt__GetMetadataConfiguration;	/* optional element of XSD type trt:GetMetadataConfiguration */
public:
	int soap_type() const { return 3490; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfiguration */
	         __trt__GetMetadataConfiguration();
	friend SOAP_FMAC1 __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68925 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfiguration
#define SOAP_TYPE___trt__GetAudioOutputConfiguration (3494)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfiguration
{
public:
	_trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration;	/* optional element of XSD type trt:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 3494; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfiguration */
	         __trt__GetAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:68993 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfiguration
#define SOAP_TYPE___trt__GetAudioDecoderConfiguration (3498)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfiguration
{
public:
	_trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration;	/* optional element of XSD type trt:GetAudioDecoderConfiguration */
public:
	int soap_type() const { return 3498; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfiguration */
	         __trt__GetAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69064 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations (3502)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoEncoderConfigurations
{
public:
	_trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoEncoderConfigurations */
public:
	int soap_type() const { return 3502; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations */
	         __trt__GetCompatibleVideoEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69137 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations (3506)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoSourceConfigurations
{
public:
	_trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoSourceConfigurations */
public:
	int soap_type() const { return 3506; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations */
	         __trt__GetCompatibleVideoSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69208 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations (3510)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioEncoderConfigurations
{
public:
	_trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioEncoderConfigurations */
public:
	int soap_type() const { return 3510; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations */
	         __trt__GetCompatibleAudioEncoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69279 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations (3514)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioSourceConfigurations
{
public:
	_trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioSourceConfigurations */
public:
	int soap_type() const { return 3514; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations */
	         __trt__GetCompatibleAudioSourceConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69350 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations (3518)
/* Operation wrapper: */
struct __trt__GetCompatibleVideoAnalyticsConfigurations
{
public:
	_trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations;	/* optional element of XSD type trt:GetCompatibleVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 3518; } /* = unique type id SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations */
	         __trt__GetCompatibleVideoAnalyticsConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69421 */
#ifndef SOAP_TYPE___trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___trt__GetCompatibleMetadataConfigurations (3522)
/* Operation wrapper: */
struct __trt__GetCompatibleMetadataConfigurations
{
public:
	_trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations;	/* optional element of XSD type trt:GetCompatibleMetadataConfigurations */
public:
	int soap_type() const { return 3522; } /* = unique type id SOAP_TYPE___trt__GetCompatibleMetadataConfigurations */
	         __trt__GetCompatibleMetadataConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69491 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations (3526)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioOutputConfigurations
{
public:
	_trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioOutputConfigurations */
public:
	int soap_type() const { return 3526; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations */
	         __trt__GetCompatibleAudioOutputConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69561 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations (3530)
/* Operation wrapper: */
struct __trt__GetCompatibleAudioDecoderConfigurations
{
public:
	_trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations;	/* optional element of XSD type trt:GetCompatibleAudioDecoderConfigurations */
public:
	int soap_type() const { return 3530; } /* = unique type id SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations */
	         __trt__GetCompatibleAudioDecoderConfigurations();
	friend SOAP_FMAC1 __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69633 */
#ifndef SOAP_TYPE___trt__SetVideoSourceConfiguration
#define SOAP_TYPE___trt__SetVideoSourceConfiguration (3534)
/* Operation wrapper: */
struct __trt__SetVideoSourceConfiguration
{
public:
	_trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration;	/* optional element of XSD type trt:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 3534; } /* = unique type id SOAP_TYPE___trt__SetVideoSourceConfiguration */
	         __trt__SetVideoSourceConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69706 */
#ifndef SOAP_TYPE___trt__SetVideoEncoderConfiguration
#define SOAP_TYPE___trt__SetVideoEncoderConfiguration (3538)
/* Operation wrapper: */
struct __trt__SetVideoEncoderConfiguration
{
public:
	_trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration;	/* optional element of XSD type trt:SetVideoEncoderConfiguration */
public:
	int soap_type() const { return 3538; } /* = unique type id SOAP_TYPE___trt__SetVideoEncoderConfiguration */
	         __trt__SetVideoEncoderConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69780 */
#ifndef SOAP_TYPE___trt__SetAudioSourceConfiguration
#define SOAP_TYPE___trt__SetAudioSourceConfiguration (3542)
/* Operation wrapper: */
struct __trt__SetAudioSourceConfiguration
{
public:
	_trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration;	/* optional element of XSD type trt:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 3542; } /* = unique type id SOAP_TYPE___trt__SetAudioSourceConfiguration */
	         __trt__SetAudioSourceConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69855 */
#ifndef SOAP_TYPE___trt__SetAudioEncoderConfiguration
#define SOAP_TYPE___trt__SetAudioEncoderConfiguration (3546)
/* Operation wrapper: */
struct __trt__SetAudioEncoderConfiguration
{
public:
	_trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration;	/* optional element of XSD type trt:SetAudioEncoderConfiguration */
public:
	int soap_type() const { return 3546; } /* = unique type id SOAP_TYPE___trt__SetAudioEncoderConfiguration */
	         __trt__SetAudioEncoderConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:69932 */
#ifndef SOAP_TYPE___trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__SetVideoAnalyticsConfiguration (3550)
/* Operation wrapper: */
struct __trt__SetVideoAnalyticsConfiguration
{
public:
	_trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration;	/* optional element of XSD type trt:SetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 3550; } /* = unique type id SOAP_TYPE___trt__SetVideoAnalyticsConfiguration */
	         __trt__SetVideoAnalyticsConfiguration();
	friend SOAP_FMAC1 __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70008 */
#ifndef SOAP_TYPE___trt__SetMetadataConfiguration
#define SOAP_TYPE___trt__SetMetadataConfiguration (3554)
/* Operation wrapper: */
struct __trt__SetMetadataConfiguration
{
public:
	_trt__SetMetadataConfiguration *trt__SetMetadataConfiguration;	/* optional element of XSD type trt:SetMetadataConfiguration */
public:
	int soap_type() const { return 3554; } /* = unique type id SOAP_TYPE___trt__SetMetadataConfiguration */
	         __trt__SetMetadataConfiguration();
	friend SOAP_FMAC1 __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70077 */
#ifndef SOAP_TYPE___trt__SetAudioOutputConfiguration
#define SOAP_TYPE___trt__SetAudioOutputConfiguration (3558)
/* Operation wrapper: */
struct __trt__SetAudioOutputConfiguration
{
public:
	_trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration;	/* optional element of XSD type trt:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 3558; } /* = unique type id SOAP_TYPE___trt__SetAudioOutputConfiguration */
	         __trt__SetAudioOutputConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70146 */
#ifndef SOAP_TYPE___trt__SetAudioDecoderConfiguration
#define SOAP_TYPE___trt__SetAudioDecoderConfiguration (3562)
/* Operation wrapper: */
struct __trt__SetAudioDecoderConfiguration
{
public:
	_trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration;	/* optional element of XSD type trt:SetAudioDecoderConfiguration */
public:
	int soap_type() const { return 3562; } /* = unique type id SOAP_TYPE___trt__SetAudioDecoderConfiguration */
	         __trt__SetAudioDecoderConfiguration();
	friend SOAP_FMAC1 __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70219 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___trt__GetVideoSourceConfigurationOptions (3566)
/* Operation wrapper: */
struct __trt__GetVideoSourceConfigurationOptions
{
public:
	_trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions;	/* optional element of XSD type trt:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 3566; } /* = unique type id SOAP_TYPE___trt__GetVideoSourceConfigurationOptions */
	         __trt__GetVideoSourceConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70289 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions (3570)
/* Operation wrapper: */
struct __trt__GetVideoEncoderConfigurationOptions
{
public:
	_trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions;	/* optional element of XSD type trt:GetVideoEncoderConfigurationOptions */
public:
	int soap_type() const { return 3570; } /* = unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions */
	         __trt__GetVideoEncoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70362 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___trt__GetAudioSourceConfigurationOptions (3574)
/* Operation wrapper: */
struct __trt__GetAudioSourceConfigurationOptions
{
public:
	_trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions;	/* optional element of XSD type trt:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 3574; } /* = unique type id SOAP_TYPE___trt__GetAudioSourceConfigurationOptions */
	         __trt__GetAudioSourceConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70431 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions (3578)
/* Operation wrapper: */
struct __trt__GetAudioEncoderConfigurationOptions
{
public:
	_trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioEncoderConfigurationOptions */
public:
	int soap_type() const { return 3578; } /* = unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions */
	         __trt__GetAudioEncoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70499 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurationOptions
#define SOAP_TYPE___trt__GetMetadataConfigurationOptions (3582)
/* Operation wrapper: */
struct __trt__GetMetadataConfigurationOptions
{
public:
	_trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions;	/* optional element of XSD type trt:GetMetadataConfigurationOptions */
public:
	int soap_type() const { return 3582; } /* = unique type id SOAP_TYPE___trt__GetMetadataConfigurationOptions */
	         __trt__GetMetadataConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70567 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___trt__GetAudioOutputConfigurationOptions (3586)
/* Operation wrapper: */
struct __trt__GetAudioOutputConfigurationOptions
{
public:
	_trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions;	/* optional element of XSD type trt:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 3586; } /* = unique type id SOAP_TYPE___trt__GetAudioOutputConfigurationOptions */
	         __trt__GetAudioOutputConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70636 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions (3590)
/* Operation wrapper: */
struct __trt__GetAudioDecoderConfigurationOptions
{
public:
	_trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions;	/* optional element of XSD type trt:GetAudioDecoderConfigurationOptions */
public:
	int soap_type() const { return 3590; } /* = unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions */
	         __trt__GetAudioDecoderConfigurationOptions();
	friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70705 */
#ifndef SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances (3594)
/* Operation wrapper: */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	_trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* optional element of XSD type trt:GetGuaranteedNumberOfVideoEncoderInstances */
public:
	int soap_type() const { return 3594; } /* = unique type id SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances */
	         __trt__GetGuaranteedNumberOfVideoEncoderInstances();
	friend SOAP_FMAC1 __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70778 */
#ifndef SOAP_TYPE___trt__GetStreamUri
#define SOAP_TYPE___trt__GetStreamUri (3598)
/* Operation wrapper: */
struct __trt__GetStreamUri
{
public:
	_trt__GetStreamUri *trt__GetStreamUri;	/* optional element of XSD type trt:GetStreamUri */
public:
	int soap_type() const { return 3598; } /* = unique type id SOAP_TYPE___trt__GetStreamUri */
	         __trt__GetStreamUri();
	friend SOAP_FMAC1 __trt__GetStreamUri * SOAP_FMAC2 soap_instantiate___trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70852 */
#ifndef SOAP_TYPE___trt__StartMulticastStreaming
#define SOAP_TYPE___trt__StartMulticastStreaming (3602)
/* Operation wrapper: */
struct __trt__StartMulticastStreaming
{
public:
	_trt__StartMulticastStreaming *trt__StartMulticastStreaming;	/* optional element of XSD type trt:StartMulticastStreaming */
public:
	int soap_type() const { return 3602; } /* = unique type id SOAP_TYPE___trt__StartMulticastStreaming */
	         __trt__StartMulticastStreaming();
	friend SOAP_FMAC1 __trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:70919 */
#ifndef SOAP_TYPE___trt__StopMulticastStreaming
#define SOAP_TYPE___trt__StopMulticastStreaming (3606)
/* Operation wrapper: */
struct __trt__StopMulticastStreaming
{
public:
	_trt__StopMulticastStreaming *trt__StopMulticastStreaming;	/* optional element of XSD type trt:StopMulticastStreaming */
public:
	int soap_type() const { return 3606; } /* = unique type id SOAP_TYPE___trt__StopMulticastStreaming */
	         __trt__StopMulticastStreaming();
	friend SOAP_FMAC1 __trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71003 */
#ifndef SOAP_TYPE___trt__SetSynchronizationPoint
#define SOAP_TYPE___trt__SetSynchronizationPoint (3610)
/* Operation wrapper: */
struct __trt__SetSynchronizationPoint
{
public:
	_trt__SetSynchronizationPoint *trt__SetSynchronizationPoint;	/* optional element of XSD type trt:SetSynchronizationPoint */
public:
	int soap_type() const { return 3610; } /* = unique type id SOAP_TYPE___trt__SetSynchronizationPoint */
	         __trt__SetSynchronizationPoint();
	friend SOAP_FMAC1 __trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71080 */
#ifndef SOAP_TYPE___trt__GetSnapshotUri
#define SOAP_TYPE___trt__GetSnapshotUri (3614)
/* Operation wrapper: */
struct __trt__GetSnapshotUri
{
public:
	_trt__GetSnapshotUri *trt__GetSnapshotUri;	/* optional element of XSD type trt:GetSnapshotUri */
public:
	int soap_type() const { return 3614; } /* = unique type id SOAP_TYPE___trt__GetSnapshotUri */
	         __trt__GetSnapshotUri();
	friend SOAP_FMAC1 __trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71166 */
#ifndef SOAP_TYPE___trv__GetServiceCapabilities
#define SOAP_TYPE___trv__GetServiceCapabilities (3618)
/* Operation wrapper: */
struct __trv__GetServiceCapabilities
{
public:
	_trv__GetServiceCapabilities *trv__GetServiceCapabilities;	/* optional element of XSD type trv:GetServiceCapabilities */
public:
	int soap_type() const { return 3618; } /* = unique type id SOAP_TYPE___trv__GetServiceCapabilities */
	         __trv__GetServiceCapabilities();
	friend SOAP_FMAC1 __trv__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trv__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71236 */
#ifndef SOAP_TYPE___trv__GetReceivers
#define SOAP_TYPE___trv__GetReceivers (3622)
/* Operation wrapper: */
struct __trv__GetReceivers
{
public:
	_trv__GetReceivers *trv__GetReceivers;	/* optional element of XSD type trv:GetReceivers */
public:
	int soap_type() const { return 3622; } /* = unique type id SOAP_TYPE___trv__GetReceivers */
	         __trv__GetReceivers();
	friend SOAP_FMAC1 __trv__GetReceivers * SOAP_FMAC2 soap_instantiate___trv__GetReceivers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71306 */
#ifndef SOAP_TYPE___trv__GetReceiver
#define SOAP_TYPE___trv__GetReceiver (3626)
/* Operation wrapper: */
struct __trv__GetReceiver
{
public:
	_trv__GetReceiver *trv__GetReceiver;	/* optional element of XSD type trv:GetReceiver */
public:
	int soap_type() const { return 3626; } /* = unique type id SOAP_TYPE___trv__GetReceiver */
	         __trv__GetReceiver();
	friend SOAP_FMAC1 __trv__GetReceiver * SOAP_FMAC2 soap_instantiate___trv__GetReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71377 */
#ifndef SOAP_TYPE___trv__CreateReceiver
#define SOAP_TYPE___trv__CreateReceiver (3630)
/* Operation wrapper: */
struct __trv__CreateReceiver
{
public:
	_trv__CreateReceiver *trv__CreateReceiver;	/* optional element of XSD type trv:CreateReceiver */
public:
	int soap_type() const { return 3630; } /* = unique type id SOAP_TYPE___trv__CreateReceiver */
	         __trv__CreateReceiver();
	friend SOAP_FMAC1 __trv__CreateReceiver * SOAP_FMAC2 soap_instantiate___trv__CreateReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71449 */
#ifndef SOAP_TYPE___trv__DeleteReceiver
#define SOAP_TYPE___trv__DeleteReceiver (3634)
/* Operation wrapper: */
struct __trv__DeleteReceiver
{
public:
	_trv__DeleteReceiver *trv__DeleteReceiver;	/* optional element of XSD type trv:DeleteReceiver */
public:
	int soap_type() const { return 3634; } /* = unique type id SOAP_TYPE___trv__DeleteReceiver */
	         __trv__DeleteReceiver();
	friend SOAP_FMAC1 __trv__DeleteReceiver * SOAP_FMAC2 soap_instantiate___trv__DeleteReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71519 */
#ifndef SOAP_TYPE___trv__ConfigureReceiver
#define SOAP_TYPE___trv__ConfigureReceiver (3638)
/* Operation wrapper: */
struct __trv__ConfigureReceiver
{
public:
	_trv__ConfigureReceiver *trv__ConfigureReceiver;	/* optional element of XSD type trv:ConfigureReceiver */
public:
	int soap_type() const { return 3638; } /* = unique type id SOAP_TYPE___trv__ConfigureReceiver */
	         __trv__ConfigureReceiver();
	friend SOAP_FMAC1 __trv__ConfigureReceiver * SOAP_FMAC2 soap_instantiate___trv__ConfigureReceiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71590 */
#ifndef SOAP_TYPE___trv__SetReceiverMode
#define SOAP_TYPE___trv__SetReceiverMode (3642)
/* Operation wrapper: */
struct __trv__SetReceiverMode
{
public:
	_trv__SetReceiverMode *trv__SetReceiverMode;	/* optional element of XSD type trv:SetReceiverMode */
public:
	int soap_type() const { return 3642; } /* = unique type id SOAP_TYPE___trv__SetReceiverMode */
	         __trv__SetReceiverMode();
	friend SOAP_FMAC1 __trv__SetReceiverMode * SOAP_FMAC2 soap_instantiate___trv__SetReceiverMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71662 */
#ifndef SOAP_TYPE___trv__GetReceiverState
#define SOAP_TYPE___trv__GetReceiverState (3646)
/* Operation wrapper: */
struct __trv__GetReceiverState
{
public:
	_trv__GetReceiverState *trv__GetReceiverState;	/* optional element of XSD type trv:GetReceiverState */
public:
	int soap_type() const { return 3646; } /* = unique type id SOAP_TYPE___trv__GetReceiverState */
	         __trv__GetReceiverState();
	friend SOAP_FMAC1 __trv__GetReceiverState * SOAP_FMAC2 soap_instantiate___trv__GetReceiverState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71748 */
#ifndef SOAP_TYPE___tse__GetServiceCapabilities
#define SOAP_TYPE___tse__GetServiceCapabilities (3650)
/* Operation wrapper: */
struct __tse__GetServiceCapabilities
{
public:
	_tse__GetServiceCapabilities *tse__GetServiceCapabilities;	/* optional element of XSD type tse:GetServiceCapabilities */
public:
	int soap_type() const { return 3650; } /* = unique type id SOAP_TYPE___tse__GetServiceCapabilities */
	         __tse__GetServiceCapabilities();
	friend SOAP_FMAC1 __tse__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tse__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71817 */
#ifndef SOAP_TYPE___tse__GetRecordingSummary
#define SOAP_TYPE___tse__GetRecordingSummary (3654)
/* Operation wrapper: */
struct __tse__GetRecordingSummary
{
public:
	_tse__GetRecordingSummary *tse__GetRecordingSummary;	/* optional element of XSD type tse:GetRecordingSummary */
public:
	int soap_type() const { return 3654; } /* = unique type id SOAP_TYPE___tse__GetRecordingSummary */
	         __tse__GetRecordingSummary();
	friend SOAP_FMAC1 __tse__GetRecordingSummary * SOAP_FMAC2 soap_instantiate___tse__GetRecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71887 */
#ifndef SOAP_TYPE___tse__GetRecordingInformation
#define SOAP_TYPE___tse__GetRecordingInformation (3658)
/* Operation wrapper: */
struct __tse__GetRecordingInformation
{
public:
	_tse__GetRecordingInformation *tse__GetRecordingInformation;	/* optional element of XSD type tse:GetRecordingInformation */
public:
	int soap_type() const { return 3658; } /* = unique type id SOAP_TYPE___tse__GetRecordingInformation */
	         __tse__GetRecordingInformation();
	friend SOAP_FMAC1 __tse__GetRecordingInformation * SOAP_FMAC2 soap_instantiate___tse__GetRecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:71964 */
#ifndef SOAP_TYPE___tse__GetMediaAttributes
#define SOAP_TYPE___tse__GetMediaAttributes (3662)
/* Operation wrapper: */
struct __tse__GetMediaAttributes
{
public:
	_tse__GetMediaAttributes *tse__GetMediaAttributes;	/* optional element of XSD type tse:GetMediaAttributes */
public:
	int soap_type() const { return 3662; } /* = unique type id SOAP_TYPE___tse__GetMediaAttributes */
	         __tse__GetMediaAttributes();
	friend SOAP_FMAC1 __tse__GetMediaAttributes * SOAP_FMAC2 soap_instantiate___tse__GetMediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72038 */
#ifndef SOAP_TYPE___tse__FindRecordings
#define SOAP_TYPE___tse__FindRecordings (3666)
/* Operation wrapper: */
struct __tse__FindRecordings
{
public:
	_tse__FindRecordings *tse__FindRecordings;	/* optional element of XSD type tse:FindRecordings */
public:
	int soap_type() const { return 3666; } /* = unique type id SOAP_TYPE___tse__FindRecordings */
	         __tse__FindRecordings();
	friend SOAP_FMAC1 __tse__FindRecordings * SOAP_FMAC2 soap_instantiate___tse__FindRecordings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72113 */
#ifndef SOAP_TYPE___tse__GetRecordingSearchResults
#define SOAP_TYPE___tse__GetRecordingSearchResults (3670)
/* Operation wrapper: */
struct __tse__GetRecordingSearchResults
{
public:
	_tse__GetRecordingSearchResults *tse__GetRecordingSearchResults;	/* optional element of XSD type tse:GetRecordingSearchResults */
public:
	int soap_type() const { return 3670; } /* = unique type id SOAP_TYPE___tse__GetRecordingSearchResults */
	         __tse__GetRecordingSearchResults();
	friend SOAP_FMAC1 __tse__GetRecordingSearchResults * SOAP_FMAC2 soap_instantiate___tse__GetRecordingSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72186 */
#ifndef SOAP_TYPE___tse__FindEvents
#define SOAP_TYPE___tse__FindEvents (3674)
/* Operation wrapper: */
struct __tse__FindEvents
{
public:
	_tse__FindEvents *tse__FindEvents;	/* optional element of XSD type tse:FindEvents */
public:
	int soap_type() const { return 3674; } /* = unique type id SOAP_TYPE___tse__FindEvents */
	         __tse__FindEvents();
	friend SOAP_FMAC1 __tse__FindEvents * SOAP_FMAC2 soap_instantiate___tse__FindEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72259 */
#ifndef SOAP_TYPE___tse__GetEventSearchResults
#define SOAP_TYPE___tse__GetEventSearchResults (3678)
/* Operation wrapper: */
struct __tse__GetEventSearchResults
{
public:
	_tse__GetEventSearchResults *tse__GetEventSearchResults;	/* optional element of XSD type tse:GetEventSearchResults */
public:
	int soap_type() const { return 3678; } /* = unique type id SOAP_TYPE___tse__GetEventSearchResults */
	         __tse__GetEventSearchResults();
	friend SOAP_FMAC1 __tse__GetEventSearchResults * SOAP_FMAC2 soap_instantiate___tse__GetEventSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72332 */
#ifndef SOAP_TYPE___tse__FindPTZPosition
#define SOAP_TYPE___tse__FindPTZPosition (3682)
/* Operation wrapper: */
struct __tse__FindPTZPosition
{
public:
	_tse__FindPTZPosition *tse__FindPTZPosition;	/* optional element of XSD type tse:FindPTZPosition */
public:
	int soap_type() const { return 3682; } /* = unique type id SOAP_TYPE___tse__FindPTZPosition */
	         __tse__FindPTZPosition();
	friend SOAP_FMAC1 __tse__FindPTZPosition * SOAP_FMAC2 soap_instantiate___tse__FindPTZPosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72405 */
#ifndef SOAP_TYPE___tse__GetPTZPositionSearchResults
#define SOAP_TYPE___tse__GetPTZPositionSearchResults (3686)
/* Operation wrapper: */
struct __tse__GetPTZPositionSearchResults
{
public:
	_tse__GetPTZPositionSearchResults *tse__GetPTZPositionSearchResults;	/* optional element of XSD type tse:GetPTZPositionSearchResults */
public:
	int soap_type() const { return 3686; } /* = unique type id SOAP_TYPE___tse__GetPTZPositionSearchResults */
	         __tse__GetPTZPositionSearchResults();
	friend SOAP_FMAC1 __tse__GetPTZPositionSearchResults * SOAP_FMAC2 soap_instantiate___tse__GetPTZPositionSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72476 */
#ifndef SOAP_TYPE___tse__GetSearchState
#define SOAP_TYPE___tse__GetSearchState (3690)
/* Operation wrapper: */
struct __tse__GetSearchState
{
public:
	_tse__GetSearchState *tse__GetSearchState;	/* optional element of XSD type tse:GetSearchState */
public:
	int soap_type() const { return 3690; } /* = unique type id SOAP_TYPE___tse__GetSearchState */
	         __tse__GetSearchState();
	friend SOAP_FMAC1 __tse__GetSearchState * SOAP_FMAC2 soap_instantiate___tse__GetSearchState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72553 */
#ifndef SOAP_TYPE___tse__EndSearch
#define SOAP_TYPE___tse__EndSearch (3694)
/* Operation wrapper: */
struct __tse__EndSearch
{
public:
	_tse__EndSearch *tse__EndSearch;	/* optional element of XSD type tse:EndSearch */
public:
	int soap_type() const { return 3694; } /* = unique type id SOAP_TYPE___tse__EndSearch */
	         __tse__EndSearch();
	friend SOAP_FMAC1 __tse__EndSearch * SOAP_FMAC2 soap_instantiate___tse__EndSearch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72626 */
#ifndef SOAP_TYPE___tse__FindMetadata
#define SOAP_TYPE___tse__FindMetadata (3698)
/* Operation wrapper: */
struct __tse__FindMetadata
{
public:
	_tse__FindMetadata *tse__FindMetadata;	/* optional element of XSD type tse:FindMetadata */
public:
	int soap_type() const { return 3698; } /* = unique type id SOAP_TYPE___tse__FindMetadata */
	         __tse__FindMetadata();
	friend SOAP_FMAC1 __tse__FindMetadata * SOAP_FMAC2 soap_instantiate___tse__FindMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../wsdl/onvif.h:72698 */
#ifndef SOAP_TYPE___tse__GetMetadataSearchResults
#define SOAP_TYPE___tse__GetMetadataSearchResults (3702)
/* Operation wrapper: */
struct __tse__GetMetadataSearchResults
{
public:
	_tse__GetMetadataSearchResults *tse__GetMetadataSearchResults;	/* optional element of XSD type tse:GetMetadataSearchResults */
public:
	int soap_type() const { return 3702; } /* = unique type id SOAP_TYPE___tse__GetMetadataSearchResults */
	         __tse__GetMetadataSearchResults();
	friend SOAP_FMAC1 __tse__GetMetadataSearchResults * SOAP_FMAC2 soap_instantiate___tse__GetMetadataSearchResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* wsdd10.h:18 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* wsdd10.h:18 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* wsa.h:220 */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (19)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

/* wsa.h:223 */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (20)
typedef char *_wsa__MessageID;
#endif

/* wsa.h:226 */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (21)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

/* wsa.h:229 */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (22)
typedef char *_wsa__To;
#endif

/* wsa.h:232 */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (23)
typedef char *_wsa__Action;
#endif

/* wsa.h:235 */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (24)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

/* wsa.h:238 */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (25)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

/* wsa.h:241 */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (26)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

/* wsa.h:244 */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (28)
typedef unsigned int _wsa__ReplyAfter;
#endif

/* wsdd10.h:101 */
#ifndef SOAP_TYPE_wsdd__QNameListType
#define SOAP_TYPE_wsdd__QNameListType (55)
typedef _QName wsdd__QNameListType;
#endif

/* wsdd10.h:104 */
#ifndef SOAP_TYPE_wsdd__UriListType
#define SOAP_TYPE_wsdd__UriListType (56)
typedef char *wsdd__UriListType;
#endif

/* wsdd10.h:107 */
#ifndef SOAP_TYPE_wsdd__FaultCodeOpenType
#define SOAP_TYPE_wsdd__FaultCodeOpenType (57)
typedef char *wsdd__FaultCodeOpenType;
#endif

/* wsa5.h:87 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (91)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:90 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (92)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:209 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (98)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:212 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (99)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:215 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (100)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:218 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (101)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:221 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (102)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:224 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (103)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:227 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (104)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:230 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (105)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:233 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (106)
typedef char *_wsa5__To;
#endif

/* wsa5.h:236 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (107)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:239 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (109)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:242 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (110)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:245 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (111)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:248 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (112)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* ../../wsdl/onvif.h:292 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (132)
typedef char *xsd__NCName;
#endif

/* ../../wsdl/onvif.h:309 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (135)
typedef char *xsd__anySimpleType;
#endif

/* ../../wsdl/onvif.h:319 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (137)
typedef char *xsd__anyURI;
#endif

/* ../../wsdl/onvif.h:378 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (149)
typedef char *xsd__integer;
#endif

/* ../../wsdl/onvif.h:388 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (151)
typedef char *xsd__nonNegativeInteger;
#endif

/* ../../wsdl/onvif.h:398 */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (153)
typedef char *xsd__positiveInteger;
#endif

/* ../../wsdl/onvif.h:415 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (156)
typedef char *xsd__token;
#endif

/* ../../wsdl/onvif.h:433 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (159)
typedef char *_xml__lang;
#endif

/* ../../wsdl/onvif.h:4179 */
#ifndef SOAP_TYPE_tmd__DelayTimes
#define SOAP_TYPE_tmd__DelayTimes (1402)
typedef char *tmd__DelayTimes;
#endif

/* ../../wsdl/onvif.h:4199 */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (1403)
typedef char *tt__IntAttrList;
#endif

/* ../../wsdl/onvif.h:4203 */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (1404)
typedef char *tt__FloatAttrList;
#endif

/* ../../wsdl/onvif.h:4207 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (1405)
typedef char *tt__StringAttrList;
#endif

/* ../../wsdl/onvif.h:4218 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (1406)
typedef char *wsnt__AbsoluteOrRelativeTimeType;
#endif

/* ../../wsdl/onvif.h:4246 */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (1407)
typedef char *tds__EAPMethodTypes;
#endif

/* ../../wsdl/onvif.h:4322 */
#ifndef SOAP_TYPE_trc__EncodingTypes
#define SOAP_TYPE_trc__EncodingTypes (1408)
typedef char *trc__EncodingTypes;
#endif

/* ../../wsdl/onvif.h:4466 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (1413)
typedef char *tt__ReferenceToken;
#endif

/* ../../wsdl/onvif.h:4481 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (1415)
typedef char *tt__Name;
#endif

/* ../../wsdl/onvif.h:4644 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (1435)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* ../../wsdl/onvif.h:4674 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (1439)
typedef int tt__IANA_IfTypes;
#endif

/* ../../wsdl/onvif.h:4737 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (1447)
typedef xsd__token tt__IPv4Address;
#endif

/* ../../wsdl/onvif.h:4748 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (1449)
typedef xsd__token tt__IPv6Address;
#endif

/* ../../wsdl/onvif.h:4759 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (1451)
typedef xsd__token tt__HwAddress;
#endif

/* ../../wsdl/onvif.h:4786 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (1455)
typedef xsd__token tt__DNSName;
#endif

/* ../../wsdl/onvif.h:4797 */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (1457)
typedef xsd__token tt__Domain;
#endif

/* ../../wsdl/onvif.h:4842 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (1463)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* ../../wsdl/onvif.h:4908 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (1471)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* ../../wsdl/onvif.h:4920 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (1473)
typedef char *tt__Dot11PSKPassphrase;
#endif

/* ../../wsdl/onvif.h:5165 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (1499)
typedef char *tt__AuxiliaryData;
#endif

/* ../../wsdl/onvif.h:5402 */
#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (1527)
typedef xsd__anyURI tt__TopicNamespaceLocation;
#endif

/* ../../wsdl/onvif.h:5532 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (1539)
typedef char *tt__Description;
#endif

/* ../../wsdl/onvif.h:5543 */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (1541)
typedef char *tt__XPathExpression;
#endif

/* ../../wsdl/onvif.h:5628 */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (1549)
typedef char *tt__RecordingJobMode;
#endif

/* ../../wsdl/onvif.h:5639 */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (1551)
typedef char *tt__RecordingJobState;
#endif

/* ../../wsdl/onvif.h:5698 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (1555)
typedef char *wstop__FullTopicExpression;
#endif

/* ../../wsdl/onvif.h:5714 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1557)
typedef char *wstop__ConcreteTopicExpression;
#endif

/* ../../wsdl/onvif.h:5729 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (1559)
typedef _QName wstop__SimpleTopicExpression;
#endif

/* ../../wsdl/onvif.h:6047 */
#ifndef SOAP_TYPE_ns3__ReferenceToken
#define SOAP_TYPE_ns3__ReferenceToken (1575)
typedef char *ns3__ReferenceToken;
#endif

/* ../../wsdl/onvif.h:6062 */
#ifndef SOAP_TYPE_ns3__Name
#define SOAP_TYPE_ns3__Name (1577)
typedef char *ns3__Name;
#endif

/* ../../wsdl/onvif.h:6079 */
#ifndef SOAP_TYPE_ns3__Description
#define SOAP_TYPE_ns3__Description (1579)
typedef char *ns3__Description;
#endif

/* ../../wsdl/onvif.h:6300 */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (1593)
typedef tt__ReferenceToken tt__ReceiverReference;
#endif

/* ../../wsdl/onvif.h:6311 */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (1595)
typedef tt__ReferenceToken tt__RecordingReference;
#endif

/* ../../wsdl/onvif.h:6322 */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (1597)
typedef tt__ReferenceToken tt__TrackReference;
#endif

/* ../../wsdl/onvif.h:6333 */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (1599)
typedef tt__ReferenceToken tt__JobToken;
#endif

/* ../../wsdl/onvif.h:6344 */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (1601)
typedef tt__ReferenceToken tt__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 SOAP_ENV__Fault(struct soap*, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Hello(struct soap*, struct wsdd__HelloType *wsdd__Hello);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Bye(struct soap*, struct wsdd__ByeType *wsdd__Bye);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Probe(struct soap*, struct wsdd__ProbeType *wsdd__Probe);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__ProbeMatches(struct soap*, struct wsdd__ProbeMatchesType *wsdd__ProbeMatches);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__Resolve(struct soap*, struct wsdd__ResolveType *wsdd__Resolve);

SOAP_FMAC5 int SOAP_FMAC6 __wsdd__ResolveMatches(struct soap*, struct wsdd__ResolveMatchesType *wsdd__ResolveMatches);

SOAP_FMAC5 int SOAP_FMAC6 SOAP_ENV__Fault_yz(struct soap*, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSupportedActions(struct soap*, _ns1__GetSupportedActions *ns1__GetSupportedActions, _ns1__GetSupportedActionsResponse &ns1__GetSupportedActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetActions(struct soap*, _ns1__GetActions *ns1__GetActions, _ns1__GetActionsResponse &ns1__GetActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__CreateActions(struct soap*, _ns1__CreateActions *ns1__CreateActions, _ns1__CreateActionsResponse &ns1__CreateActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__DeleteActions(struct soap*, _ns1__DeleteActions *ns1__DeleteActions, _ns1__DeleteActionsResponse &ns1__DeleteActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__ModifyActions(struct soap*, _ns1__ModifyActions *ns1__ModifyActions, _ns1__ModifyActionsResponse &ns1__ModifyActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetServiceCapabilities(struct soap*, _ns1__GetServiceCapabilities *ns1__GetServiceCapabilities, _ns1__GetServiceCapabilitiesResponse &ns1__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetActionTriggers(struct soap*, _ns1__GetActionTriggers *ns1__GetActionTriggers, _ns1__GetActionTriggersResponse &ns1__GetActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__CreateActionTriggers(struct soap*, _ns1__CreateActionTriggers *ns1__CreateActionTriggers, _ns1__CreateActionTriggersResponse &ns1__CreateActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__DeleteActionTriggers(struct soap*, _ns1__DeleteActionTriggers *ns1__DeleteActionTriggers, _ns1__DeleteActionTriggersResponse &ns1__DeleteActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__ModifyActionTriggers(struct soap*, _ns1__ModifyActionTriggers *ns1__ModifyActionTriggers, _ns1__ModifyActionTriggersResponse &ns1__ModifyActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetServiceCapabilities(struct soap*, _ns2__GetServiceCapabilities *ns2__GetServiceCapabilities, _ns2__GetServiceCapabilitiesResponse &ns2__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetAccessPointInfoList(struct soap*, _ns2__GetAccessPointInfoList *ns2__GetAccessPointInfoList, _ns2__GetAccessPointInfoListResponse &ns2__GetAccessPointInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetAccessPointInfo(struct soap*, _ns2__GetAccessPointInfo *ns2__GetAccessPointInfo, _ns2__GetAccessPointInfoResponse &ns2__GetAccessPointInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetAreaInfoList(struct soap*, _ns2__GetAreaInfoList *ns2__GetAreaInfoList, _ns2__GetAreaInfoListResponse &ns2__GetAreaInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetAreaInfo(struct soap*, _ns2__GetAreaInfo *ns2__GetAreaInfo, _ns2__GetAreaInfoResponse &ns2__GetAreaInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__GetAccessPointState(struct soap*, _ns2__GetAccessPointState *ns2__GetAccessPointState, _ns2__GetAccessPointStateResponse &ns2__GetAccessPointStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__EnableAccessPoint(struct soap*, _ns2__EnableAccessPoint *ns2__EnableAccessPoint, _ns2__EnableAccessPointResponse &ns2__EnableAccessPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__DisableAccessPoint(struct soap*, _ns2__DisableAccessPoint *ns2__DisableAccessPoint, _ns2__DisableAccessPointResponse &ns2__DisableAccessPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns2__ExternalAuthorization(struct soap*, _ns2__ExternalAuthorization *ns2__ExternalAuthorization, _ns2__ExternalAuthorizationResponse &ns2__ExternalAuthorizationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__GetServiceCapabilities(struct soap*, _ns4__GetServiceCapabilities *ns4__GetServiceCapabilities, _ns4__GetServiceCapabilitiesResponse &ns4__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__GetDoorInfoList(struct soap*, _ns4__GetDoorInfoList *ns4__GetDoorInfoList, _ns4__GetDoorInfoListResponse &ns4__GetDoorInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__GetDoorInfo(struct soap*, _ns4__GetDoorInfo *ns4__GetDoorInfo, _ns4__GetDoorInfoResponse &ns4__GetDoorInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__GetDoorState(struct soap*, _ns4__GetDoorState *ns4__GetDoorState, _ns4__GetDoorStateResponse &ns4__GetDoorStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__AccessDoor(struct soap*, _ns4__AccessDoor *ns4__AccessDoor, _ns4__AccessDoorResponse &ns4__AccessDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__LockDoor(struct soap*, _ns4__LockDoor *ns4__LockDoor, _ns4__LockDoorResponse &ns4__LockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__UnlockDoor(struct soap*, _ns4__UnlockDoor *ns4__UnlockDoor, _ns4__UnlockDoorResponse &ns4__UnlockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__BlockDoor(struct soap*, _ns4__BlockDoor *ns4__BlockDoor, _ns4__BlockDoorResponse &ns4__BlockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__LockDownDoor(struct soap*, _ns4__LockDownDoor *ns4__LockDownDoor, _ns4__LockDownDoorResponse &ns4__LockDownDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__LockDownReleaseDoor(struct soap*, _ns4__LockDownReleaseDoor *ns4__LockDownReleaseDoor, _ns4__LockDownReleaseDoorResponse &ns4__LockDownReleaseDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__LockOpenDoor(struct soap*, _ns4__LockOpenDoor *ns4__LockOpenDoor, _ns4__LockOpenDoorResponse &ns4__LockOpenDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__LockOpenReleaseDoor(struct soap*, _ns4__LockOpenReleaseDoor *ns4__LockOpenReleaseDoor, _ns4__LockOpenReleaseDoorResponse &ns4__LockOpenReleaseDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns4__DoubleLockDoor(struct soap*, _ns4__DoubleLockDoor *ns4__DoubleLockDoor, _ns4__DoubleLockDoorResponse &ns4__DoubleLockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetServiceCapabilities(struct soap*, _tad__GetServiceCapabilities *tad__GetServiceCapabilities, _tad__GetServiceCapabilitiesResponse &tad__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__DeleteAnalyticsEngineControl(struct soap*, _tad__DeleteAnalyticsEngineControl *tad__DeleteAnalyticsEngineControl, _tad__DeleteAnalyticsEngineControlResponse &tad__DeleteAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__CreateAnalyticsEngineControl(struct soap*, _tad__CreateAnalyticsEngineControl *tad__CreateAnalyticsEngineControl, _tad__CreateAnalyticsEngineControlResponse &tad__CreateAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__SetAnalyticsEngineControl(struct soap*, _tad__SetAnalyticsEngineControl *tad__SetAnalyticsEngineControl, _tad__SetAnalyticsEngineControlResponse &tad__SetAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineControl(struct soap*, _tad__GetAnalyticsEngineControl *tad__GetAnalyticsEngineControl, _tad__GetAnalyticsEngineControlResponse &tad__GetAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineControls(struct soap*, _tad__GetAnalyticsEngineControls *tad__GetAnalyticsEngineControls, _tad__GetAnalyticsEngineControlsResponse &tad__GetAnalyticsEngineControlsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngine(struct soap*, _tad__GetAnalyticsEngine *tad__GetAnalyticsEngine, _tad__GetAnalyticsEngineResponse &tad__GetAnalyticsEngineResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngines(struct soap*, _tad__GetAnalyticsEngines *tad__GetAnalyticsEngines, _tad__GetAnalyticsEnginesResponse &tad__GetAnalyticsEnginesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__SetVideoAnalyticsConfiguration(struct soap*, _tad__SetVideoAnalyticsConfiguration *tad__SetVideoAnalyticsConfiguration, _tad__SetVideoAnalyticsConfigurationResponse &tad__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__SetAnalyticsEngineInput(struct soap*, _tad__SetAnalyticsEngineInput *tad__SetAnalyticsEngineInput, _tad__SetAnalyticsEngineInputResponse &tad__SetAnalyticsEngineInputResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineInput(struct soap*, _tad__GetAnalyticsEngineInput *tad__GetAnalyticsEngineInput, _tad__GetAnalyticsEngineInputResponse &tad__GetAnalyticsEngineInputResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsEngineInputs(struct soap*, _tad__GetAnalyticsEngineInputs *tad__GetAnalyticsEngineInputs, _tad__GetAnalyticsEngineInputsResponse &tad__GetAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsDeviceStreamUri(struct soap*, _tad__GetAnalyticsDeviceStreamUri *tad__GetAnalyticsDeviceStreamUri, _tad__GetAnalyticsDeviceStreamUriResponse &tad__GetAnalyticsDeviceStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetVideoAnalyticsConfiguration(struct soap*, _tad__GetVideoAnalyticsConfiguration *tad__GetVideoAnalyticsConfiguration, _tad__GetVideoAnalyticsConfigurationResponse &tad__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__CreateAnalyticsEngineInputs(struct soap*, _tad__CreateAnalyticsEngineInputs *tad__CreateAnalyticsEngineInputs, _tad__CreateAnalyticsEngineInputsResponse &tad__CreateAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__DeleteAnalyticsEngineInputs(struct soap*, _tad__DeleteAnalyticsEngineInputs *tad__DeleteAnalyticsEngineInputs, _tad__DeleteAnalyticsEngineInputsResponse &tad__DeleteAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tad__GetAnalyticsState(struct soap*, _tad__GetAnalyticsState *tad__GetAnalyticsState, _tad__GetAnalyticsStateResponse &tad__GetAnalyticsStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__GetSupportedRules(struct soap*, _tan__GetSupportedRules *tan__GetSupportedRules, _tan__GetSupportedRulesResponse &tan__GetSupportedRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__CreateRules(struct soap*, _tan__CreateRules *tan__CreateRules, _tan__CreateRulesResponse &tan__CreateRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__DeleteRules(struct soap*, _tan__DeleteRules *tan__DeleteRules, _tan__DeleteRulesResponse &tan__DeleteRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__GetRules(struct soap*, _tan__GetRules *tan__GetRules, _tan__GetRulesResponse &tan__GetRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__ModifyRules(struct soap*, _tan__ModifyRules *tan__ModifyRules, _tan__ModifyRulesResponse &tan__ModifyRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__GetServiceCapabilities(struct soap*, _tan__GetServiceCapabilities *tan__GetServiceCapabilities, _tan__GetServiceCapabilitiesResponse &tan__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__GetSupportedAnalyticsModules(struct soap*, _tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules, _tan__GetSupportedAnalyticsModulesResponse &tan__GetSupportedAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__CreateAnalyticsModules(struct soap*, _tan__CreateAnalyticsModules *tan__CreateAnalyticsModules, _tan__CreateAnalyticsModulesResponse &tan__CreateAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__DeleteAnalyticsModules(struct soap*, _tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules, _tan__DeleteAnalyticsModulesResponse &tan__DeleteAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__GetAnalyticsModules(struct soap*, _tan__GetAnalyticsModules *tan__GetAnalyticsModules, _tan__GetAnalyticsModulesResponse &tan__GetAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tan__ModifyAnalyticsModules(struct soap*, _tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules, _tan__ModifyAnalyticsModulesResponse &tan__ModifyAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tdn__Hello(struct soap*, struct wsdd__HelloType tdn__Hello, struct wsdd__ResolveType &tdn__HelloResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tdn__Bye(struct soap*, struct wsdd__ByeType tdn__Bye, struct wsdd__ResolveType &tdn__ByeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tdn__Probe(struct soap*, struct wsdd__ProbeType tdn__Probe, struct wsdd__ProbeMatchesType &tdn__ProbeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServices(struct soap*, _tds__GetServices *tds__GetServices, _tds__GetServicesResponse &tds__GetServicesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetServiceCapabilities(struct soap*, _tds__GetServiceCapabilities *tds__GetServiceCapabilities, _tds__GetServiceCapabilitiesResponse &tds__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDeviceInformation(struct soap*, _tds__GetDeviceInformation *tds__GetDeviceInformation, _tds__GetDeviceInformationResponse &tds__GetDeviceInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemDateAndTime(struct soap*, _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, _tds__SetSystemDateAndTimeResponse &tds__SetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemDateAndTime(struct soap*, _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, _tds__GetSystemDateAndTimeResponse &tds__GetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetSystemFactoryDefault(struct soap*, _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, _tds__SetSystemFactoryDefaultResponse &tds__SetSystemFactoryDefaultResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__UpgradeSystemFirmware(struct soap*, _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, _tds__UpgradeSystemFirmwareResponse &tds__UpgradeSystemFirmwareResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SystemReboot(struct soap*, _tds__SystemReboot *tds__SystemReboot, _tds__SystemRebootResponse &tds__SystemRebootResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RestoreSystem(struct soap*, _tds__RestoreSystem *tds__RestoreSystem, _tds__RestoreSystemResponse &tds__RestoreSystemResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemBackup(struct soap*, _tds__GetSystemBackup *tds__GetSystemBackup, _tds__GetSystemBackupResponse &tds__GetSystemBackupResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemLog(struct soap*, _tds__GetSystemLog *tds__GetSystemLog, _tds__GetSystemLogResponse &tds__GetSystemLogResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemSupportInformation(struct soap*, _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, _tds__GetSystemSupportInformationResponse &tds__GetSystemSupportInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetScopes(struct soap*, _tds__GetScopes *tds__GetScopes, _tds__GetScopesResponse &tds__GetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetScopes(struct soap*, _tds__SetScopes *tds__SetScopes, _tds__SetScopesResponse &tds__SetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__AddScopes(struct soap*, _tds__AddScopes *tds__AddScopes, _tds__AddScopesResponse &tds__AddScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveScopes(struct soap*, _tds__RemoveScopes *tds__RemoveScopes, _tds__RemoveScopesResponse &tds__RemoveScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDiscoveryMode(struct soap*, _tds__GetDiscoveryMode *tds__GetDiscoveryMode, _tds__GetDiscoveryModeResponse &tds__GetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDiscoveryMode(struct soap*, _tds__SetDiscoveryMode *tds__SetDiscoveryMode, _tds__SetDiscoveryModeResponse &tds__SetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteDiscoveryMode(struct soap*, _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, _tds__GetRemoteDiscoveryModeResponse &tds__GetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteDiscoveryMode(struct soap*, _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, _tds__SetRemoteDiscoveryModeResponse &tds__SetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDPAddresses(struct soap*, _tds__GetDPAddresses *tds__GetDPAddresses, _tds__GetDPAddressesResponse &tds__GetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetEndpointReference(struct soap*, _tds__GetEndpointReference *tds__GetEndpointReference, _tds__GetEndpointReferenceResponse &tds__GetEndpointReferenceResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRemoteUser(struct soap*, _tds__GetRemoteUser *tds__GetRemoteUser, _tds__GetRemoteUserResponse &tds__GetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRemoteUser(struct soap*, _tds__SetRemoteUser *tds__SetRemoteUser, _tds__SetRemoteUserResponse &tds__SetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetUsers(struct soap*, _tds__GetUsers *tds__GetUsers, _tds__GetUsersResponse &tds__GetUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateUsers(struct soap*, _tds__CreateUsers *tds__CreateUsers, _tds__CreateUsersResponse &tds__CreateUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteUsers(struct soap*, _tds__DeleteUsers *tds__DeleteUsers, _tds__DeleteUsersResponse &tds__DeleteUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetUser(struct soap*, _tds__SetUser *tds__SetUser, _tds__SetUserResponse &tds__SetUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetWsdlUrl(struct soap*, _tds__GetWsdlUrl *tds__GetWsdlUrl, _tds__GetWsdlUrlResponse &tds__GetWsdlUrlResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCapabilities(struct soap*, _tds__GetCapabilities *tds__GetCapabilities, _tds__GetCapabilitiesResponse &tds__GetCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDPAddresses(struct soap*, _tds__SetDPAddresses *tds__SetDPAddresses, _tds__SetDPAddressesResponse &tds__SetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetHostname(struct soap*, _tds__GetHostname *tds__GetHostname, _tds__GetHostnameResponse &tds__GetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostname(struct soap*, _tds__SetHostname *tds__SetHostname, _tds__SetHostnameResponse &tds__SetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetHostnameFromDHCP(struct soap*, _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP, _tds__SetHostnameFromDHCPResponse &tds__SetHostnameFromDHCPResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDNS(struct soap*, _tds__GetDNS *tds__GetDNS, _tds__GetDNSResponse &tds__GetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDNS(struct soap*, _tds__SetDNS *tds__SetDNS, _tds__SetDNSResponse &tds__SetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNTP(struct soap*, _tds__GetNTP *tds__GetNTP, _tds__GetNTPResponse &tds__GetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNTP(struct soap*, _tds__SetNTP *tds__SetNTP, _tds__SetNTPResponse &tds__SetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDynamicDNS(struct soap*, _tds__GetDynamicDNS *tds__GetDynamicDNS, _tds__GetDynamicDNSResponse &tds__GetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDynamicDNS(struct soap*, _tds__SetDynamicDNS *tds__SetDynamicDNS, _tds__SetDynamicDNSResponse &tds__SetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkInterfaces(struct soap*, _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, _tds__GetNetworkInterfacesResponse &tds__GetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkInterfaces(struct soap*, _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, _tds__SetNetworkInterfacesResponse &tds__SetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkProtocols(struct soap*, _tds__GetNetworkProtocols *tds__GetNetworkProtocols, _tds__GetNetworkProtocolsResponse &tds__GetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkProtocols(struct soap*, _tds__SetNetworkProtocols *tds__SetNetworkProtocols, _tds__SetNetworkProtocolsResponse &tds__SetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetNetworkDefaultGateway(struct soap*, _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, _tds__GetNetworkDefaultGatewayResponse &tds__GetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetNetworkDefaultGateway(struct soap*, _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, _tds__SetNetworkDefaultGatewayResponse &tds__SetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetZeroConfiguration(struct soap*, _tds__GetZeroConfiguration *tds__GetZeroConfiguration, _tds__GetZeroConfigurationResponse &tds__GetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetZeroConfiguration(struct soap*, _tds__SetZeroConfiguration *tds__SetZeroConfiguration, _tds__SetZeroConfigurationResponse &tds__SetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetIPAddressFilter(struct soap*, _tds__GetIPAddressFilter *tds__GetIPAddressFilter, _tds__GetIPAddressFilterResponse &tds__GetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetIPAddressFilter(struct soap*, _tds__SetIPAddressFilter *tds__SetIPAddressFilter, _tds__SetIPAddressFilterResponse &tds__SetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__AddIPAddressFilter(struct soap*, _tds__AddIPAddressFilter *tds__AddIPAddressFilter, _tds__AddIPAddressFilterResponse &tds__AddIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__RemoveIPAddressFilter(struct soap*, _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, _tds__RemoveIPAddressFilterResponse &tds__RemoveIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetAccessPolicy(struct soap*, _tds__GetAccessPolicy *tds__GetAccessPolicy, _tds__GetAccessPolicyResponse &tds__GetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetAccessPolicy(struct soap*, _tds__SetAccessPolicy *tds__SetAccessPolicy, _tds__SetAccessPolicyResponse &tds__SetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateCertificate(struct soap*, _tds__CreateCertificate *tds__CreateCertificate, _tds__CreateCertificateResponse &tds__CreateCertificateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificates(struct soap*, _tds__GetCertificates *tds__GetCertificates, _tds__GetCertificatesResponse &tds__GetCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificatesStatus(struct soap*, _tds__GetCertificatesStatus *tds__GetCertificatesStatus, _tds__GetCertificatesStatusResponse &tds__GetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetCertificatesStatus(struct soap*, _tds__SetCertificatesStatus *tds__SetCertificatesStatus, _tds__SetCertificatesStatusResponse &tds__SetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteCertificates(struct soap*, _tds__DeleteCertificates *tds__DeleteCertificates, _tds__DeleteCertificatesResponse &tds__DeleteCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetPkcs10Request(struct soap*, _tds__GetPkcs10Request *tds__GetPkcs10Request, _tds__GetPkcs10RequestResponse &tds__GetPkcs10RequestResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificates(struct soap*, _tds__LoadCertificates *tds__LoadCertificates, _tds__LoadCertificatesResponse &tds__LoadCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetClientCertificateMode(struct soap*, _tds__GetClientCertificateMode *tds__GetClientCertificateMode, _tds__GetClientCertificateModeResponse &tds__GetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetClientCertificateMode(struct soap*, _tds__SetClientCertificateMode *tds__SetClientCertificateMode, _tds__SetClientCertificateModeResponse &tds__SetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetRelayOutputs(struct soap*, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse &tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputSettings(struct soap*, _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, _tds__SetRelayOutputSettingsResponse &tds__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetRelayOutputState(struct soap*, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse &tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SendAuxiliaryCommand(struct soap*, _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand, _tds__SendAuxiliaryCommandResponse &tds__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCACertificates(struct soap*, _tds__GetCACertificates *tds__GetCACertificates, _tds__GetCACertificatesResponse &tds__GetCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCertificateWithPrivateKey(struct soap*, _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey, _tds__LoadCertificateWithPrivateKeyResponse &tds__LoadCertificateWithPrivateKeyResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetCertificateInformation(struct soap*, _tds__GetCertificateInformation *tds__GetCertificateInformation, _tds__GetCertificateInformationResponse &tds__GetCertificateInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__LoadCACertificates(struct soap*, _tds__LoadCACertificates *tds__LoadCACertificates, _tds__LoadCACertificatesResponse &tds__LoadCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__CreateDot1XConfiguration(struct soap*, _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration, _tds__CreateDot1XConfigurationResponse &tds__CreateDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__SetDot1XConfiguration(struct soap*, _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration, _tds__SetDot1XConfigurationResponse &tds__SetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfiguration(struct soap*, _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration, _tds__GetDot1XConfigurationResponse &tds__GetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot1XConfigurations(struct soap*, _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations, _tds__GetDot1XConfigurationsResponse &tds__GetDot1XConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__DeleteDot1XConfiguration(struct soap*, _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration, _tds__DeleteDot1XConfigurationResponse &tds__DeleteDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Capabilities(struct soap*, _tds__GetDot11Capabilities *tds__GetDot11Capabilities, _tds__GetDot11CapabilitiesResponse &tds__GetDot11CapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetDot11Status(struct soap*, _tds__GetDot11Status *tds__GetDot11Status, _tds__GetDot11StatusResponse &tds__GetDot11StatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__ScanAvailableDot11Networks(struct soap*, _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks, _tds__ScanAvailableDot11NetworksResponse &tds__ScanAvailableDot11NetworksResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__GetSystemUris(struct soap*, _tds__GetSystemUris *tds__GetSystemUris, _tds__GetSystemUrisResponse &tds__GetSystemUrisResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__StartFirmwareUpgrade(struct soap*, _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade, _tds__StartFirmwareUpgradeResponse &tds__StartFirmwareUpgradeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tds__StartSystemRestore(struct soap*, _tds__StartSystemRestore *tds__StartSystemRestore, _tds__StartSystemRestoreResponse &tds__StartSystemRestoreResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__PullMessages(struct soap*, _tev__PullMessages *tev__PullMessages, _tev__PullMessagesResponse &tev__PullMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Seek(struct soap*, _tev__Seek *tev__Seek, _tev__SeekResponse &tev__SeekResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__SetSynchronizationPoint(struct soap*, _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint, _tev__SetSynchronizationPointResponse &tev__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__GetServiceCapabilities(struct soap*, _tev__GetServiceCapabilities *tev__GetServiceCapabilities, _tev__GetServiceCapabilitiesResponse &tev__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__CreatePullPointSubscription(struct soap*, _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription, _tev__CreatePullPointSubscriptionResponse &tev__CreatePullPointSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__GetEventProperties(struct soap*, _tev__GetEventProperties *tev__GetEventProperties, _tev__GetEventPropertiesResponse &tev__GetEventPropertiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Renew(struct soap*, _wsnt__Renew *wsnt__Renew, _wsnt__RenewResponse &wsnt__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Unsubscribe(struct soap*, _wsnt__Unsubscribe *wsnt__Unsubscribe, _wsnt__UnsubscribeResponse &wsnt__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Subscribe(struct soap*, _wsnt__Subscribe *wsnt__Subscribe, _wsnt__SubscribeResponse &wsnt__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__GetCurrentMessage(struct soap*, _wsnt__GetCurrentMessage *wsnt__GetCurrentMessage, _wsnt__GetCurrentMessageResponse &wsnt__GetCurrentMessageResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Notify(struct soap*, _wsnt__Notify *wsnt__Notify);

SOAP_FMAC5 int SOAP_FMAC6 __tev__GetMessages(struct soap*, _wsnt__GetMessages *wsnt__GetMessages, _wsnt__GetMessagesResponse &wsnt__GetMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__DestroyPullPoint(struct soap*, _wsnt__DestroyPullPoint *wsnt__DestroyPullPoint, _wsnt__DestroyPullPointResponse &wsnt__DestroyPullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Notify_(struct soap*, _wsnt__Notify *wsnt__Notify);

SOAP_FMAC5 int SOAP_FMAC6 __tev__CreatePullPoint(struct soap*, _wsnt__CreatePullPoint *wsnt__CreatePullPoint, _wsnt__CreatePullPointResponse &wsnt__CreatePullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Renew_(struct soap*, _wsnt__Renew *wsnt__Renew, _wsnt__RenewResponse &wsnt__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__Unsubscribe_(struct soap*, _wsnt__Unsubscribe *wsnt__Unsubscribe, _wsnt__UnsubscribeResponse &wsnt__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__PauseSubscription(struct soap*, _wsnt__PauseSubscription *wsnt__PauseSubscription, _wsnt__PauseSubscriptionResponse &wsnt__PauseSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tev__ResumeSubscription(struct soap*, _wsnt__ResumeSubscription *wsnt__ResumeSubscription, _wsnt__ResumeSubscriptionResponse &wsnt__ResumeSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetServiceCapabilities(struct soap*, _timg__GetServiceCapabilities *timg__GetServiceCapabilities, _timg__GetServiceCapabilitiesResponse &timg__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetImagingSettings(struct soap*, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse &timg__GetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__SetImagingSettings(struct soap*, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse &timg__SetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetOptions(struct soap*, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse &timg__GetOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__Move(struct soap*, _timg__Move *timg__Move, _timg__MoveResponse &timg__MoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__Stop(struct soap*, _timg__Stop *timg__Stop, _timg__StopResponse &timg__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetStatus(struct soap*, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse &timg__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __timg__GetMoveOptions(struct soap*, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse &timg__GetMoveOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__GetServiceCapabilities(struct soap*, _tls__GetServiceCapabilities *tls__GetServiceCapabilities, _tls__GetServiceCapabilitiesResponse &tls__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__GetLayout(struct soap*, _tls__GetLayout *tls__GetLayout, _tls__GetLayoutResponse &tls__GetLayoutResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__SetLayout(struct soap*, _tls__SetLayout *tls__SetLayout, _tls__SetLayoutResponse &tls__SetLayoutResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__GetDisplayOptions(struct soap*, _tls__GetDisplayOptions *tls__GetDisplayOptions, _tls__GetDisplayOptionsResponse &tls__GetDisplayOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__GetPaneConfigurations(struct soap*, _tls__GetPaneConfigurations *tls__GetPaneConfigurations, _tls__GetPaneConfigurationsResponse &tls__GetPaneConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__GetPaneConfiguration(struct soap*, _tls__GetPaneConfiguration *tls__GetPaneConfiguration, _tls__GetPaneConfigurationResponse &tls__GetPaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__SetPaneConfigurations(struct soap*, _tls__SetPaneConfigurations *tls__SetPaneConfigurations, _tls__SetPaneConfigurationsResponse &tls__SetPaneConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__SetPaneConfiguration(struct soap*, _tls__SetPaneConfiguration *tls__SetPaneConfiguration, _tls__SetPaneConfigurationResponse &tls__SetPaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__CreatePaneConfiguration(struct soap*, _tls__CreatePaneConfiguration *tls__CreatePaneConfiguration, _tls__CreatePaneConfigurationResponse &tls__CreatePaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tls__DeletePaneConfiguration(struct soap*, _tls__DeletePaneConfiguration *tls__DeletePaneConfiguration, _tls__DeletePaneConfigurationResponse &tls__DeletePaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetServiceCapabilities(struct soap*, _tmd__GetServiceCapabilities *tmd__GetServiceCapabilities, _tmd__GetServiceCapabilitiesResponse &tmd__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetRelayOutputOptions(struct soap*, _tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions, _tmd__GetRelayOutputOptionsResponse &tmd__GetRelayOutputOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSources(struct soap*, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse &trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputs(struct soap*, _trt__GetAudioOutputs *trt__GetAudioOutputs, _trt__GetAudioOutputsResponse &trt__GetAudioOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSources(struct soap*, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse &trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputs(struct soap*, _tmd__GetVideoOutputs *tmd__GetVideoOutputs, _tmd__GetVideoOutputsResponse &tmd__GetVideoOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSourceConfiguration(struct soap*, _tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration, _tmd__GetVideoSourceConfigurationResponse &tmd__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputConfiguration(struct soap*, _tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration, _tmd__GetVideoOutputConfigurationResponse &tmd__GetVideoOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSourceConfiguration(struct soap*, _tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration, _tmd__GetAudioSourceConfigurationResponse &tmd__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputConfiguration(struct soap*, _tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration, _tmd__GetAudioOutputConfigurationResponse &tmd__GetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetVideoSourceConfiguration(struct soap*, _tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration, _tmd__SetVideoSourceConfigurationResponse &tmd__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetVideoOutputConfiguration(struct soap*, _tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration, _tmd__SetVideoOutputConfigurationResponse &tmd__SetVideoOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetAudioSourceConfiguration(struct soap*, _tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration, _tmd__SetAudioSourceConfigurationResponse &tmd__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetAudioOutputConfiguration(struct soap*, _tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration, _tmd__SetAudioOutputConfigurationResponse &tmd__SetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoSourceConfigurationOptions(struct soap*, _tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions, _tmd__GetVideoSourceConfigurationOptionsResponse &tmd__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetVideoOutputConfigurationOptions(struct soap*, _tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions, _tmd__GetVideoOutputConfigurationOptionsResponse &tmd__GetVideoOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioSourceConfigurationOptions(struct soap*, _tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions, _tmd__GetAudioSourceConfigurationOptionsResponse &tmd__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetAudioOutputConfigurationOptions(struct soap*, _tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions, _tmd__GetAudioOutputConfigurationOptionsResponse &tmd__GetAudioOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetRelayOutputs(struct soap*, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse &tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetRelayOutputSettings(struct soap*, _tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings, _tmd__SetRelayOutputSettingsResponse &tmd__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetRelayOutputState(struct soap*, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse &tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetDigitalInputs(struct soap*, _tmd__GetDigitalInputs *tmd__GetDigitalInputs, _tmd__GetDigitalInputsResponse &tmd__GetDigitalInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPorts(struct soap*, _tmd__GetSerialPorts *tmd__GetSerialPorts, _tmd__GetSerialPortsResponse &tmd__GetSerialPortsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPortConfiguration(struct soap*, _tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration, _tmd__GetSerialPortConfigurationResponse &tmd__GetSerialPortConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SetSerialPortConfiguration(struct soap*, _tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration, _tmd__SetSerialPortConfigurationResponse &tmd__SetSerialPortConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__GetSerialPortConfigurationOptions(struct soap*, _tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions, _tmd__GetSerialPortConfigurationOptionsResponse &tmd__GetSerialPortConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tmd__SendReceiveSerialCommand(struct soap*, _tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand, _tmd__SendReceiveSerialCommandResponse &tmd__SendReceiveSerialCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetServiceCapabilities(struct soap*, _tptz__GetServiceCapabilities *tptz__GetServiceCapabilities, _tptz__GetServiceCapabilitiesResponse &tptz__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurations(struct soap*, _tptz__GetConfigurations *tptz__GetConfigurations, _tptz__GetConfigurationsResponse &tptz__GetConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresets(struct soap*, _tptz__GetPresets *tptz__GetPresets, _tptz__GetPresetsResponse &tptz__GetPresetsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetPreset(struct soap*, _tptz__SetPreset *tptz__SetPreset, _tptz__SetPresetResponse &tptz__SetPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__RemovePreset(struct soap*, _tptz__RemovePreset *tptz__RemovePreset, _tptz__RemovePresetResponse &tptz__RemovePresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoPreset(struct soap*, _tptz__GotoPreset *tptz__GotoPreset, _tptz__GotoPresetResponse &tptz__GotoPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetStatus(struct soap*, _tptz__GetStatus *tptz__GetStatus, _tptz__GetStatusResponse &tptz__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfiguration(struct soap*, _tptz__GetConfiguration *tptz__GetConfiguration, _tptz__GetConfigurationResponse &tptz__GetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNodes(struct soap*, _tptz__GetNodes *tptz__GetNodes, _tptz__GetNodesResponse &tptz__GetNodesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetNode(struct soap*, _tptz__GetNode *tptz__GetNode, _tptz__GetNodeResponse &tptz__GetNodeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetConfiguration(struct soap*, _tptz__SetConfiguration *tptz__SetConfiguration, _tptz__SetConfigurationResponse &tptz__SetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetConfigurationOptions(struct soap*, _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions, _tptz__GetConfigurationOptionsResponse &tptz__GetConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GotoHomePosition(struct soap*, _tptz__GotoHomePosition *tptz__GotoHomePosition, _tptz__GotoHomePositionResponse &tptz__GotoHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SetHomePosition(struct soap*, _tptz__SetHomePosition *tptz__SetHomePosition, _tptz__SetHomePositionResponse &tptz__SetHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__ContinuousMove(struct soap*, _tptz__ContinuousMove *tptz__ContinuousMove, _tptz__ContinuousMoveResponse &tptz__ContinuousMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__RelativeMove(struct soap*, _tptz__RelativeMove *tptz__RelativeMove, _tptz__RelativeMoveResponse &tptz__RelativeMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__SendAuxiliaryCommand(struct soap*, _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand, _tptz__SendAuxiliaryCommandResponse &tptz__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__AbsoluteMove(struct soap*, _tptz__AbsoluteMove *tptz__AbsoluteMove, _tptz__AbsoluteMoveResponse &tptz__AbsoluteMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__Stop(struct soap*, _tptz__Stop *tptz__Stop, _tptz__StopResponse &tptz__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTours(struct soap*, _tptz__GetPresetTours *tptz__GetPresetTours, _tptz__GetPresetToursResponse &tptz__GetPresetToursResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTour(struct soap*, _tptz__GetPresetTour *tptz__GetPresetTour, _tptz__GetPresetTourResponse &tptz__GetPresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__GetPresetTourOptions(struct soap*, _tptz__GetPresetTourOptions *tptz__GetPresetTourOptions, _tptz__GetPresetTourOptionsResponse &tptz__GetPresetTourOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__CreatePresetTour(struct soap*, _tptz__CreatePresetTour *tptz__CreatePresetTour, _tptz__CreatePresetTourResponse &tptz__CreatePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__ModifyPresetTour(struct soap*, _tptz__ModifyPresetTour *tptz__ModifyPresetTour, _tptz__ModifyPresetTourResponse &tptz__ModifyPresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__OperatePresetTour(struct soap*, _tptz__OperatePresetTour *tptz__OperatePresetTour, _tptz__OperatePresetTourResponse &tptz__OperatePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tptz__RemovePresetTour(struct soap*, _tptz__RemovePresetTour *tptz__RemovePresetTour, _tptz__RemovePresetTourResponse &tptz__RemovePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetServiceCapabilities(struct soap*, _trc__GetServiceCapabilities *trc__GetServiceCapabilities, _trc__GetServiceCapabilitiesResponse &trc__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateRecording(struct soap*, _trc__CreateRecording *trc__CreateRecording, _trc__CreateRecordingResponse &trc__CreateRecordingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteRecording(struct soap*, _trc__DeleteRecording *trc__DeleteRecording, _trc__DeleteRecordingResponse &trc__DeleteRecordingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordings(struct soap*, _trc__GetRecordings *trc__GetRecordings, _trc__GetRecordingsResponse &trc__GetRecordingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingConfiguration(struct soap*, _trc__SetRecordingConfiguration *trc__SetRecordingConfiguration, _trc__SetRecordingConfigurationResponse &trc__SetRecordingConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingConfiguration(struct soap*, _trc__GetRecordingConfiguration *trc__GetRecordingConfiguration, _trc__GetRecordingConfigurationResponse &trc__GetRecordingConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingOptions(struct soap*, _trc__GetRecordingOptions *trc__GetRecordingOptions, _trc__GetRecordingOptionsResponse &trc__GetRecordingOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateTrack(struct soap*, _trc__CreateTrack *trc__CreateTrack, _trc__CreateTrackResponse &trc__CreateTrackResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteTrack(struct soap*, _trc__DeleteTrack *trc__DeleteTrack, _trc__DeleteTrackResponse &trc__DeleteTrackResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetTrackConfiguration(struct soap*, _trc__GetTrackConfiguration *trc__GetTrackConfiguration, _trc__GetTrackConfigurationResponse &trc__GetTrackConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__SetTrackConfiguration(struct soap*, _trc__SetTrackConfiguration *trc__SetTrackConfiguration, _trc__SetTrackConfigurationResponse &trc__SetTrackConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__CreateRecordingJob(struct soap*, _trc__CreateRecordingJob *trc__CreateRecordingJob, _trc__CreateRecordingJobResponse &trc__CreateRecordingJobResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__DeleteRecordingJob(struct soap*, _trc__DeleteRecordingJob *trc__DeleteRecordingJob, _trc__DeleteRecordingJobResponse &trc__DeleteRecordingJobResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobs(struct soap*, _trc__GetRecordingJobs *trc__GetRecordingJobs, _trc__GetRecordingJobsResponse &trc__GetRecordingJobsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingJobConfiguration(struct soap*, _trc__SetRecordingJobConfiguration *trc__SetRecordingJobConfiguration, _trc__SetRecordingJobConfigurationResponse &trc__SetRecordingJobConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobConfiguration(struct soap*, _trc__GetRecordingJobConfiguration *trc__GetRecordingJobConfiguration, _trc__GetRecordingJobConfigurationResponse &trc__GetRecordingJobConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__SetRecordingJobMode(struct soap*, _trc__SetRecordingJobMode *trc__SetRecordingJobMode, _trc__SetRecordingJobModeResponse &trc__SetRecordingJobModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trc__GetRecordingJobState(struct soap*, _trc__GetRecordingJobState *trc__GetRecordingJobState, _trc__GetRecordingJobStateResponse &trc__GetRecordingJobStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trp__GetServiceCapabilities(struct soap*, _trp__GetServiceCapabilities *trp__GetServiceCapabilities, _trp__GetServiceCapabilitiesResponse &trp__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trp__GetReplayUri(struct soap*, _trp__GetReplayUri *trp__GetReplayUri, _trp__GetReplayUriResponse &trp__GetReplayUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trp__GetReplayConfiguration(struct soap*, _trp__GetReplayConfiguration *trp__GetReplayConfiguration, _trp__GetReplayConfigurationResponse &trp__GetReplayConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trp__SetReplayConfiguration(struct soap*, _trp__SetReplayConfiguration *trp__SetReplayConfiguration, _trp__SetReplayConfigurationResponse &trp__SetReplayConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetServiceCapabilities(struct soap*, _trt__GetServiceCapabilities *trt__GetServiceCapabilities, _trt__GetServiceCapabilitiesResponse &trt__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSources(struct soap*, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse &trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSources(struct soap*, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse &trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputs(struct soap*, _trt__GetAudioOutputs *trt__GetAudioOutputs, _trt__GetAudioOutputsResponse &trt__GetAudioOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__CreateProfile(struct soap*, _trt__CreateProfile *trt__CreateProfile, _trt__CreateProfileResponse &trt__CreateProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfile(struct soap*, _trt__GetProfile *trt__GetProfile, _trt__GetProfileResponse &trt__GetProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetProfiles(struct soap*, _trt__GetProfiles *trt__GetProfiles, _trt__GetProfilesResponse &trt__GetProfilesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoEncoderConfiguration(struct soap*, _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, _trt__AddVideoEncoderConfigurationResponse &trt__AddVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoSourceConfiguration(struct soap*, _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, _trt__AddVideoSourceConfigurationResponse &trt__AddVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioEncoderConfiguration(struct soap*, _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, _trt__AddAudioEncoderConfigurationResponse &trt__AddAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioSourceConfiguration(struct soap*, _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, _trt__AddAudioSourceConfigurationResponse &trt__AddAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddPTZConfiguration(struct soap*, _trt__AddPTZConfiguration *trt__AddPTZConfiguration, _trt__AddPTZConfigurationResponse &trt__AddPTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddVideoAnalyticsConfiguration(struct soap*, _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, _trt__AddVideoAnalyticsConfigurationResponse &trt__AddVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddMetadataConfiguration(struct soap*, _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, _trt__AddMetadataConfigurationResponse &trt__AddMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioOutputConfiguration(struct soap*, _trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration, _trt__AddAudioOutputConfigurationResponse &trt__AddAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__AddAudioDecoderConfiguration(struct soap*, _trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration, _trt__AddAudioDecoderConfigurationResponse &trt__AddAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoEncoderConfiguration(struct soap*, _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, _trt__RemoveVideoEncoderConfigurationResponse &trt__RemoveVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoSourceConfiguration(struct soap*, _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, _trt__RemoveVideoSourceConfigurationResponse &trt__RemoveVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioEncoderConfiguration(struct soap*, _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, _trt__RemoveAudioEncoderConfigurationResponse &trt__RemoveAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioSourceConfiguration(struct soap*, _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, _trt__RemoveAudioSourceConfigurationResponse &trt__RemoveAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemovePTZConfiguration(struct soap*, _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, _trt__RemovePTZConfigurationResponse &trt__RemovePTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveVideoAnalyticsConfiguration(struct soap*, _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, _trt__RemoveVideoAnalyticsConfigurationResponse &trt__RemoveVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveMetadataConfiguration(struct soap*, _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, _trt__RemoveMetadataConfigurationResponse &trt__RemoveMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioOutputConfiguration(struct soap*, _trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration, _trt__RemoveAudioOutputConfigurationResponse &trt__RemoveAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__RemoveAudioDecoderConfiguration(struct soap*, _trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration, _trt__RemoveAudioDecoderConfigurationResponse &trt__RemoveAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__DeleteProfile(struct soap*, _trt__DeleteProfile *trt__DeleteProfile, _trt__DeleteProfileResponse &trt__DeleteProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurations(struct soap*, _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, _trt__GetVideoSourceConfigurationsResponse &trt__GetVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurations(struct soap*, _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, _trt__GetVideoEncoderConfigurationsResponse &trt__GetVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurations(struct soap*, _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, _trt__GetAudioSourceConfigurationsResponse &trt__GetAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurations(struct soap*, _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, _trt__GetAudioEncoderConfigurationsResponse &trt__GetAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfigurations(struct soap*, _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, _trt__GetVideoAnalyticsConfigurationsResponse &trt__GetVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurations(struct soap*, _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, _trt__GetMetadataConfigurationsResponse &trt__GetMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfigurations(struct soap*, _trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations, _trt__GetAudioOutputConfigurationsResponse &trt__GetAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfigurations(struct soap*, _trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations, _trt__GetAudioDecoderConfigurationsResponse &trt__GetAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfiguration(struct soap*, _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, _trt__GetVideoSourceConfigurationResponse &trt__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfiguration(struct soap*, _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, _trt__GetVideoEncoderConfigurationResponse &trt__GetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfiguration(struct soap*, _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, _trt__GetAudioSourceConfigurationResponse &trt__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfiguration(struct soap*, _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, _trt__GetAudioEncoderConfigurationResponse &trt__GetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoAnalyticsConfiguration(struct soap*, _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, _trt__GetVideoAnalyticsConfigurationResponse &trt__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfiguration(struct soap*, _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, _trt__GetMetadataConfigurationResponse &trt__GetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfiguration(struct soap*, _trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration, _trt__GetAudioOutputConfigurationResponse &trt__GetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfiguration(struct soap*, _trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration, _trt__GetAudioDecoderConfigurationResponse &trt__GetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoEncoderConfigurations(struct soap*, _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, _trt__GetCompatibleVideoEncoderConfigurationsResponse &trt__GetCompatibleVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoSourceConfigurations(struct soap*, _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, _trt__GetCompatibleVideoSourceConfigurationsResponse &trt__GetCompatibleVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioEncoderConfigurations(struct soap*, _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, _trt__GetCompatibleAudioEncoderConfigurationsResponse &trt__GetCompatibleAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioSourceConfigurations(struct soap*, _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, _trt__GetCompatibleAudioSourceConfigurationsResponse &trt__GetCompatibleAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse &trt__GetCompatibleVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleMetadataConfigurations(struct soap*, _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, _trt__GetCompatibleMetadataConfigurationsResponse &trt__GetCompatibleMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioOutputConfigurations(struct soap*, _trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations, _trt__GetCompatibleAudioOutputConfigurationsResponse &trt__GetCompatibleAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetCompatibleAudioDecoderConfigurations(struct soap*, _trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations, _trt__GetCompatibleAudioDecoderConfigurationsResponse &trt__GetCompatibleAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoSourceConfiguration(struct soap*, _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, _trt__SetVideoSourceConfigurationResponse &trt__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoEncoderConfiguration(struct soap*, _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, _trt__SetVideoEncoderConfigurationResponse &trt__SetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioSourceConfiguration(struct soap*, _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, _trt__SetAudioSourceConfigurationResponse &trt__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioEncoderConfiguration(struct soap*, _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, _trt__SetAudioEncoderConfigurationResponse &trt__SetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetVideoAnalyticsConfiguration(struct soap*, _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, _trt__SetVideoAnalyticsConfigurationResponse &trt__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetMetadataConfiguration(struct soap*, _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, _trt__SetMetadataConfigurationResponse &trt__SetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioOutputConfiguration(struct soap*, _trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration, _trt__SetAudioOutputConfigurationResponse &trt__SetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetAudioDecoderConfiguration(struct soap*, _trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration, _trt__SetAudioDecoderConfigurationResponse &trt__SetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoSourceConfigurationOptions(struct soap*, _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, _trt__GetVideoSourceConfigurationOptionsResponse &trt__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetVideoEncoderConfigurationOptions(struct soap*, _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, _trt__GetVideoEncoderConfigurationOptionsResponse &trt__GetVideoEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioSourceConfigurationOptions(struct soap*, _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, _trt__GetAudioSourceConfigurationOptionsResponse &trt__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioEncoderConfigurationOptions(struct soap*, _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, _trt__GetAudioEncoderConfigurationOptionsResponse &trt__GetAudioEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetMetadataConfigurationOptions(struct soap*, _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, _trt__GetMetadataConfigurationOptionsResponse &trt__GetMetadataConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioOutputConfigurationOptions(struct soap*, _trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions, _trt__GetAudioOutputConfigurationOptionsResponse &trt__GetAudioOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetAudioDecoderConfigurationOptions(struct soap*, _trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions, _trt__GetAudioDecoderConfigurationOptionsResponse &trt__GetAudioDecoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse &trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetStreamUri(struct soap*, _trt__GetStreamUri *trt__GetStreamUri, _trt__GetStreamUriResponse &trt__GetStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__StartMulticastStreaming(struct soap*, _trt__StartMulticastStreaming *trt__StartMulticastStreaming, _trt__StartMulticastStreamingResponse &trt__StartMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__StopMulticastStreaming(struct soap*, _trt__StopMulticastStreaming *trt__StopMulticastStreaming, _trt__StopMulticastStreamingResponse &trt__StopMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__SetSynchronizationPoint(struct soap*, _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, _trt__SetSynchronizationPointResponse &trt__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trt__GetSnapshotUri(struct soap*, _trt__GetSnapshotUri *trt__GetSnapshotUri, _trt__GetSnapshotUriResponse &trt__GetSnapshotUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__GetServiceCapabilities(struct soap*, _trv__GetServiceCapabilities *trv__GetServiceCapabilities, _trv__GetServiceCapabilitiesResponse &trv__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceivers(struct soap*, _trv__GetReceivers *trv__GetReceivers, _trv__GetReceiversResponse &trv__GetReceiversResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceiver(struct soap*, _trv__GetReceiver *trv__GetReceiver, _trv__GetReceiverResponse &trv__GetReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__CreateReceiver(struct soap*, _trv__CreateReceiver *trv__CreateReceiver, _trv__CreateReceiverResponse &trv__CreateReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__DeleteReceiver(struct soap*, _trv__DeleteReceiver *trv__DeleteReceiver, _trv__DeleteReceiverResponse &trv__DeleteReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__ConfigureReceiver(struct soap*, _trv__ConfigureReceiver *trv__ConfigureReceiver, _trv__ConfigureReceiverResponse &trv__ConfigureReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__SetReceiverMode(struct soap*, _trv__SetReceiverMode *trv__SetReceiverMode, _trv__SetReceiverModeResponse &trv__SetReceiverModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __trv__GetReceiverState(struct soap*, _trv__GetReceiverState *trv__GetReceiverState, _trv__GetReceiverStateResponse &trv__GetReceiverStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetServiceCapabilities(struct soap*, _tse__GetServiceCapabilities *tse__GetServiceCapabilities, _tse__GetServiceCapabilitiesResponse &tse__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingSummary(struct soap*, _tse__GetRecordingSummary *tse__GetRecordingSummary, _tse__GetRecordingSummaryResponse &tse__GetRecordingSummaryResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingInformation(struct soap*, _tse__GetRecordingInformation *tse__GetRecordingInformation, _tse__GetRecordingInformationResponse &tse__GetRecordingInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetMediaAttributes(struct soap*, _tse__GetMediaAttributes *tse__GetMediaAttributes, _tse__GetMediaAttributesResponse &tse__GetMediaAttributesResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__FindRecordings(struct soap*, _tse__FindRecordings *tse__FindRecordings, _tse__FindRecordingsResponse &tse__FindRecordingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetRecordingSearchResults(struct soap*, _tse__GetRecordingSearchResults *tse__GetRecordingSearchResults, _tse__GetRecordingSearchResultsResponse &tse__GetRecordingSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__FindEvents(struct soap*, _tse__FindEvents *tse__FindEvents, _tse__FindEventsResponse &tse__FindEventsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetEventSearchResults(struct soap*, _tse__GetEventSearchResults *tse__GetEventSearchResults, _tse__GetEventSearchResultsResponse &tse__GetEventSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__FindPTZPosition(struct soap*, _tse__FindPTZPosition *tse__FindPTZPosition, _tse__FindPTZPositionResponse &tse__FindPTZPositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetPTZPositionSearchResults(struct soap*, _tse__GetPTZPositionSearchResults *tse__GetPTZPositionSearchResults, _tse__GetPTZPositionSearchResultsResponse &tse__GetPTZPositionSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetSearchState(struct soap*, _tse__GetSearchState *tse__GetSearchState, _tse__GetSearchStateResponse &tse__GetSearchStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__EndSearch(struct soap*, _tse__EndSearch *tse__EndSearch, _tse__EndSearchResponse &tse__EndSearchResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__FindMetadata(struct soap*, _tse__FindMetadata *tse__FindMetadata, _tse__FindMetadataResponse &tse__FindMetadataResponse);

SOAP_FMAC5 int SOAP_FMAC6 __tse__GetMetadataSearchResults(struct soap*, _tse__GetMetadataSearchResults *tse__GetMetadataSearchResults, _tse__GetMetadataSearchResultsResponse &tse__GetMetadataSearchResultsResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_SOAP_ENV__Fault(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__Hello(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__Bye(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__Probe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__ProbeMatches(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__Resolve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___wsdd__ResolveMatches(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_SOAP_ENV__Fault_yz(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSupportedActions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetActions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CreateActions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__DeleteActions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ModifyActions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetActionTriggers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CreateActionTriggers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__DeleteActionTriggers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ModifyActionTriggers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetAccessPointInfoList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetAccessPointInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetAreaInfoList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetAreaInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__GetAccessPointState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__EnableAccessPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__DisableAccessPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns2__ExternalAuthorization(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__GetDoorInfoList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__GetDoorInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__GetDoorState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__AccessDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__LockDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__UnlockDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__BlockDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__LockDownDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__LockDownReleaseDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__LockOpenDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__LockOpenReleaseDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns4__DoubleLockDoor(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__DeleteAnalyticsEngineControl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__CreateAnalyticsEngineControl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__SetAnalyticsEngineControl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngineControl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngineControls(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngine(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngines(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__SetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__SetAnalyticsEngineInput(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngineInput(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsEngineInputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsDeviceStreamUri(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__CreateAnalyticsEngineInputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__DeleteAnalyticsEngineInputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tad__GetAnalyticsState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__GetSupportedRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__CreateRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__DeleteRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__GetRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__ModifyRules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__GetSupportedAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__CreateAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__DeleteAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__GetAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tan__ModifyAnalyticsModules(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tdn__Hello(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tdn__Bye(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tdn__Probe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetServices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDeviceInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetSystemDateAndTime(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemDateAndTime(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetSystemFactoryDefault(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__UpgradeSystemFirmware(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SystemReboot(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RestoreSystem(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemBackup(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemSupportInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__AddScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RemoveScopes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetRemoteDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRemoteDiscoveryMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDPAddresses(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetEndpointReference(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetRemoteUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRemoteUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__CreateUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__DeleteUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetWsdlUrl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDPAddresses(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetHostname(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetHostname(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetHostnameFromDHCP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNTP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNTP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDynamicDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDynamicDNS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkInterfaces(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkInterfaces(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkProtocols(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkProtocols(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetNetworkDefaultGateway(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetNetworkDefaultGateway(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetZeroConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetZeroConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__AddIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__RemoveIPAddressFilter(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetAccessPolicy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetAccessPolicy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__CreateCertificate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCertificatesStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetCertificatesStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__DeleteCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetPkcs10Request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__LoadCertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetClientCertificateMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetClientCertificateMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetRelayOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRelayOutputSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetRelayOutputState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SendAuxiliaryCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCACertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__LoadCertificateWithPrivateKey(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetCertificateInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__LoadCACertificates(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__CreateDot1XConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__SetDot1XConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDot1XConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDot1XConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__DeleteDot1XConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDot11Capabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetDot11Status(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__ScanAvailableDot11Networks(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__GetSystemUris(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__StartFirmwareUpgrade(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tds__StartSystemRestore(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__PullMessages(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Seek(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__SetSynchronizationPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__CreatePullPointSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__GetEventProperties(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Renew(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Unsubscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Subscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__GetCurrentMessage(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Notify(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__GetMessages(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__DestroyPullPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Notify_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__CreatePullPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Renew_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__Unsubscribe_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__PauseSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tev__ResumeSubscription(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__SetImagingSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Move(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__Stop(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___timg__GetMoveOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__GetLayout(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__SetLayout(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__GetDisplayOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__GetPaneConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__GetPaneConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__SetPaneConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__SetPaneConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__CreatePaneConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tls__DeletePaneConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetRelayOutputOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetVideoOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetVideoOutputConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetAudioOutputConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetRelayOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetRelayOutputSettings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetRelayOutputState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetDigitalInputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetSerialPorts(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetSerialPortConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SetSerialPortConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__GetSerialPortConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tmd__SendReceiveSerialCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetPresets(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetPreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__RemovePreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GotoPreset(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetNodes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetNode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GotoHomePosition(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SetHomePosition(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__ContinuousMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__RelativeMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__SendAuxiliaryCommand(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__AbsoluteMove(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__Stop(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetPresetTours(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetPresetTour(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__GetPresetTourOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__CreatePresetTour(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__ModifyPresetTour(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__OperatePresetTour(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tptz__RemovePresetTour(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__CreateRecording(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__DeleteRecording(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__SetRecordingConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordingConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordingOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__CreateTrack(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__DeleteTrack(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetTrackConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__SetTrackConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__CreateRecordingJob(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__DeleteRecordingJob(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordingJobs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__SetRecordingJobConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordingJobConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__SetRecordingJobMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trc__GetRecordingJobState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trp__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trp__GetReplayUri(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trp__GetReplayConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trp__SetReplayConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSources(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioOutputs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__CreateProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetProfiles(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddPTZConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__AddAudioDecoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemovePTZConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__RemoveAudioDecoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__DeleteProfile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoAnalyticsConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioOutputConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioDecoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioDecoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioEncoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioSourceConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleMetadataConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioOutputConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetCompatibleAudioDecoderConfigurations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioSourceConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioEncoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetVideoAnalyticsConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetMetadataConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioOutputConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetAudioDecoderConfiguration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetVideoEncoderConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioSourceConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioEncoderConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetMetadataConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioOutputConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetAudioDecoderConfigurationOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetStreamUri(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__StartMulticastStreaming(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__StopMulticastStreaming(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__SetSynchronizationPoint(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trt__GetSnapshotUri(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__GetReceivers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__GetReceiver(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__CreateReceiver(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__DeleteReceiver(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__ConfigureReceiver(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__SetReceiverMode(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___trv__GetReceiverState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetServiceCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetRecordingSummary(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetRecordingInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetMediaAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__FindRecordings(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetRecordingSearchResults(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__FindEvents(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetEventSearchResults(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__FindPTZPosition(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetPTZPositionSearchResults(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetSearchState(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__EndSearch(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__FindMetadata(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___tse__GetMetadataSearchResults(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_send_SOAP_ENV__Fault(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *_param_1);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__HelloType *wsdd__Hello);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *_param_2);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Bye(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ByeType *wsdd__Bye);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *_param_3);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Probe(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeType *wsdd__Probe);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *_param_4);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__ProbeMatches(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeMatchesType *wsdd__ProbeMatches);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *_param_5);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__Resolve(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ResolveType *wsdd__Resolve);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *_param_6);


SOAP_FMAC5 int SOAP_FMAC6 soap_send___wsdd__ResolveMatches(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ResolveMatchesType *wsdd__ResolveMatches);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *_param_7);


SOAP_FMAC5 int SOAP_FMAC6 soap_send_SOAP_ENV__Fault_yz(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv_SOAP_ENV__Fault_yz(struct soap *soap, struct SOAP_ENV__Fault_yz *_param_8);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSupportedActions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSupportedActions *ns1__GetSupportedActions, _ns1__GetSupportedActionsResponse &ns1__GetSupportedActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetActions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetActions *ns1__GetActions, _ns1__GetActionsResponse &ns1__GetActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CreateActions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateActions *ns1__CreateActions, _ns1__CreateActionsResponse &ns1__CreateActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DeleteActions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DeleteActions *ns1__DeleteActions, _ns1__DeleteActionsResponse &ns1__DeleteActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ModifyActions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ModifyActions *ns1__ModifyActions, _ns1__ModifyActionsResponse &ns1__ModifyActionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetServiceCapabilities *ns1__GetServiceCapabilities, _ns1__GetServiceCapabilitiesResponse &ns1__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetActionTriggers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetActionTriggers *ns1__GetActionTriggers, _ns1__GetActionTriggersResponse &ns1__GetActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CreateActionTriggers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateActionTriggers *ns1__CreateActionTriggers, _ns1__CreateActionTriggersResponse &ns1__CreateActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DeleteActionTriggers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DeleteActionTriggers *ns1__DeleteActionTriggers, _ns1__DeleteActionTriggersResponse &ns1__DeleteActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ModifyActionTriggers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ModifyActionTriggers *ns1__ModifyActionTriggers, _ns1__ModifyActionTriggersResponse &ns1__ModifyActionTriggersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetServiceCapabilities *ns2__GetServiceCapabilities, _ns2__GetServiceCapabilitiesResponse &ns2__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetAccessPointInfoList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetAccessPointInfoList *ns2__GetAccessPointInfoList, _ns2__GetAccessPointInfoListResponse &ns2__GetAccessPointInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetAccessPointInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetAccessPointInfo *ns2__GetAccessPointInfo, _ns2__GetAccessPointInfoResponse &ns2__GetAccessPointInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetAreaInfoList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetAreaInfoList *ns2__GetAreaInfoList, _ns2__GetAreaInfoListResponse &ns2__GetAreaInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetAreaInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetAreaInfo *ns2__GetAreaInfo, _ns2__GetAreaInfoResponse &ns2__GetAreaInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__GetAccessPointState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__GetAccessPointState *ns2__GetAccessPointState, _ns2__GetAccessPointStateResponse &ns2__GetAccessPointStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__EnableAccessPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__EnableAccessPoint *ns2__EnableAccessPoint, _ns2__EnableAccessPointResponse &ns2__EnableAccessPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__DisableAccessPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__DisableAccessPoint *ns2__DisableAccessPoint, _ns2__DisableAccessPointResponse &ns2__DisableAccessPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns2__ExternalAuthorization(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__ExternalAuthorization *ns2__ExternalAuthorization, _ns2__ExternalAuthorizationResponse &ns2__ExternalAuthorizationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetServiceCapabilities *ns4__GetServiceCapabilities, _ns4__GetServiceCapabilitiesResponse &ns4__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__GetDoorInfoList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetDoorInfoList *ns4__GetDoorInfoList, _ns4__GetDoorInfoListResponse &ns4__GetDoorInfoListResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__GetDoorInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetDoorInfo *ns4__GetDoorInfo, _ns4__GetDoorInfoResponse &ns4__GetDoorInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__GetDoorState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__GetDoorState *ns4__GetDoorState, _ns4__GetDoorStateResponse &ns4__GetDoorStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__AccessDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__AccessDoor *ns4__AccessDoor, _ns4__AccessDoorResponse &ns4__AccessDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__LockDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__LockDoor *ns4__LockDoor, _ns4__LockDoorResponse &ns4__LockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__UnlockDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__UnlockDoor *ns4__UnlockDoor, _ns4__UnlockDoorResponse &ns4__UnlockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__BlockDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__BlockDoor *ns4__BlockDoor, _ns4__BlockDoorResponse &ns4__BlockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__LockDownDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__LockDownDoor *ns4__LockDownDoor, _ns4__LockDownDoorResponse &ns4__LockDownDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__LockDownReleaseDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__LockDownReleaseDoor *ns4__LockDownReleaseDoor, _ns4__LockDownReleaseDoorResponse &ns4__LockDownReleaseDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__LockOpenDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__LockOpenDoor *ns4__LockOpenDoor, _ns4__LockOpenDoorResponse &ns4__LockOpenDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__LockOpenReleaseDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__LockOpenReleaseDoor *ns4__LockOpenReleaseDoor, _ns4__LockOpenReleaseDoorResponse &ns4__LockOpenReleaseDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns4__DoubleLockDoor(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns4__DoubleLockDoor *ns4__DoubleLockDoor, _ns4__DoubleLockDoorResponse &ns4__DoubleLockDoorResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetServiceCapabilities *tad__GetServiceCapabilities, _tad__GetServiceCapabilitiesResponse &tad__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__DeleteAnalyticsEngineControl *tad__DeleteAnalyticsEngineControl, _tad__DeleteAnalyticsEngineControlResponse &tad__DeleteAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__CreateAnalyticsEngineControl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__CreateAnalyticsEngineControl *tad__CreateAnalyticsEngineControl, _tad__CreateAnalyticsEngineControlResponse &tad__CreateAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__SetAnalyticsEngineControl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__SetAnalyticsEngineControl *tad__SetAnalyticsEngineControl, _tad__SetAnalyticsEngineControlResponse &tad__SetAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngineControl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngineControl *tad__GetAnalyticsEngineControl, _tad__GetAnalyticsEngineControlResponse &tad__GetAnalyticsEngineControlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngineControls(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngineControls *tad__GetAnalyticsEngineControls, _tad__GetAnalyticsEngineControlsResponse &tad__GetAnalyticsEngineControlsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngine(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngine *tad__GetAnalyticsEngine, _tad__GetAnalyticsEngineResponse &tad__GetAnalyticsEngineResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngines(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngines *tad__GetAnalyticsEngines, _tad__GetAnalyticsEnginesResponse &tad__GetAnalyticsEnginesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__SetVideoAnalyticsConfiguration *tad__SetVideoAnalyticsConfiguration, _tad__SetVideoAnalyticsConfigurationResponse &tad__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__SetAnalyticsEngineInput(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__SetAnalyticsEngineInput *tad__SetAnalyticsEngineInput, _tad__SetAnalyticsEngineInputResponse &tad__SetAnalyticsEngineInputResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngineInput(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngineInput *tad__GetAnalyticsEngineInput, _tad__GetAnalyticsEngineInputResponse &tad__GetAnalyticsEngineInputResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsEngineInputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsEngineInputs *tad__GetAnalyticsEngineInputs, _tad__GetAnalyticsEngineInputsResponse &tad__GetAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsDeviceStreamUri *tad__GetAnalyticsDeviceStreamUri, _tad__GetAnalyticsDeviceStreamUriResponse &tad__GetAnalyticsDeviceStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetVideoAnalyticsConfiguration *tad__GetVideoAnalyticsConfiguration, _tad__GetVideoAnalyticsConfigurationResponse &tad__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__CreateAnalyticsEngineInputs *tad__CreateAnalyticsEngineInputs, _tad__CreateAnalyticsEngineInputsResponse &tad__CreateAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__DeleteAnalyticsEngineInputs *tad__DeleteAnalyticsEngineInputs, _tad__DeleteAnalyticsEngineInputsResponse &tad__DeleteAnalyticsEngineInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tad__GetAnalyticsState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tad__GetAnalyticsState *tad__GetAnalyticsState, _tad__GetAnalyticsStateResponse &tad__GetAnalyticsStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__GetSupportedRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetSupportedRules *tan__GetSupportedRules, _tan__GetSupportedRulesResponse &tan__GetSupportedRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__CreateRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__CreateRules *tan__CreateRules, _tan__CreateRulesResponse &tan__CreateRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__DeleteRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__DeleteRules *tan__DeleteRules, _tan__DeleteRulesResponse &tan__DeleteRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__GetRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetRules *tan__GetRules, _tan__GetRulesResponse &tan__GetRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__ModifyRules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__ModifyRules *tan__ModifyRules, _tan__ModifyRulesResponse &tan__ModifyRulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetServiceCapabilities *tan__GetServiceCapabilities, _tan__GetServiceCapabilitiesResponse &tan__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__GetSupportedAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetSupportedAnalyticsModules *tan__GetSupportedAnalyticsModules, _tan__GetSupportedAnalyticsModulesResponse &tan__GetSupportedAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__CreateAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__CreateAnalyticsModules *tan__CreateAnalyticsModules, _tan__CreateAnalyticsModulesResponse &tan__CreateAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__DeleteAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__DeleteAnalyticsModules *tan__DeleteAnalyticsModules, _tan__DeleteAnalyticsModulesResponse &tan__DeleteAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__GetAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__GetAnalyticsModules *tan__GetAnalyticsModules, _tan__GetAnalyticsModulesResponse &tan__GetAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tan__ModifyAnalyticsModules(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tan__ModifyAnalyticsModules *tan__ModifyAnalyticsModules, _tan__ModifyAnalyticsModulesResponse &tan__ModifyAnalyticsModulesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Hello(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__HelloType tdn__Hello, struct wsdd__ResolveType &tdn__HelloResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Bye(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ByeType tdn__Bye, struct wsdd__ResolveType &tdn__ByeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tdn__Probe(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct wsdd__ProbeType tdn__Probe, struct wsdd__ProbeMatchesType &tdn__ProbeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetServices(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetServices *tds__GetServices, _tds__GetServicesResponse &tds__GetServicesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetServiceCapabilities *tds__GetServiceCapabilities, _tds__GetServiceCapabilitiesResponse &tds__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDeviceInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDeviceInformation *tds__GetDeviceInformation, _tds__GetDeviceInformationResponse &tds__GetDeviceInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime, _tds__SetSystemDateAndTimeResponse &tds__SetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemDateAndTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime, _tds__GetSystemDateAndTimeResponse &tds__GetSystemDateAndTimeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetSystemFactoryDefault(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault, _tds__SetSystemFactoryDefaultResponse &tds__SetSystemFactoryDefaultResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__UpgradeSystemFirmware(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware, _tds__UpgradeSystemFirmwareResponse &tds__UpgradeSystemFirmwareResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SystemReboot(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SystemReboot *tds__SystemReboot, _tds__SystemRebootResponse &tds__SystemRebootResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RestoreSystem(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RestoreSystem *tds__RestoreSystem, _tds__RestoreSystemResponse &tds__RestoreSystemResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemBackup(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemBackup *tds__GetSystemBackup, _tds__GetSystemBackupResponse &tds__GetSystemBackupResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemLog(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemLog *tds__GetSystemLog, _tds__GetSystemLogResponse &tds__GetSystemLogResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemSupportInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation, _tds__GetSystemSupportInformationResponse &tds__GetSystemSupportInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetScopes *tds__GetScopes, _tds__GetScopesResponse &tds__GetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetScopes *tds__SetScopes, _tds__SetScopesResponse &tds__SetScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddScopes *tds__AddScopes, _tds__AddScopesResponse &tds__AddScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveScopes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveScopes *tds__RemoveScopes, _tds__RemoveScopesResponse &tds__RemoveScopesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDiscoveryMode *tds__GetDiscoveryMode, _tds__GetDiscoveryModeResponse &tds__GetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDiscoveryMode *tds__SetDiscoveryMode, _tds__SetDiscoveryModeResponse &tds__SetDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode, _tds__GetRemoteDiscoveryModeResponse &tds__GetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode, _tds__SetRemoteDiscoveryModeResponse &tds__SetRemoteDiscoveryModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDPAddresses *tds__GetDPAddresses, _tds__GetDPAddressesResponse &tds__GetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetEndpointReference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetEndpointReference *tds__GetEndpointReference, _tds__GetEndpointReferenceResponse &tds__GetEndpointReferenceResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRemoteUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRemoteUser *tds__GetRemoteUser, _tds__GetRemoteUserResponse &tds__GetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRemoteUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRemoteUser *tds__SetRemoteUser, _tds__SetRemoteUserResponse &tds__SetRemoteUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetUsers *tds__GetUsers, _tds__GetUsersResponse &tds__GetUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateUsers *tds__CreateUsers, _tds__CreateUsersResponse &tds__CreateUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteUsers *tds__DeleteUsers, _tds__DeleteUsersResponse &tds__DeleteUsersResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetUser *tds__SetUser, _tds__SetUserResponse &tds__SetUserResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetWsdlUrl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetWsdlUrl *tds__GetWsdlUrl, _tds__GetWsdlUrlResponse &tds__GetWsdlUrlResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCapabilities *tds__GetCapabilities, _tds__GetCapabilitiesResponse &tds__GetCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDPAddresses(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDPAddresses *tds__SetDPAddresses, _tds__SetDPAddressesResponse &tds__SetDPAddressesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetHostname *tds__GetHostname, _tds__GetHostnameResponse &tds__GetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetHostname(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetHostname *tds__SetHostname, _tds__SetHostnameResponse &tds__SetHostnameResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetHostnameFromDHCP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP, _tds__SetHostnameFromDHCPResponse &tds__SetHostnameFromDHCPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDNS *tds__GetDNS, _tds__GetDNSResponse &tds__GetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDNS *tds__SetDNS, _tds__SetDNSResponse &tds__SetDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNTP *tds__GetNTP, _tds__GetNTPResponse &tds__GetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNTP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNTP *tds__SetNTP, _tds__SetNTPResponse &tds__SetNTPResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDynamicDNS *tds__GetDynamicDNS, _tds__GetDynamicDNSResponse &tds__GetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDynamicDNS(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDynamicDNS *tds__SetDynamicDNS, _tds__SetDynamicDNSResponse &tds__SetDynamicDNSResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces, _tds__GetNetworkInterfacesResponse &tds__GetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkInterfaces(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces, _tds__SetNetworkInterfacesResponse &tds__SetNetworkInterfacesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkProtocols *tds__GetNetworkProtocols, _tds__GetNetworkProtocolsResponse &tds__GetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkProtocols *tds__SetNetworkProtocols, _tds__SetNetworkProtocolsResponse &tds__SetNetworkProtocolsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway, _tds__GetNetworkDefaultGatewayResponse &tds__GetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetNetworkDefaultGateway(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway, _tds__SetNetworkDefaultGatewayResponse &tds__SetNetworkDefaultGatewayResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetZeroConfiguration *tds__GetZeroConfiguration, _tds__GetZeroConfigurationResponse &tds__GetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetZeroConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetZeroConfiguration *tds__SetZeroConfiguration, _tds__SetZeroConfigurationResponse &tds__SetZeroConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetIPAddressFilter *tds__GetIPAddressFilter, _tds__GetIPAddressFilterResponse &tds__GetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetIPAddressFilter *tds__SetIPAddressFilter, _tds__SetIPAddressFilterResponse &tds__SetIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__AddIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__AddIPAddressFilter *tds__AddIPAddressFilter, _tds__AddIPAddressFilterResponse &tds__AddIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__RemoveIPAddressFilter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter, _tds__RemoveIPAddressFilterResponse &tds__RemoveIPAddressFilterResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetAccessPolicy *tds__GetAccessPolicy, _tds__GetAccessPolicyResponse &tds__GetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetAccessPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetAccessPolicy *tds__SetAccessPolicy, _tds__SetAccessPolicyResponse &tds__SetAccessPolicyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateCertificate(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateCertificate *tds__CreateCertificate, _tds__CreateCertificateResponse &tds__CreateCertificateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificates *tds__GetCertificates, _tds__GetCertificatesResponse &tds__GetCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificatesStatus *tds__GetCertificatesStatus, _tds__GetCertificatesStatusResponse &tds__GetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetCertificatesStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetCertificatesStatus *tds__SetCertificatesStatus, _tds__SetCertificatesStatusResponse &tds__SetCertificatesStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteCertificates *tds__DeleteCertificates, _tds__DeleteCertificatesResponse &tds__DeleteCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetPkcs10Request(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetPkcs10Request *tds__GetPkcs10Request, _tds__GetPkcs10RequestResponse &tds__GetPkcs10RequestResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCertificates *tds__LoadCertificates, _tds__LoadCertificatesResponse &tds__LoadCertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetClientCertificateMode *tds__GetClientCertificateMode, _tds__GetClientCertificateModeResponse &tds__GetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetClientCertificateMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetClientCertificateMode *tds__SetClientCertificateMode, _tds__SetClientCertificateModeResponse &tds__SetClientCertificateModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetRelayOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse &tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings, _tds__SetRelayOutputSettingsResponse &tds__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetRelayOutputState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse &tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SendAuxiliaryCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand, _tds__SendAuxiliaryCommandResponse &tds__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCACertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCACertificates *tds__GetCACertificates, _tds__GetCACertificatesResponse &tds__GetCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey, _tds__LoadCertificateWithPrivateKeyResponse &tds__LoadCertificateWithPrivateKeyResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetCertificateInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetCertificateInformation *tds__GetCertificateInformation, _tds__GetCertificateInformationResponse &tds__GetCertificateInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__LoadCACertificates(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__LoadCACertificates *tds__LoadCACertificates, _tds__LoadCACertificatesResponse &tds__LoadCACertificatesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__CreateDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration, _tds__CreateDot1XConfigurationResponse &tds__CreateDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__SetDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration, _tds__SetDot1XConfigurationResponse &tds__SetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration, _tds__GetDot1XConfigurationResponse &tds__GetDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot1XConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations, _tds__GetDot1XConfigurationsResponse &tds__GetDot1XConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__DeleteDot1XConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration, _tds__DeleteDot1XConfigurationResponse &tds__DeleteDot1XConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot11Capabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot11Capabilities *tds__GetDot11Capabilities, _tds__GetDot11CapabilitiesResponse &tds__GetDot11CapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetDot11Status(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetDot11Status *tds__GetDot11Status, _tds__GetDot11StatusResponse &tds__GetDot11StatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__ScanAvailableDot11Networks(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks, _tds__ScanAvailableDot11NetworksResponse &tds__ScanAvailableDot11NetworksResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__GetSystemUris(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetSystemUris *tds__GetSystemUris, _tds__GetSystemUrisResponse &tds__GetSystemUrisResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__StartFirmwareUpgrade(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade, _tds__StartFirmwareUpgradeResponse &tds__StartFirmwareUpgradeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tds__StartSystemRestore(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__StartSystemRestore *tds__StartSystemRestore, _tds__StartSystemRestoreResponse &tds__StartSystemRestoreResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__PullMessages(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__PullMessages *tev__PullMessages, _tev__PullMessagesResponse &tev__PullMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Seek(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__Seek *tev__Seek, _tev__SeekResponse &tev__SeekResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__SetSynchronizationPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint, _tev__SetSynchronizationPointResponse &tev__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__GetServiceCapabilities *tev__GetServiceCapabilities, _tev__GetServiceCapabilitiesResponse &tev__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__CreatePullPointSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription, _tev__CreatePullPointSubscriptionResponse &tev__CreatePullPointSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__GetEventProperties(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tev__GetEventProperties *tev__GetEventProperties, _tev__GetEventPropertiesResponse &tev__GetEventPropertiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Renew(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Renew *wsnt__Renew, _wsnt__RenewResponse &wsnt__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Unsubscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Unsubscribe *wsnt__Unsubscribe, _wsnt__UnsubscribeResponse &wsnt__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Subscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Subscribe *wsnt__Subscribe, _wsnt__SubscribeResponse &wsnt__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__GetCurrentMessage(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__GetCurrentMessage *wsnt__GetCurrentMessage, _wsnt__GetCurrentMessageResponse &wsnt__GetCurrentMessageResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_send___tev__Notify(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Notify *wsnt__Notify);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___tev__Notify(struct soap *soap, struct __tev__Notify *_param_9);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__GetMessages(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__GetMessages *wsnt__GetMessages, _wsnt__GetMessagesResponse &wsnt__GetMessagesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__DestroyPullPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__DestroyPullPoint *wsnt__DestroyPullPoint, _wsnt__DestroyPullPointResponse &wsnt__DestroyPullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_send___tev__Notify_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Notify *wsnt__Notify);

SOAP_FMAC5 int SOAP_FMAC6 soap_recv___tev__Notify_(struct soap *soap, struct __tev__Notify_ *_param_10);


SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__CreatePullPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__CreatePullPoint *wsnt__CreatePullPoint, _wsnt__CreatePullPointResponse &wsnt__CreatePullPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Renew_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Renew *wsnt__Renew, _wsnt__RenewResponse &wsnt__RenewResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__Unsubscribe_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__Unsubscribe *wsnt__Unsubscribe, _wsnt__UnsubscribeResponse &wsnt__UnsubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__PauseSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__PauseSubscription *wsnt__PauseSubscription, _wsnt__PauseSubscriptionResponse &wsnt__PauseSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tev__ResumeSubscription(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wsnt__ResumeSubscription *wsnt__ResumeSubscription, _wsnt__ResumeSubscriptionResponse &wsnt__ResumeSubscriptionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetServiceCapabilities *timg__GetServiceCapabilities, _timg__GetServiceCapabilitiesResponse &timg__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetImagingSettings *timg__GetImagingSettings, _timg__GetImagingSettingsResponse &timg__GetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__SetImagingSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__SetImagingSettings *timg__SetImagingSettings, _timg__SetImagingSettingsResponse &timg__SetImagingSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetOptions *timg__GetOptions, _timg__GetOptionsResponse &timg__GetOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Move(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Move *timg__Move, _timg__MoveResponse &timg__MoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__Stop *timg__Stop, _timg__StopResponse &timg__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetStatus *timg__GetStatus, _timg__GetStatusResponse &timg__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___timg__GetMoveOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _timg__GetMoveOptions *timg__GetMoveOptions, _timg__GetMoveOptionsResponse &timg__GetMoveOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__GetServiceCapabilities *tls__GetServiceCapabilities, _tls__GetServiceCapabilitiesResponse &tls__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__GetLayout(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__GetLayout *tls__GetLayout, _tls__GetLayoutResponse &tls__GetLayoutResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__SetLayout(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__SetLayout *tls__SetLayout, _tls__SetLayoutResponse &tls__SetLayoutResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__GetDisplayOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__GetDisplayOptions *tls__GetDisplayOptions, _tls__GetDisplayOptionsResponse &tls__GetDisplayOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__GetPaneConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__GetPaneConfigurations *tls__GetPaneConfigurations, _tls__GetPaneConfigurationsResponse &tls__GetPaneConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__GetPaneConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__GetPaneConfiguration *tls__GetPaneConfiguration, _tls__GetPaneConfigurationResponse &tls__GetPaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__SetPaneConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__SetPaneConfigurations *tls__SetPaneConfigurations, _tls__SetPaneConfigurationsResponse &tls__SetPaneConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__SetPaneConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__SetPaneConfiguration *tls__SetPaneConfiguration, _tls__SetPaneConfigurationResponse &tls__SetPaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__CreatePaneConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__CreatePaneConfiguration *tls__CreatePaneConfiguration, _tls__CreatePaneConfigurationResponse &tls__CreatePaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tls__DeletePaneConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tls__DeletePaneConfiguration *tls__DeletePaneConfiguration, _tls__DeletePaneConfigurationResponse &tls__DeletePaneConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetServiceCapabilities *tmd__GetServiceCapabilities, _tmd__GetServiceCapabilitiesResponse &tmd__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetRelayOutputOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions, _tmd__GetRelayOutputOptionsResponse &tmd__GetRelayOutputOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse &trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputs *trt__GetAudioOutputs, _trt__GetAudioOutputsResponse &trt__GetAudioOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse &trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetVideoOutputs *tmd__GetVideoOutputs, _tmd__GetVideoOutputsResponse &tmd__GetVideoOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration, _tmd__GetVideoSourceConfigurationResponse &tmd__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration, _tmd__GetVideoOutputConfigurationResponse &tmd__GetVideoOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration, _tmd__GetAudioSourceConfigurationResponse &tmd__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration, _tmd__GetAudioOutputConfigurationResponse &tmd__GetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration, _tmd__SetVideoSourceConfigurationResponse &tmd__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetVideoOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration, _tmd__SetVideoOutputConfigurationResponse &tmd__SetVideoOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration, _tmd__SetAudioSourceConfigurationResponse &tmd__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration, _tmd__SetAudioOutputConfigurationResponse &tmd__SetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions, _tmd__GetVideoSourceConfigurationOptionsResponse &tmd__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions, _tmd__GetVideoOutputConfigurationOptionsResponse &tmd__GetVideoOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions, _tmd__GetAudioSourceConfigurationOptionsResponse &tmd__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions, _tmd__GetAudioOutputConfigurationOptionsResponse &tmd__GetAudioOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetRelayOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__GetRelayOutputs *tds__GetRelayOutputs, _tds__GetRelayOutputsResponse &tds__GetRelayOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetRelayOutputSettings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings, _tmd__SetRelayOutputSettingsResponse &tmd__SetRelayOutputSettingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetRelayOutputState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tds__SetRelayOutputState *tds__SetRelayOutputState, _tds__SetRelayOutputStateResponse &tds__SetRelayOutputStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetDigitalInputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetDigitalInputs *tmd__GetDigitalInputs, _tmd__GetDigitalInputsResponse &tmd__GetDigitalInputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetSerialPorts(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetSerialPorts *tmd__GetSerialPorts, _tmd__GetSerialPortsResponse &tmd__GetSerialPortsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetSerialPortConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration, _tmd__GetSerialPortConfigurationResponse &tmd__GetSerialPortConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SetSerialPortConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration, _tmd__SetSerialPortConfigurationResponse &tmd__SetSerialPortConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__GetSerialPortConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions, _tmd__GetSerialPortConfigurationOptionsResponse &tmd__GetSerialPortConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tmd__SendReceiveSerialCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand, _tmd__SendReceiveSerialCommandResponse &tmd__SendReceiveSerialCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetServiceCapabilities *tptz__GetServiceCapabilities, _tptz__GetServiceCapabilitiesResponse &tptz__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfigurations *tptz__GetConfigurations, _tptz__GetConfigurationsResponse &tptz__GetConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetPresets(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetPresets *tptz__GetPresets, _tptz__GetPresetsResponse &tptz__GetPresetsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetPreset *tptz__SetPreset, _tptz__SetPresetResponse &tptz__SetPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__RemovePreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__RemovePreset *tptz__RemovePreset, _tptz__RemovePresetResponse &tptz__RemovePresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GotoPreset(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GotoPreset *tptz__GotoPreset, _tptz__GotoPresetResponse &tptz__GotoPresetResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetStatus *tptz__GetStatus, _tptz__GetStatusResponse &tptz__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfiguration *tptz__GetConfiguration, _tptz__GetConfigurationResponse &tptz__GetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetNodes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetNodes *tptz__GetNodes, _tptz__GetNodesResponse &tptz__GetNodesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetNode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetNode *tptz__GetNode, _tptz__GetNodeResponse &tptz__GetNodeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetConfiguration *tptz__SetConfiguration, _tptz__SetConfigurationResponse &tptz__SetConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions, _tptz__GetConfigurationOptionsResponse &tptz__GetConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GotoHomePosition(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GotoHomePosition *tptz__GotoHomePosition, _tptz__GotoHomePositionResponse &tptz__GotoHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SetHomePosition(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SetHomePosition *tptz__SetHomePosition, _tptz__SetHomePositionResponse &tptz__SetHomePositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__ContinuousMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__ContinuousMove *tptz__ContinuousMove, _tptz__ContinuousMoveResponse &tptz__ContinuousMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__RelativeMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__RelativeMove *tptz__RelativeMove, _tptz__RelativeMoveResponse &tptz__RelativeMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__SendAuxiliaryCommand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand, _tptz__SendAuxiliaryCommandResponse &tptz__SendAuxiliaryCommandResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__AbsoluteMove(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__AbsoluteMove *tptz__AbsoluteMove, _tptz__AbsoluteMoveResponse &tptz__AbsoluteMoveResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__Stop(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__Stop *tptz__Stop, _tptz__StopResponse &tptz__StopResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetPresetTours(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetPresetTours *tptz__GetPresetTours, _tptz__GetPresetToursResponse &tptz__GetPresetToursResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetPresetTour(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetPresetTour *tptz__GetPresetTour, _tptz__GetPresetTourResponse &tptz__GetPresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__GetPresetTourOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__GetPresetTourOptions *tptz__GetPresetTourOptions, _tptz__GetPresetTourOptionsResponse &tptz__GetPresetTourOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__CreatePresetTour(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__CreatePresetTour *tptz__CreatePresetTour, _tptz__CreatePresetTourResponse &tptz__CreatePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__ModifyPresetTour(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__ModifyPresetTour *tptz__ModifyPresetTour, _tptz__ModifyPresetTourResponse &tptz__ModifyPresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__OperatePresetTour(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__OperatePresetTour *tptz__OperatePresetTour, _tptz__OperatePresetTourResponse &tptz__OperatePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tptz__RemovePresetTour(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tptz__RemovePresetTour *tptz__RemovePresetTour, _tptz__RemovePresetTourResponse &tptz__RemovePresetTourResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetServiceCapabilities *trc__GetServiceCapabilities, _trc__GetServiceCapabilitiesResponse &trc__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__CreateRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__CreateRecording *trc__CreateRecording, _trc__CreateRecordingResponse &trc__CreateRecordingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__DeleteRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__DeleteRecording *trc__DeleteRecording, _trc__DeleteRecordingResponse &trc__DeleteRecordingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordings *trc__GetRecordings, _trc__GetRecordingsResponse &trc__GetRecordingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__SetRecordingConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__SetRecordingConfiguration *trc__SetRecordingConfiguration, _trc__SetRecordingConfigurationResponse &trc__SetRecordingConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordingConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordingConfiguration *trc__GetRecordingConfiguration, _trc__GetRecordingConfigurationResponse &trc__GetRecordingConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordingOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordingOptions *trc__GetRecordingOptions, _trc__GetRecordingOptionsResponse &trc__GetRecordingOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__CreateTrack(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__CreateTrack *trc__CreateTrack, _trc__CreateTrackResponse &trc__CreateTrackResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__DeleteTrack(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__DeleteTrack *trc__DeleteTrack, _trc__DeleteTrackResponse &trc__DeleteTrackResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetTrackConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetTrackConfiguration *trc__GetTrackConfiguration, _trc__GetTrackConfigurationResponse &trc__GetTrackConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__SetTrackConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__SetTrackConfiguration *trc__SetTrackConfiguration, _trc__SetTrackConfigurationResponse &trc__SetTrackConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__CreateRecordingJob(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__CreateRecordingJob *trc__CreateRecordingJob, _trc__CreateRecordingJobResponse &trc__CreateRecordingJobResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__DeleteRecordingJob(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__DeleteRecordingJob *trc__DeleteRecordingJob, _trc__DeleteRecordingJobResponse &trc__DeleteRecordingJobResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordingJobs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordingJobs *trc__GetRecordingJobs, _trc__GetRecordingJobsResponse &trc__GetRecordingJobsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__SetRecordingJobConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__SetRecordingJobConfiguration *trc__SetRecordingJobConfiguration, _trc__SetRecordingJobConfigurationResponse &trc__SetRecordingJobConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordingJobConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordingJobConfiguration *trc__GetRecordingJobConfiguration, _trc__GetRecordingJobConfigurationResponse &trc__GetRecordingJobConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__SetRecordingJobMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__SetRecordingJobMode *trc__SetRecordingJobMode, _trc__SetRecordingJobModeResponse &trc__SetRecordingJobModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trc__GetRecordingJobState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trc__GetRecordingJobState *trc__GetRecordingJobState, _trc__GetRecordingJobStateResponse &trc__GetRecordingJobStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trp__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trp__GetServiceCapabilities *trp__GetServiceCapabilities, _trp__GetServiceCapabilitiesResponse &trp__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trp__GetReplayUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trp__GetReplayUri *trp__GetReplayUri, _trp__GetReplayUriResponse &trp__GetReplayUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trp__GetReplayConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trp__GetReplayConfiguration *trp__GetReplayConfiguration, _trp__GetReplayConfigurationResponse &trp__GetReplayConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trp__SetReplayConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trp__SetReplayConfiguration *trp__SetReplayConfiguration, _trp__SetReplayConfigurationResponse &trp__SetReplayConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetServiceCapabilities *trt__GetServiceCapabilities, _trt__GetServiceCapabilitiesResponse &trt__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSources *trt__GetVideoSources, _trt__GetVideoSourcesResponse &trt__GetVideoSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSources(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSources *trt__GetAudioSources, _trt__GetAudioSourcesResponse &trt__GetAudioSourcesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputs *trt__GetAudioOutputs, _trt__GetAudioOutputsResponse &trt__GetAudioOutputsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__CreateProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__CreateProfile *trt__CreateProfile, _trt__CreateProfileResponse &trt__CreateProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfile *trt__GetProfile, _trt__GetProfileResponse &trt__GetProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetProfiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetProfiles *trt__GetProfiles, _trt__GetProfilesResponse &trt__GetProfilesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration, _trt__AddVideoEncoderConfigurationResponse &trt__AddVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration, _trt__AddVideoSourceConfigurationResponse &trt__AddVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration, _trt__AddAudioEncoderConfigurationResponse &trt__AddAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration, _trt__AddAudioSourceConfigurationResponse &trt__AddAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddPTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddPTZConfiguration *trt__AddPTZConfiguration, _trt__AddPTZConfigurationResponse &trt__AddPTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration, _trt__AddVideoAnalyticsConfigurationResponse &trt__AddVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration, _trt__AddMetadataConfigurationResponse &trt__AddMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration, _trt__AddAudioOutputConfigurationResponse &trt__AddAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration, _trt__AddAudioDecoderConfigurationResponse &trt__AddAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration, _trt__RemoveVideoEncoderConfigurationResponse &trt__RemoveVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration, _trt__RemoveVideoSourceConfigurationResponse &trt__RemoveVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration, _trt__RemoveAudioEncoderConfigurationResponse &trt__RemoveAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration, _trt__RemoveAudioSourceConfigurationResponse &trt__RemoveAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemovePTZConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration, _trt__RemovePTZConfigurationResponse &trt__RemovePTZConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration, _trt__RemoveVideoAnalyticsConfigurationResponse &trt__RemoveVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration, _trt__RemoveMetadataConfigurationResponse &trt__RemoveMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration, _trt__RemoveAudioOutputConfigurationResponse &trt__RemoveAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration, _trt__RemoveAudioDecoderConfigurationResponse &trt__RemoveAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__DeleteProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__DeleteProfile *trt__DeleteProfile, _trt__DeleteProfileResponse &trt__DeleteProfileResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations, _trt__GetVideoSourceConfigurationsResponse &trt__GetVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations, _trt__GetVideoEncoderConfigurationsResponse &trt__GetVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations, _trt__GetAudioSourceConfigurationsResponse &trt__GetAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations, _trt__GetAudioEncoderConfigurationsResponse &trt__GetAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations, _trt__GetVideoAnalyticsConfigurationsResponse &trt__GetVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations, _trt__GetMetadataConfigurationsResponse &trt__GetMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations, _trt__GetAudioOutputConfigurationsResponse &trt__GetAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations, _trt__GetAudioDecoderConfigurationsResponse &trt__GetAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration, _trt__GetVideoSourceConfigurationResponse &trt__GetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration, _trt__GetVideoEncoderConfigurationResponse &trt__GetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration, _trt__GetAudioSourceConfigurationResponse &trt__GetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration, _trt__GetAudioEncoderConfigurationResponse &trt__GetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration, _trt__GetVideoAnalyticsConfigurationResponse &trt__GetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration, _trt__GetMetadataConfigurationResponse &trt__GetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration, _trt__GetAudioOutputConfigurationResponse &trt__GetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration, _trt__GetAudioDecoderConfigurationResponse &trt__GetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations, _trt__GetCompatibleVideoEncoderConfigurationsResponse &trt__GetCompatibleVideoEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations, _trt__GetCompatibleVideoSourceConfigurationsResponse &trt__GetCompatibleVideoSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations, _trt__GetCompatibleAudioEncoderConfigurationsResponse &trt__GetCompatibleAudioEncoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations, _trt__GetCompatibleAudioSourceConfigurationsResponse &trt__GetCompatibleAudioSourceConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse &trt__GetCompatibleVideoAnalyticsConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations, _trt__GetCompatibleMetadataConfigurationsResponse &trt__GetCompatibleMetadataConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations, _trt__GetCompatibleAudioOutputConfigurationsResponse &trt__GetCompatibleAudioOutputConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations, _trt__GetCompatibleAudioDecoderConfigurationsResponse &trt__GetCompatibleAudioDecoderConfigurationsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration, _trt__SetVideoSourceConfigurationResponse &trt__SetVideoSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration, _trt__SetVideoEncoderConfigurationResponse &trt__SetVideoEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioSourceConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration, _trt__SetAudioSourceConfigurationResponse &trt__SetAudioSourceConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration, _trt__SetAudioEncoderConfigurationResponse &trt__SetAudioEncoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration, _trt__SetVideoAnalyticsConfigurationResponse &trt__SetVideoAnalyticsConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetMetadataConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration, _trt__SetMetadataConfigurationResponse &trt__SetMetadataConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioOutputConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration, _trt__SetAudioOutputConfigurationResponse &trt__SetAudioOutputConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration, _trt__SetAudioDecoderConfigurationResponse &trt__SetAudioDecoderConfigurationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions, _trt__GetVideoSourceConfigurationOptionsResponse &trt__GetVideoSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions, _trt__GetVideoEncoderConfigurationOptionsResponse &trt__GetVideoEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions, _trt__GetAudioSourceConfigurationOptionsResponse &trt__GetAudioSourceConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions, _trt__GetAudioEncoderConfigurationOptionsResponse &trt__GetAudioEncoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions, _trt__GetMetadataConfigurationOptionsResponse &trt__GetMetadataConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions, _trt__GetAudioOutputConfigurationOptionsResponse &trt__GetAudioOutputConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions, _trt__GetAudioDecoderConfigurationOptionsResponse &trt__GetAudioDecoderConfigurationOptionsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse &trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetStreamUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetStreamUri *trt__GetStreamUri, _trt__GetStreamUriResponse &trt__GetStreamUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StartMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StartMulticastStreaming *trt__StartMulticastStreaming, _trt__StartMulticastStreamingResponse &trt__StartMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__StopMulticastStreaming(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__StopMulticastStreaming *trt__StopMulticastStreaming, _trt__StopMulticastStreamingResponse &trt__StopMulticastStreamingResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__SetSynchronizationPoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint, _trt__SetSynchronizationPointResponse &trt__SetSynchronizationPointResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trt__GetSnapshotUri(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trt__GetSnapshotUri *trt__GetSnapshotUri, _trt__GetSnapshotUriResponse &trt__GetSnapshotUriResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__GetServiceCapabilities *trv__GetServiceCapabilities, _trv__GetServiceCapabilitiesResponse &trv__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__GetReceivers(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__GetReceivers *trv__GetReceivers, _trv__GetReceiversResponse &trv__GetReceiversResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__GetReceiver(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__GetReceiver *trv__GetReceiver, _trv__GetReceiverResponse &trv__GetReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__CreateReceiver(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__CreateReceiver *trv__CreateReceiver, _trv__CreateReceiverResponse &trv__CreateReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__DeleteReceiver(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__DeleteReceiver *trv__DeleteReceiver, _trv__DeleteReceiverResponse &trv__DeleteReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__ConfigureReceiver(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__ConfigureReceiver *trv__ConfigureReceiver, _trv__ConfigureReceiverResponse &trv__ConfigureReceiverResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__SetReceiverMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__SetReceiverMode *trv__SetReceiverMode, _trv__SetReceiverModeResponse &trv__SetReceiverModeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___trv__GetReceiverState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _trv__GetReceiverState *trv__GetReceiverState, _trv__GetReceiverStateResponse &trv__GetReceiverStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetServiceCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetServiceCapabilities *tse__GetServiceCapabilities, _tse__GetServiceCapabilitiesResponse &tse__GetServiceCapabilitiesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetRecordingSummary(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetRecordingSummary *tse__GetRecordingSummary, _tse__GetRecordingSummaryResponse &tse__GetRecordingSummaryResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetRecordingInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetRecordingInformation *tse__GetRecordingInformation, _tse__GetRecordingInformationResponse &tse__GetRecordingInformationResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetMediaAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetMediaAttributes *tse__GetMediaAttributes, _tse__GetMediaAttributesResponse &tse__GetMediaAttributesResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__FindRecordings(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__FindRecordings *tse__FindRecordings, _tse__FindRecordingsResponse &tse__FindRecordingsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetRecordingSearchResults(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetRecordingSearchResults *tse__GetRecordingSearchResults, _tse__GetRecordingSearchResultsResponse &tse__GetRecordingSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__FindEvents(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__FindEvents *tse__FindEvents, _tse__FindEventsResponse &tse__FindEventsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetEventSearchResults(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetEventSearchResults *tse__GetEventSearchResults, _tse__GetEventSearchResultsResponse &tse__GetEventSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__FindPTZPosition(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__FindPTZPosition *tse__FindPTZPosition, _tse__FindPTZPositionResponse &tse__FindPTZPositionResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetPTZPositionSearchResults(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetPTZPositionSearchResults *tse__GetPTZPositionSearchResults, _tse__GetPTZPositionSearchResultsResponse &tse__GetPTZPositionSearchResultsResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetSearchState(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetSearchState *tse__GetSearchState, _tse__GetSearchStateResponse &tse__GetSearchStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__EndSearch(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__EndSearch *tse__EndSearch, _tse__EndSearchResponse &tse__EndSearchResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__FindMetadata(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__FindMetadata *tse__FindMetadata, _tse__FindMetadataResponse &tse__FindMetadataResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___tse__GetMetadataSearchResults(struct soap *soap, const char *soap_endpoint, const char *soap_action, _tse__GetMetadataSearchResults *tse__GetMetadataSearchResults, _tse__GetMetadataSearchResultsResponse &tse__GetMetadataSearchResultsResponse);

#endif

/* End of soapStub.h */
